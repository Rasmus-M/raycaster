*********************************************************************
*
* Raycaster
* For the TI-99/4A home computer
*
* April 2020
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >1000                      ; Pattern table base 2
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
nametb equ  >2800                      ; Name table base 1
namet2 equ  >2c00                      ; Name table base 2
spratb equ  >2f00                      ; Sprite attribute table base 1
sprat2 equ  >2f80                      ; Sprite attribute table base 2
colrt2 equ  >3000                      ; Color table base 2

**
* Constants
*
map_width:
       equ  256
map_height:
       equ  32
screen_width:
       equ  32
screen_height:
       equ  24
n_directions:
       equ  128
n_rays:
       equ  screen_width
max_steps:
       equ  24
n_tile_patterns:
       equ  121
n_sprite_patterns:
       equ  0

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables

**
* PAD variables
*
rand_no:
       equ  padvar+2
dbl_buffer_flag:
       equ  rand_no+2
x:
       equ  dbl_buffer_flag+2
y:
       equ  x+2
dir:
       equ  y+2
ray_count:
       equ  dir+2
ray_idx:
       equ  ray_count+2
column_ptr:
       equ  ray_idx+2
column_ptrs:
       equ  column_ptr+2
cast_ray_loop_pad:
       equ  column_ptrs+(n_rays*2)
upload_screen_loop_pad:
       equ  cast_ray_loop_pad+40
pad_max:
       equ  upload_screen_loop_pad+28

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@dir
main_loop:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @cast_rays
       bl   @upload_screen
       bl   @user_input
       jmp  main_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,r12
       rt
*// vsync

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set name table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
*      Set sprite attribute table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>055e
       bl   @vwtr
*      Flip flag
       inv  @dbl_buffer_flag
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,column_ptrs
       mov  r0,@column_ptr
       li   r2,n_rays
       mov  r2,@ray_count
       mov  @dir,r2
       ai  r2,-n_rays/2
       andi r2,n_directions-1
       mov  r2,@ray_idx
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_idx,r2
       bl   @cast_ray
*      Calculate which column to display
       mov  r4,r4                      ; Color
       jeq  cast_rays_2
       dec  r4                         ; Color--
       a    r3,r4                      ; Add side to color
cast_rays_2:
       li   r6,24*screen_height        ; Size of a column set
       mpy  r4,r6                      ; Multiple by color to r7
*      Fish-eye correction
       mov  @ray_idx,r8
       s    @dir,r8
       andi r8,n_directions-1
       sla  r8,1
       mov  @cos_table(r8),r8
       mpy  r2,r8
       movb @r8lb,r2
       movb r9,@r2lb
*
       mov  r2,r5                      ; Distance
       srl  r5,6                       ; To FP 14.2
       sla  r5,1                       ; To word offset
       mov  @dist_column_table(r5),r5  ; Get column index
       li   r6,screen_height           ; Column size
       mpy  r6,r5                      ; Column index * column size
       a    r6,r7                      ; Add to column set base
       ai   r7,columns                 ; Add columns base
       mov  @column_ptr,r6
       mov  r7,*r6+
       mov  r6,@column_ptr
*      Next ray
       mov  @ray_idx,r2
       inc  r2
       andi r2,n_directions-1
       mov  r2,@ray_idx
       dec  @ray_count
       jne  cast_rays_1
       .endproc
*// cast_rays

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the side hit (0 = x-side, 1 = y-side)
* r4 contains the map entry/color
*
cast_ray:
       .proc
*      Set up variables
       mov  r0,r6                      ; Player x
       mov  r1,r8                      ; Player y
       andi r0,>ff00                   ; mapX
       andi r1,>ff00                   ; mapY
       andi r6,>00ff                   ; fracX
       andi r8,>00ff                   ; fracY
       sla  r2,1                       ; To word offset
       mov  @inv_cos_table(r2),r4      ; deltaDistX
       mov  @inv_sin_table(r2),r5      ; deltaDistY
*      Calculate sideDistX
       mov  @cos_table(r2),r3          ; dirX
       jlt  cast_ray_1
       jgt  cast_ray_2
       clr  r6                         ; stepX
       li   r7,>7f00                   ; sideDistX
       jmp  cast_ray_3
cast_ray_1:
       mpy  r4,r6                      ; sideDistX = fracX * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,-1                      ; stepX = -1
       jmp  cast_ray_3
cast_ray_2:
       neg  r6                         ; -fracX
       ai   r6,>0100                   ; 1 - fracX
       mpy  r4,r6                      ; sideDistX = (1 - fracX) * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,1                       ; stepX = 1
*      Calculate sideDistY
cast_ray_3:
       mov  @sin_table(r2),r3          ; dirY
       jlt  cast_ray_4
       jgt  cast_ray_5
       clr  r8                         ; stepY
       li   r9,>7f00                   ; sideDistY
       jmp  cast_ray_6
cast_ray_4:
       mpy  r5,r8                      ; sideDistY = fracY * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,-map_width              ; stepY = -1
       jmp  cast_ray_6
cast_ray_5:
       neg  r8                         ; -fracY
       ai   r8,>0100                   ; 1 - fracY
       mpy  r5,r8                      ; sideDistY = (1 - fracY) * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,map_width               ; stepY = 1
*      Map address
cast_ray_6:
       movb r0,@r12lb
       movb r1,r12
       ai   r12,map
*      Cast the ray
       li   r2,max_steps               ; Step counter
       bl   @cast_ray_loop_pad
*      Inverse map address (maybe not required)
       ai   r12,-map
       movb @r12lb,r0
       movb r12,r1
*      Calculate distance
       mov  r2,r2                      ; Steps left
       jne  cast_ray_7
       li   r2,>1700                   ; Max distance
       clr  r4
       jmp  cast_ray_10
cast_ray_7:
       mov  r3,r3                      ; xSide ?
       jne  cast_ray_8
       s    r4,r7                      ; sideDistX -= deltaDistX
       mov  r7,r2                      ; Distance
       jmp  cast_ray_9
cast_ray_8:
       s    r5,r9                      ; sideDistY -= deltaDistY
       mov  r9,r2                      ; Distance
*      Color and side
cast_ray_9:
       clr  r4                         ; Clear color
       movb r13,@r4lb                  ; Set color
cast_ray_10:
       abs  r3                         ; Side
       .endproc                        ; Return
*// cast_ray

***************************************************************
*
* Cast ray loop
*
cast_ray_loop:
       c    r7,r9                      ; sideDistX < sideDistY ?
       jgt  cast_ray_loop_1
       a    r4,r7                      ; sideDistX += deltaDistX
       a    r6,r12                     ; mapX += stepX
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_2
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_1:
       a    r5,r9                      ; sideDistY += deltaDistY
       a    r8,r12                     ; mapY += stepY
       movb *r12,r13
       jne  cast_ray_loop_3
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_2:
       clr  r3                         ; xSide = 1
       rt
cast_ray_loop_3:
       seto r3                         ; xSide = -1
       rt
cast_ray_loop_end:
       equ  $
*// cast_ray_loop

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       sla  r0,10
       ai   r0,nametb
       bl   @vwad
       clr  @self_modifying_offset
       li   r3,screen_height
       bl   @upload_screen_loop_pad
       .endproc
*// upload_screen

*********************************************************************
*
* Upload screen loop
*
upload_screen_loop:
       li   r0,column_ptrs
       li   r2,screen_width
upload_screen_loop_1:
       mov  *r0+,r1                    ; Get column pointer
upload_screen_offset:
       movb @0(r1),*r15                ; Write byte to VDP (r15 contains VDPWD)
       dec  r2
       jne  upload_screen_loop_1       ; Next column
       inc  @self_modifying_offset
       dec  r3
       jne  upload_screen_loop         ; Next row
       rt
upload_screen_loop_end:
       equ  $
self_modifying_offset:
       equ upload_screen_offset+2-upload_screen_loop+upload_screen_loop_pad
*// upload_screen_loop

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1

*      Left
user_input_1:
       tb   1
       jeq  user_input_2
       mov  @dir,r0
       dect r0
       andi r0,n_directions-1
       mov  r0,@dir
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       mov  @dir,r0
       inct r0
       andi r0,n_directions-1
       mov  r0,@dir
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       mov  @dir,r2
       sla  r2,1
       mov  @x,r0
       mov  @cos_table(r2),r3
       sra  r3,1
       s    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r3
       sra  r3,1
       s    r3,r1
       movb r1,r2
       movb r0,@r2lb
       movb @map(r2),r2
       jne  user_input_5
       mov  r0,@x
       mov  r1,@y
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       mov  @dir,r2
       sla  r2,1
       mov  @x,r0
       mov  @cos_table(r2),r3
       sra  r3,1
       a    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r3
       sra  r3,1
       a    r3,r1
       movb r1,r2
       movb r0,@r2lb
       movb @map(r2),r2
       jne  user_input_5
       mov  r0,@x
       mov  r1,@y
user_input_5:
       .endproc
*// user_input

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       bl   @graphics_mode
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Patterns
       li   r0,ptrntb
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,COL0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Sprite patterns
;       li   r0,sprptb
;       li   r1,SPR0
;       li   r2,n_sprite_patterns*32
;       bl   @vmbw
;       li   r0,spratb
;       li   r1,>d000
;       bl   @vsbw
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >0e                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       b    *r11
*// rand

*********************************************************************
*
* Program files
*
       copy "vdp.a99"

***************************************************************
*
* Data
*
start_x:
       data >1800
start_y:
       data >0500
start_dir:
       data 96

**
* This table lists, for each distance
* 1.00, 1.25, 1.50 ... 23.50, 23.75
* the index of one of the 23 pre-drawn
* columns to use.
*
dist_column_table:
       data 0, 1, 2, 3, 4, 5, 6, 7
       data 8, 9, 10, 11, 12, 13, 13, 14
       data 14, 15, 15, 16, 16, 16, 17, 17
       data 17, 17, 18, 18, 18, 18, 18, 19
       data 19, 19, 19, 19, 19, 19, 19, 20
       data 20, 20, 20, 20, 20, 20, 20, 20
       data 20, 20, 20, 21, 21, 21, 21, 21
       data 21, 21, 21, 21, 21, 21, 21, 21
       data 21, 21, 21, 21, 21, 21, 21, 21
       data 21, 22, 22, 22, 22, 22, 22, 22
       data 22, 22, 22, 22, 22, 22, 22, 22
       data 22, 22, 22, 22, 23, 23, 23, 23

**
* These are the heights of the pre-drawn colums,
* but the numbers are not used for anything here.
*
*      24.0, 19.0, 16.0, 13.5, 12.0, 10.5, 9.5, 8.5
*      8.0, 7.5, 7.0, 6.5, 6.0, 5.5, 5.0, 4.5
*      4.0, 3.5, 3.0, 2.5, 2.0, 1.5, 1.0

**
* 128 values of cos(a) as FP 8.8 for 0 <= a < 360 degrees.
*
cos_table:
       data >0100,>0100,>00ff,>00fd,>00fb,>00f8,>00f5,>00f1
       data >00ed,>00e7,>00e2,>00dc,>00d5,>00ce,>00c6,>00be
       data >00b5,>00ac,>00a2,>0098,>008e,>0084,>0079,>006d
       data >0062,>0056,>004a,>003e,>0032,>0026,>0019,>000d
       data >0000,>fff3,>ffe7,>ffda,>ffce,>ffc2,>ffb6,>ffaa
       data >ff9e,>ff93,>ff87,>ff7c,>ff72,>ff68,>ff5e,>ff54
       data >ff4b,>ff42,>ff3a,>ff32,>ff2b,>ff24,>ff1e,>ff19
       data >ff13,>ff0f,>ff0b,>ff08,>ff05,>ff03,>ff01,>ff00
       data >ff00,>ff00,>ff01,>ff03,>ff05,>ff08,>ff0b,>ff0f
       data >ff13,>ff19,>ff1e,>ff24,>ff2b,>ff32,>ff3a,>ff42
       data >ff4b,>ff54,>ff5e,>ff68,>ff72,>ff7c,>ff87,>ff93
       data >ff9e,>ffaa,>ffb6,>ffc2,>ffce,>ffda,>ffe7,>fff3
       data >0000,>000d,>0019,>0026,>0032,>003e,>004a,>0056
       data >0062,>006d,>0079,>0084,>008e,>0098,>00a2,>00ac
       data >00b5,>00be,>00c6,>00ce,>00d5,>00dc,>00e2,>00e7
       data >00ed,>00f1,>00f5,>00f8,>00fb,>00fd,>00ff,>0100

**
* 128 values of sin(a) as FP 8.8 for 0 <= a < 360 degrees.
*
sin_table:
       data >0000,>000d,>0019,>0026,>0032,>003e,>004a,>0056
       data >0062,>006d,>0079,>0084,>008e,>0098,>00a2,>00ac
       data >00b5,>00be,>00c6,>00ce,>00d5,>00dc,>00e2,>00e7
       data >00ed,>00f1,>00f5,>00f8,>00fb,>00fd,>00ff,>0100
       data >0100,>0100,>00ff,>00fd,>00fb,>00f8,>00f5,>00f1
       data >00ed,>00e7,>00e2,>00dc,>00d5,>00ce,>00c6,>00be
       data >00b5,>00ac,>00a2,>0098,>008e,>0084,>0079,>006d
       data >0062,>0056,>004a,>003e,>0032,>0026,>0019,>000d
       data >0000,>fff3,>ffe7,>ffda,>ffce,>ffc2,>ffb6,>ffaa
       data >ff9e,>ff93,>ff87,>ff7c,>ff72,>ff68,>ff5e,>ff54
       data >ff4b,>ff42,>ff3a,>ff32,>ff2b,>ff24,>ff1e,>ff19
       data >ff13,>ff0f,>ff0b,>ff08,>ff05,>ff03,>ff01,>ff00
       data >ff00,>ff00,>ff01,>ff03,>ff05,>ff08,>ff0b,>ff0f
       data >ff13,>ff19,>ff1e,>ff24,>ff2b,>ff32,>ff3a,>ff42
       data >ff4b,>ff54,>ff5e,>ff68,>ff72,>ff7c,>ff87,>ff93
       data >ff9e,>ffaa,>ffb6,>ffc2,>ffce,>ffda,>ffe7,>fff3

**
* 128 values of 1 / cos(a) as FP 8.8 for 0 <= a < 360 degrees.
*
inv_cos_table:
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100

**
* 128 values of 1 / sin(a) as FP 8.8 for 0 <= a < 360 degrees.
*
inv_sin_table:
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461

***************************************************************
*
* Data files
*
columns:
       copy "columns.a99"
       copy "chars.a99"

       aorg >2000
map:
       copy "map.a99"

       end  main
