*********************************************************************
*
* Raycaster
* For the TI-99/4A home computer
*
* April 2020
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >1000                      ; Pattern table base 2
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
nametb equ  >2800                      ; Name table base 1
namet2 equ  >2c00                      ; Name table base 2
spratb equ  >2f00                      ; Sprite attribute table base 1
sprat2 equ  >2f80                      ; Sprite attribute table base 2
colrt2 equ  >3000                      ; Color table base 2

**
* Constants
*
map_width:
       equ  256
map_height:
       equ  32
screen_width:
       equ  32
screen_height:
       equ  24
n_directions:
       equ  128
direction_mask:
       equ  2*n_directions-1
n_rays:
       equ  screen_width
max_steps:
       equ  24
n_tile_patterns:
       equ  168
n_sprite_patterns:
       equ  12

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables

**
* PAD variables
*
rand_no:
       equ  padvar+2
dbl_buffer_flag:
       equ  rand_no+2
x:                                     ; Player x FP 8.8
       equ  dbl_buffer_flag+2
y:                                     ; Player y FP 8.8
       equ  x+2
dir:                                   ; Player direction 0 - 2 * n_directions (even only)
       equ  y+2
ray_count:
       equ  dir+2
ray_dir:
       equ  ray_count+2
distance:
       equ  ray_dir+2
depth_buffer_ptr:
       equ  distance+2
column_ptr:
       equ  depth_buffer_ptr+2
column_ptrs:
       equ  column_ptr+2
cast_ray_loop_pad:
       equ  column_ptrs+(n_rays*2)
upload_screen_loop_pad:
       equ  cast_ray_loop_pad+40
pad_max:
       equ  upload_screen_loop_pad+28

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@dir
main_loop:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @cast_rays
       bl   @upload_screen
       bl   @user_input
       jmp  main_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12                ; Clear any pending interrupt
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,r12
       rt
*// vsync

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set name table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
*      Set sprite attribute table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>055e
       bl   @vwtr
*      Flip flag
       inv  @dbl_buffer_flag
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,column_ptrs
       mov  r0,@column_ptr
       li   r0,depth_buffer
       mov  r0,@depth_buffer_ptr
       li   r2,n_rays                  ; Number of rays to cast
       mov  r2,@ray_count              ; Init count-down
       mov  @dir,r2                    ; Player direction (even only)
       ai  r2,-n_rays                  ; Direction of leftmost ray
       andi r2,direction_mask          ; Wrap around
       mov  r2,@ray_dir                ; Save
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_dir,r2                ; Direction
       bl   @cast_ray                  ; Cast ray (r2=distance, r3=side, r4=color)
       mov  r2,@distance               ; Save euclidian distance
       bl   @fish_eye_correction       ; Adjust distance in r2
       mov  @depth_buffer_ptr,r5
       mov  r2,*r5+
       mov  r5,@depth_buffer_ptr
*      Calculate which column to display
       bl   @get_column_set            ; Returns column set index in r4
       sla  r4,1                       ; To word offset
       mov  @columns_set_table(r4),r4  ; Get columns set address
       mov  r2,r5                      ; Distance
       srl  r5,6                       ; To FP 14.2
       sla  r5,1                       ; To word offset
       mov  @dist_column_table(r5),r5  ; Get column index
       li   r6,screen_height           ; Column byte size
       mpy  r6,r5                      ; Column index * column size
       a    r4,r6                      ; Add to column set base
       mov  @column_ptr,r7             ; Get address of column pointer
       mov  r6,*r7+                    ; Set column pointer and increment
       mov  r7,@column_ptr             ; Save address of next column pointer
*      Next ray
       mov  @ray_dir,r2                ; Get ray direction
       inct r2                         ; Increment it
       andi r2,direction_mask          ; Wrap around
       mov  r2,@ray_dir                ; Save it
       dec  @ray_count                 ; Count down
       jne  cast_rays_1                ; Loop if more rays to cast
       .endproc
*// cast_rays

*********************************************************************
*
* Fish-eye correction
* Calculate perpendicualar distance from euclidian distance in r2
*
fish_eye_correction:
       mov  @ray_dir,r12               ; Ray direction
       s    @dir,r12                   ; Direction offset (angle)
       andi r12,direction_mask         ; Wrap around
       mov  @cos_table(r12),r12        ; Cosine of angle
       mpy  r2,r12                     ; Multiply by distance
       movb @r12lb,r2                  ; Move result back
       movb r13,@r2lb                  ; into r2
       rt
*// fish_eye_correction

*********************************************************************
*
* Calculate column set from map color
* r4: map color
* Returns columns set index in r4
*
get_column_set:
       mov  r4,r4                      ; Color
       jeq  get_column_set_6           ; Return if no wall
       ci   r4,10
       jhe  get_column_set_1
*      Single column set
       dec  r4                         ; Color--
       a    r3,r4                      ; Different color on x/y facing walls
       jmp  get_column_set_6
*      Texture
get_column_set_1:
       mov  @ray_dir,r12               ; Ray direction
       mov  r3,r3                      ; Check side
       jne  get_column_set_3           ; Jump if y side
*      Texture x side
       mov  @sin_table(r12),r12        ; dirY
       jlt  get_column_set_2
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @y,r12                     ; playerY + sin(a)
       jmp  get_column_set_5
get_column_set_2:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @y,r12                     ; playerY + sin(a)
       jmp  get_column_set_5
*      Texture y side
get_column_set_3:
       mov  @cos_table(r12),r12        ; dirX
       jlt  get_column_set_4
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @x,r12                     ; playerY + sin(a)
       jmp  get_column_set_5
get_column_set_4:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @x,r12                     ; playerY + sin(a)
get_column_set_5:
       ai   r4,-10                     ; Texture index
       sla  r4,5                       ; * 32
       andi r12,>00f0                  ; Isolate the bits we need
       srl  r12,3                      ; Shift to word offset
       a    r12,r4                     ; Add to texture index
       mov  @textures(r4),r4           ; Get column set index
get_column_set_6:
       rt
*// get_column_set

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the side hit (0 = x-side, 1 = y-side)
* r4 contains the map entry/color
*
cast_ray:
       .proc
*      Set up variables
       mov  r0,r6                      ; Player x
       mov  r1,r8                      ; Player y
       andi r0,>ff00                   ; mapX
       andi r1,>ff00                   ; mapY
       andi r6,>00ff                   ; fracX
       andi r8,>00ff                   ; fracY
       mov  @inv_cos_table(r2),r4      ; deltaDistX
       mov  @inv_sin_table(r2),r5      ; deltaDistY
*      Calculate sideDistX
       mov  @cos_table(r2),r3          ; dirX
       jlt  cast_ray_1                 ; dirX < 0 ?
       jgt  cast_ray_2                 ; dirX > 0 ?
       clr  r6                         ; stepX
       li   r7,>7f00                   ; sideDistX (max value)
       jmp  cast_ray_3
cast_ray_1:
       mpy  r4,r6                      ; sideDistX = fracX * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,-1                      ; stepX = -1
       jmp  cast_ray_3
cast_ray_2:
       neg  r6                         ; -fracX
       ai   r6,>0100                   ; 1 - fracX
       mpy  r4,r6                      ; sideDistX = (1 - fracX) * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,1                       ; stepX = 1
*      Calculate sideDistY
cast_ray_3:
       mov  @sin_table(r2),r3          ; dirY
       jlt  cast_ray_4                 ; dirY < 0 ?
       jgt  cast_ray_5                 ; dirY < 0 ?
       clr  r8                         ; stepY
       li   r9,>7f00                   ; sideDistY (max value)
       jmp  cast_ray_6
cast_ray_4:
       mpy  r5,r8                      ; sideDistY = fracY * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,-map_width              ; stepY = -1
       jmp  cast_ray_6
cast_ray_5:
       neg  r8                         ; -fracY
       ai   r8,>0100                   ; 1 - fracY
       mpy  r5,r8                      ; sideDistY = (1 - fracY) * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,map_width               ; stepY = 1
*      Map address from coordinates
cast_ray_6:
       movb r0,@r12lb
       movb r1,r12
       ai   r12,map
*      Cast the ray
       li   r2,max_steps               ; Step counter
       bl   @cast_ray_loop_pad
*      Coordinates from map address (maybe not required)
       ai   r12,-map
       movb @r12lb,r0
       movb r12,r1
*      Calculate distance
       mov  r2,r2                      ; Steps left
       jne  cast_ray_7
       li   r2,>1f00                   ; Max distance
       clr  r4                         ; Reset color
       jmp  cast_ray_10
cast_ray_7:
       mov  r3,r3                      ; xSide ?
       jne  cast_ray_8
       s    r4,r7                      ; sideDistX -= deltaDistX
       mov  r7,r2                      ; Distance
       jmp  cast_ray_9
cast_ray_8:
       s    r5,r9                      ; sideDistY -= deltaDistY
       mov  r9,r2                      ; Distance
*      Color and side
cast_ray_9:
       clr  r4                         ; Clear color
       movb r13,@r4lb                  ; Set color
cast_ray_10:
       abs  r3                         ; Side
       .endproc                        ; Return
*// cast_ray

***************************************************************
*
* Cast ray loop
*
cast_ray_loop:
       c    r7,r9                      ; sideDistX < sideDistY ?
       jgt  cast_ray_loop_1
       a    r4,r7                      ; sideDistX += deltaDistX
       a    r6,r12                     ; mapX += stepX
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_2            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_1:
       a    r5,r9                      ; sideDistY += deltaDistY
       a    r8,r12                     ; mapY += stepY
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_3            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_2:
       clr  r3                         ; xSide = 1
       rt
cast_ray_loop_3:
       seto r3                         ; xSide = -1
       rt
cast_ray_loop_end:
       equ  $
*// cast_ray_loop

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       mov  @dbl_buffer_flag,r0        ; Which buffer to update?
       andi r0,>0001
       sla  r0,10
       ai   r0,nametb
       bl   @vwad                      ; Set VDP address
       clr  @self_modifying_offset     ; Evil!
       li   r3,screen_height           ; Row counter
       bl   @upload_screen_loop_pad
       .endproc
*// upload_screen

*********************************************************************
*
* Upload screen loop
*
upload_screen_loop:
       li   r0,column_ptrs
       li   r2,screen_width
upload_screen_loop_1:
       mov  *r0+,r1                    ; Get column pointer
upload_screen_offset:
       movb @0(r1),*r15                ; Write byte to VDP (r15 contains VDPWD)
       dec  r2
       jne  upload_screen_loop_1       ; Next column
       inc  @self_modifying_offset
       dec  r3
       jne  upload_screen_loop         ; Next row
       rt
upload_screen_loop_end:
       equ  $
self_modifying_offset:
       equ upload_screen_offset+2-upload_screen_loop+upload_screen_loop_pad
*// upload_screen_loop

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
*      Left
user_input_1:
       tb   1
       jeq  user_input_2
       mov  @dir,r0
       dect r0                         ; Turn left
       dect r0                         ; Turn left
       andi r0,direction_mask
       mov  r0,@dir
       jmp  user_input_3
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       mov  @dir,r0
       inct r0                         ; Turn right
       inct r0                         ; Turn right
       andi r0,direction_mask
       mov  r0,@dir
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       mov  @dir,r2
       mov  @x,r0
       mov  @cos_table(r2),r3
       sra  r3,1
       s    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r3
       sra  r3,1
       s    r3,r1
       movb r1,r2
       movb r0,@r2lb
       movb @map(r2),r2
       jne  user_input_6
       mov  r0,@x
       mov  r1,@y
       jmp  user_input_6
user_input_4:
*      Up
       tb   4
       jeq  user_input_6
       mov  @dir,r2
       mov  @x,r0
       mov  @cos_table(r2),r3
       sra  r3,1
       a    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r3
       sra  r3,1
       a    r3,r1
       movb r1,r2
       movb r0,@r2lb
       movb @map(r2),r2
       jeq  user_input_5
       cb   @door,r2
       jeq  user_input_5
       jmp  user_input_6
user_input_5:
       mov  r0,@x
       mov  r1,@y
user_input_6:
       .endproc
*// user_input

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       bl   @graphics_mode
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Patterns
       li   r0,ptrntb
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,COL0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,spratb
       li   r1,SAL
       li   r2,50
       bl   @vmbw
       li   r0,sprat2
       li   r1,SAL2
       li   r2,50
       bl   @vmbw
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >0e                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       b    *r11
*// rand

*********************************************************************
*
* Program files
*
       copy "vdp.a99"

***************************************************************
*
* Data
*
start_x:
       data >0c00
start_y:
       data >1000
start_dir:
       data 64
space:
       byte 0
door:
       byte 10
depth_buffer:
       bss  32*2

**
* This table lists, for each distance
* 1.00, 1.25, 1.50 ... 23.50, 23.75
* the index of one of the 23 pre-drawn
* columns to use.
*
dist_column_table:
       data 0,1,2,3,4,5,6,7
       data 8,9,10,11,12,13,14,14
       data 15,16,16,17,17,18,18,19
       data 19,19,20,20,20,21,21,21
       data 21,22,22,22,22,22,23,23
       data 23,23,23,23,24,24,24,24
       data 24,24,24,24,25,25,25,25
       data 25,25,25,25,25,25,26,26
       data 26,26,26,26,26,26,26,26
       data 26,26,26,26,26,26,27,27
       data 27,27,27,27,27,27,27,27
       data 27,27,27,27,27,27,27,27
       data 27,27,27,27,27,27,28,28
       data 28,28,28,28,28,28,28,28
       data 28,28,28,28,28,28,28,28
       data 28,28,28,28,28,28,28,28
       data 28,28,28,28,28,28,28,28
       data 28,28,28,28,28,28,28,28
       data 28,28,29,29,29,29,29,29
       data 29,29,29,29,29,29,29,29
       data 29,29,29,29,29,29,29,29
       data 29,29,29,29,29,29,29,29
       data 29,29,29,29,29,29,29,29

**
* These are the heights of the pre-drawn colums,
* but the numbers are not used for anything here.
*
*      24.0,21.5,19.0,17.5,16.0,15.0,13.5,13.0
*      12.0,11.5,10.5,10.0,9.5,9.0,8.5,8.0
*      7.5,7.0,6.5,6.0,5.5,5.0,4.5,4.0
*      3.5,3.0,2.5,2.0,1.5,1.0,0.5,0.0

**
* Addresses of the different column sets,
* each with a different color or texture.
*
columns_set_table:
       data MD1,MD2,MD3,MD4,MD5,MD6,MD7,MD8
       data MD9,MD10,MD11,MD12

**
* 128 values of cos(a) as FP 8.8 for 0 <= a < 360 degrees.
*
cos_table:
       data >0100,>0100,>00ff,>00fd,>00fb,>00f8,>00f5,>00f1
       data >00ed,>00e7,>00e2,>00dc,>00d5,>00ce,>00c6,>00be
       data >00b5,>00ac,>00a2,>0098,>008e,>0084,>0079,>006d
       data >0062,>0056,>004a,>003e,>0032,>0026,>0019,>000d
       data >0000,>fff3,>ffe7,>ffda,>ffce,>ffc2,>ffb6,>ffaa
       data >ff9e,>ff93,>ff87,>ff7c,>ff72,>ff68,>ff5e,>ff54
       data >ff4b,>ff42,>ff3a,>ff32,>ff2b,>ff24,>ff1e,>ff19
       data >ff13,>ff0f,>ff0b,>ff08,>ff05,>ff03,>ff01,>ff00
       data >ff00,>ff00,>ff01,>ff03,>ff05,>ff08,>ff0b,>ff0f
       data >ff13,>ff19,>ff1e,>ff24,>ff2b,>ff32,>ff3a,>ff42
       data >ff4b,>ff54,>ff5e,>ff68,>ff72,>ff7c,>ff87,>ff93
       data >ff9e,>ffaa,>ffb6,>ffc2,>ffce,>ffda,>ffe7,>fff3
       data >0000,>000d,>0019,>0026,>0032,>003e,>004a,>0056
       data >0062,>006d,>0079,>0084,>008e,>0098,>00a2,>00ac
       data >00b5,>00be,>00c6,>00ce,>00d5,>00dc,>00e2,>00e7
       data >00ed,>00f1,>00f5,>00f8,>00fb,>00fd,>00ff,>0100

**
* 128 values of sin(a) as FP 8.8 for 0 <= a < 360 degrees.
*
sin_table:
       data >0000,>000d,>0019,>0026,>0032,>003e,>004a,>0056
       data >0062,>006d,>0079,>0084,>008e,>0098,>00a2,>00ac
       data >00b5,>00be,>00c6,>00ce,>00d5,>00dc,>00e2,>00e7
       data >00ed,>00f1,>00f5,>00f8,>00fb,>00fd,>00ff,>0100
       data >0100,>0100,>00ff,>00fd,>00fb,>00f8,>00f5,>00f1
       data >00ed,>00e7,>00e2,>00dc,>00d5,>00ce,>00c6,>00be
       data >00b5,>00ac,>00a2,>0098,>008e,>0084,>0079,>006d
       data >0062,>0056,>004a,>003e,>0032,>0026,>0019,>000d
       data >0000,>fff3,>ffe7,>ffda,>ffce,>ffc2,>ffb6,>ffaa
       data >ff9e,>ff93,>ff87,>ff7c,>ff72,>ff68,>ff5e,>ff54
       data >ff4b,>ff42,>ff3a,>ff32,>ff2b,>ff24,>ff1e,>ff19
       data >ff13,>ff0f,>ff0b,>ff08,>ff05,>ff03,>ff01,>ff00
       data >ff00,>ff00,>ff01,>ff03,>ff05,>ff08,>ff0b,>ff0f
       data >ff13,>ff19,>ff1e,>ff24,>ff2b,>ff32,>ff3a,>ff42
       data >ff4b,>ff54,>ff5e,>ff68,>ff72,>ff7c,>ff87,>ff93
       data >ff9e,>ffaa,>ffb6,>ffc2,>ffce,>ffda,>ffe7,>fff3

**
* 128 values of abs(1 / cos(a)) as FP 8.8 for 0 <= a < 360 degrees.
*
inv_cos_table:
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100

**
* 128 values of abs(1 / sin(a)) as FP 8.8 for 0 <= a < 360 degrees.
*
inv_sin_table:
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461
       data >ff00,>1461,>0a34,>06d1,>0520,>041e,>0372,>02f8
       data >029d,>0257,>021f,>01f2,>01cd,>01ae,>0194,>017d
       data >016a,>015a,>014b,>013f,>0134,>012a,>0122,>011b
       data >0115,>0110,>010c,>0108,>0105,>0103,>0101,>0100
       data >0100,>0100,>0101,>0103,>0105,>0108,>010c,>0110
       data >0115,>011b,>0122,>012a,>0134,>013f,>014b,>015a
       data >016a,>017d,>0194,>01ae,>01cd,>01f2,>021f,>0257
       data >029d,>02f8,>0372,>041e,>0520,>06d1,>0a34,>1461

***************************************************************
*
* Data files
*
columns:
       copy "columns.a99"
       copy "chars.a99"
textures:
       copy "textures.a99"

       copy "gun.a99"
       copy "soldier.a99"

       aorg >2000
map:
       copy "map.a99"

       end  main
