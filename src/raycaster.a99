*********************************************************************
*
* Textures raycaster
* For the TI-99/4A home computer
*
* April 2020 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "structs.a99"
       copy "sound-defs.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >0800                      ; Pattern table base 2
ptrnt3 equ  >1000                      ; Pattern table base 3
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
colrt2 equ  >2800                      ; Color table base 2
colrt3 equ  >3000                      ; Color table base 3
nametb equ  >3800                      ; Name table base
spratb equ  >3c00                      ; Sprite attribute table base 1
sprat2 equ  >3c80                      ; Sprite attribute table base 2
sprat3 equ  >3d00                      ; Sprite attribute table base 3
sprat4 equ  >3d80                      ; Sprite attribute table base 4
sprat5 equ  >3e00                      ; Sprite attribute table base 5
sprat6 equ  >3e80                      ; Sprite attribute table base 6
sprat7 equ  >3f00                      ; Sprite attribute table base 7
sprat8 equ  >3f80                      ; Sprite attribute table base 8

**
* Constants
*
map_width:
       equ  64
map_height:
       equ  64
map_size:
       equ  map_width*map_height
screen_width:
       equ  64
screen_height:
       equ  160
n_directions:
       equ  256
turn_speed:
       equ  64
angle_mask:
       equ  2*n_directions-1
n_rays:
       equ  screen_width
max_steps:
       equ  24
allow_missing_ray:
       equ  0
max_wall_height:
       equ  528
max_sprite_width:
       equ  32
max_sprite_height:
       equ  160
max_sprite_distance:
       equ  16
max_sprites:
       equ  16
n_hw_sprite_patterns:
       equ  27
n_fixed_hw_sprites:
       equ  12
n_compass_hw_sprites:
       equ  6
enemy_speed:
       equ  >0010
bullet_speed_z:
       equ  ->0c00
bullet_accl_z:
       equ  >0100
max_bullet_distance:
       equ  16
bullet_color:
       equ  >0f
backdrop_color:
       equ  >0e
char_0:
       equ  >30
initial_health:
       equ  63
texture_bank_select:
       equ  >6028
texture_sams_page:                     ; 16
       equ  >1000
n_texture_banks:
       equ  8
texture_width:                         ; Width in fat pixels
       equ  32
texture_height:
       equ  64
texture_size:
       equ  (texture_width/2)*texture_height
max_texture_height_2:                  ; Up to this value
       equ  192                        ; all even heights are indexed
max_texture_height_8:                  ; Up to this value
       equ  456                        ; every 8th height is indexed
first_object_texture:
       equ  24
first_monster_texture:
       equ  32
first_action_block:
       equ  32
background_bank_select:
       equ  >6040
background_address:
       equ  >6800
background_height:
       equ  192
inventory_size:
       equ  8
bottom_panel_bank_select:
       equ  >603e

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
intws  equ  wrksp+>20                  ; Interrupt work space
stack  equ  intws+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
one:
       equ  padcon
**
* PAD variables
*
padvar:
       equ  one+2                      ; Start of pad variables
interrupt_count:
       equ  padvar
rand_no:
       equ  interrupt_count+2
sal_no:
       equ  rand_no+2
score:
       equ  sal_no+2
old_score:
       equ  score+2
health:
       equ  old_score+2
old_health:
       equ  health+2
status:
       equ  old_health+2
x:                                     ; Player x FP 8.8
       equ  status+2
y:                                     ; Player y FP 8.8
       equ  x+2
dx:
       equ  y+2
dy:
       equ  dx+2
angle:                                 ; Player direction 0 - 2 * n_directions (even only)
       equ  dy+2
ray_count:
       equ  angle+2
ray_angle:
       equ  ray_count+2
distance:
       equ  ray_angle+2
column_ptr:
       equ  distance+2
full_redraw_required:
       equ  column_ptr+2
column_redraw_cleared:
       equ  full_redraw_required+2
current_background_bank_select:
       equ  column_redraw_cleared+2
pointer_x:
       equ  current_background_bank_select+2
pointer_y:
       equ  pointer_x+2
pointer_pattern:
       equ  pointer_y+2
pointer_color:
       equ  pointer_pattern+1
pointer_click:
       equ  pointer_color+1
is_target_pointer:
       equ  pointer_click+2
inventory_index:
       equ  is_target_pointer+2
selected_object:
       equ  inventory_index+2
snd_channel_1:
       equ  selected_object+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
get_speech_status:
       equ  snd_track_3+2
speech_ptr:
       equ  get_speech_status+6
speech_on:
       equ  speech_ptr+2
cast_ray_loop_pad:
       equ  speech_on+2
upload_screen_loop_pad:
       equ  cast_ray_loop_pad+30
pad_max:
       equ  upload_screen_loop_pad+22

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
restart:
       bl   @init_level
main_loop:
       clr  @interrupt_count
       bl   @set_vdp_regs
       bl   @upload_hw_sprites
       bl   @cast_if_required          ; Needs map, math
       bl   @draw_screen               ; Needs screen buffer, textures, draw code (ROM)
       bl   @draw_sprites              ; Needs screen buffer, textures, draw code (ROM)
       bl   @upload_screen             ; Needs screen buffer
       bl   @keyboard_input            ; Needs map
       bl   @pointer_actions           ; Needs map
       bl   @bullet_collisions         ; Needs map, math
       bl   @sprite_collisions         ; Needs map, math
       bl   @move_enemies              ; Needs map, math
       bl   @move_bullets              ; Needs map, math
       bl   @update_health_bar
;      bl   @display_score
       bl   @speak
       bl   @delay
       mov  @status,r0
       jeq  main_loop
       jgt  finish
       bl   @play_die
       jmp  pause
finish:
       bl   @play_finish
pause:
       li   r14,120
pause_loop:
       bl   @wait_int
       dec  r14
       jne  pause_loop
pause_loop_1:
       bl   @wait_int
       li   r0,KEY_FI
       bl   @check_key
       jeq  pause_loop_1
       jmp  restart

*********************************************************************
*
* Delay if needed
*
delay:
       .proc
delay_1:
       mov  @interrupt_count,r0
       ci   r0,3
       jhe  delay_2
       bl   @wait_int
       jmp  delay_1
delay_2:
       .endproc
*// delay

*********************************************************************
*
* Wait for interrupt
*
wait_int:
       movb @vdpsta,r12                ; Clear any pending interrupt
       clr  r12
wait_int_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  wait_int_1
       blwp @interrupt
       rt
*// wait_int

*********************************************************************
*
* Check for interrupt
*
*
check_int:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  check_int_1
       blwp @interrupt
check_int_1:
       rt
*// check_int

***************************************************************
*
* Interrupt routine
* Called with blwp @interrupt
*
interrupt:
       data intws
       data interrupt_1
interrupt_1:
       inc  @interrupt_count
       movb @vdpsta,r12
       mov  @wrksp+20,r10              ; Copy stack pointer
;       .push r15
;       li   r15,vdpwd
;       bl   @set_vdp_regs
;       bl   @upload_hw_sprites
       bl   @joystick_input
       bl   @snd_player
;       .pop r15
       rtwp
*// interrupt

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set sprite attribute table
       li   r0,>0500+(spratb/>80)
       a    @sal_no,r0
       bl   @vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Upload hardware sprites
*
upload_hw_sprites:
       .proc
       mov  @sal_no,r0                 ; Which buffer to update?
       sla  r0,7
       ai   r0,spratb
       bl   @vwad                      ; Set VDP address
*      Pointer has highest priority
       movb @pointer_y,*r15
       movb @pointer_x,*r15
       movb @pointer_pattern,*r15
       movb @pointer_color,*r15
*      Skip fixed sprites
       ai   r0,(n_fixed_hw_sprites+1)*4
       bl   @vwad
*      Bullets
       bl   @draw_bullets
*      End marker
       movb @end_marker_byte,*r15
       .endproc
end_marker_byte:
       byte >d0
*// upload_hw_sprites

*********************************************************************
*
* Cast if required
*
cast_if_required:
       .proc
       abs  @full_redraw_required
       jeq  cast_if_required_1
       bl   @cast_rays
       clr  @column_redraw_cleared
       jmp  cast_if_required_2
cast_if_required_1:
       bl   @skip_cast_rays
       seto @column_redraw_cleared
cast_if_required_2:
       bl   @check_int
       .endproc
*// cast_if_required

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,columns
       mov  r0,@column_ptr
       li   r2,n_rays                  ; Number of rays to cast
       mov  r2,@ray_count              ; Init count-down
       mov  @angle,r2                  ; Player direction (even only)
       ai  r2,-n_rays                  ; Direction of leftmost ray
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_angle,r2              ; Direction
       bl   @cast_ray                  ; Cast ray (r2=distance, r3=side, r4=color)
       mov  @column_ptr,r5
       mov  r0,@column_map_x(r5)
       mov  r1,@column_map_y(r5)
       mov  r2,@distance               ; Save euclidian distance
       bl   @fish_eye_correction       ; Adjust distance in r2
*      Calculate height and color of column
       mov  r2,r0                      ; Distance as FP 8.8
       .ifeq allow_missing_ray,1
       jne  cast_rays_2
       li   r0,max_wall_height         ; Max height
       jmp  cast_rays_3
       .endif
cast_rays_2:
       clr  r0
       li   r1,screen_height*256       ; screen height as FP 24.8
       div  r2,r0                      ; height = screen height / distance, as FP 16.0
cast_rays_3:
       andi r0,>fffe                   ; Make height even
       mov  r0,@column_height(r5)
       mov  @distance,@column_distance(r5)
       mov  @distance,@column_distance_copy(r5)
       bl   @wall_color
       ai   r5,column_size
       mov  r5,@column_ptr
*      Next ray
       mov  @ray_angle,r2              ; Get ray direction
       inct r2                         ; Increment it
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save it
       bl   @check_int
       dec  @ray_count                 ; Count down
       jne  cast_rays_1                ; Loop if more rays to cast
       .endproc
*// cast_rays

*********************************************************************
*
* Skip cast rays
*
* Restore all column values to those from the last cast,
* because these may have been changed by sprite drawing.
*
skip_cast_rays:
       li   r4,columns
       li   r5,n_rays                  ; Number of columns
skip_cast_rays_1:
       mov  @column_distance_copy(r4),@column_distance(r4)   ; Restore distance
       abs  @column_redraw_cleared
       jne  skip_cast_rays_2
       clr  @column_redraw(r4)
*      Next column
skip_cast_rays_2:
       ai   r4,column_size
       dec  r5                         ; Count down
       jne  skip_cast_rays_1           ; Loop if more columns
       rt
*// skip_cast_rays

*********************************************************************
*
* Fish-eye correction
* Calculate perpendicualar distance from euclidian distance in r2
*
fish_eye_correction:
       mov  @ray_angle,r12             ; Ray direction
       s    @angle,r12                 ; Angle offset
       andi r12,angle_mask             ; Wrap around
       mov  @cos_table(r12),r12        ; Cosine of angle (positive)
       mpy  r2,r12                     ; Multiply by distance
       movb @r12lb,r2                  ; Move result back
       movb r13,@r2lb                  ; into r2
       rt
*// fish_eye_correction

*********************************************************************
*
* Calculate wall color from map color
*
* r3: 0 = x face, 1 = y face
* r4: map color
* r5: column to update
*
* Updates column.column_texture and column.column_hit_x.
*
wall_color:
       mov  r4,r4                      ; Color
       jeq  wall_color_6               ; Return
wall_color_1:
       mov  @ray_angle,r12             ; Ray direction
       mov  r3,r3                      ; Check side
       jne  wall_color_3               ; Jump if y side
*      Texture x side
       mov  @sin_table(r12),r12        ; dirY
       jlt  wall_color_2
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @y,r12                     ; playerY + sin(a)
       jmp  wall_color_5
wall_color_2:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @y,r12                     ; playerY + sin(a)
       jmp  wall_color_5
*      Texture y side
wall_color_3:
       mov  @cos_table(r12),r12        ; dirX
       jlt  wall_color_4
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @x,r12                     ; playerY + sin(a)
       jmp  wall_color_5
wall_color_4:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @x,r12                     ; playerY + sin(a)
wall_color_5:
       andi r12,>00ff
       mov  r12,@column_hit_x(r5)
wall_color_6:
       srl  r4,1                       ; Shift out secret door bit
       mov  r4,@column_texture(r5)
       rt
*// wall_color

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the side hit (0 = x-side, 1 = y-side)
* r4 contains the map entry/color
*
cast_ray:
       .proc
*      Set up variables
       mov  r0,r6                      ; Player x
       mov  r1,r8                      ; Player y
       andi r0,>ff00                   ; mapX
       andi r1,>ff00                   ; mapY
       andi r6,>00ff                   ; fracX
       andi r8,>00ff                   ; fracY
       mov  @inv_cos_table(r2),r4      ; deltaDistX
       mov  @inv_sin_table(r2),r5      ; deltaDistY
*      Calculate sideDistX
       mov  @cos_table(r2),r3          ; dirX
       jlt  cast_ray_1                 ; dirX < 0 ?
       jgt  cast_ray_2                 ; dirX > 0 ?
       clr  r6                         ; stepX
       li   r7,>7f00                   ; sideDistX (max value)
       jmp  cast_ray_3
cast_ray_1:
       mpy  r4,r6                      ; sideDistX = fracX * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,-1                      ; stepX = -1
       jmp  cast_ray_3
cast_ray_2:
       neg  r6                         ; -fracX
       ai   r6,>0100                   ; 1 - fracX
       mpy  r4,r6                      ; sideDistX = (1 - fracX) * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,1                       ; stepX = 1
*      Calculate sideDistY
cast_ray_3:
       mov  @sin_table(r2),r3          ; dirY
       jlt  cast_ray_4                 ; dirY < 0 ?
       jgt  cast_ray_5                 ; dirY < 0 ?
       clr  r8                         ; stepY
       li   r9,>7f00                   ; sideDistY (max value)
       jmp  cast_ray_6
cast_ray_4:
       mpy  r5,r8                      ; sideDistY = fracY * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,-map_width              ; stepY = -1
       jmp  cast_ray_6
cast_ray_5:
       neg  r8                         ; -fracY
       ai   r8,>0100                   ; 1 - fracY
       mpy  r5,r8                      ; sideDistY = (1 - fracY) * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,map_width               ; stepY = 1
*      Map address from coordinates
cast_ray_6:
       bl   @get_map_address
       mov  r2,r12
*      Cast the ray
       li   r2,max_steps               ; Step counter
       bl   @cast_ray_loop_pad
*      Update visible map
       socb @byte_80,*r12
       szcb @byte_80,r13
*      Coordinates from map address
       ai   r12,-map
       mov  r12,r0
       andi r0,>3f
       mov  r12,r1
       srl  r1,6
*      Calculate distance
       .ifeq allow_missing_ray,1
       mov  r2,r2                      ; Steps left
       jne  cast_ray_7
       li   r2,max_steps*256           ; Max distance
       clr  r4                         ; Reset color
       jmp  cast_ray_10
       .endif
cast_ray_7:
       mov  r3,r3                      ; xSide ?
       jne  cast_ray_8
       s    r4,r7                      ; sideDistX -= deltaDistX
       mov  r7,r2                      ; Distance
       jmp  cast_ray_9
cast_ray_8:
       s    r5,r9                      ; sideDistY -= deltaDistY
       mov  r9,r2                      ; Distance
*      Color and side
cast_ray_9:
       clr  r4                         ; Clear color
       movb r13,@r4lb                  ; Set color
cast_ray_10:
       abs  r3                         ; Side
       .endproc                        ; Return
*// cast_ray

***************************************************************
*
* Cast ray loop
*
cast_ray_loop:
       c    r7,r9                      ; sideDistX < sideDistY ?
       jgt  cast_ray_loop_1
       a    r4,r7                      ; sideDistX += deltaDistX
       a    r6,r12                     ; mapX += stepX
       movb *r12,r13                   ; Check map
       .ifeq allow_missing_ray,1
       jne  cast_ray_loop_3            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       .else
       jeq  cast_ray_loop
       .endif
       jmp  cast_ray_loop_3
cast_ray_loop_1:
       a    r5,r9                      ; sideDistY += deltaDistY
       a    r8,r12                     ; mapY += stepY
       movb *r12,r13                   ; Check map
       .ifeq allow_missing_ray,1
       jne  cast_ray_loop_2            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       .else
       jeq  cast_ray_loop
       .endif
cast_ray_loop_2:
       seto r3                         ; xSide = -1
       rt
cast_ray_loop_3:
       clr  r3                         ; xSide = 1
       rt
cast_ray_loop_end:
       equ  $
*// cast_ray_loop

*********************************************************************
*
* Draw screen
*
draw_screen:
       .proc
       bl   @calc_background_bank
       li   r3,screen_buffer
       li   r4,columns
       clr  r5
       li   r8,background_address
draw_screen_1:
*      Check even or odd
       mov  r5,r0
       andi r0,1
       jne  draw_screen_3
*      Check if column and next can be skipped
       abs  @full_redraw_required
       jne  draw_screen_2
       abs  @column_redraw(r4)
       jne  draw_screen_2
*      No need to redraw 2 columns
       ai   r3,screen_height
       ai   r8,background_height
       ai   r4,column_size*2
       inct r5
       jmp  draw_screen_5
draw_screen_2:
*      Draw even column
       bl   @draw_even_column
       ai   r3,-screen_height
       ai   r8,-screen_height
       jmp  draw_screen_4
draw_screen_3:
*      Draw odd column
       bl   @draw_odd_column
       .ifgt background_height, screen_height
       ai   r8,background_height-screen_height
       .endif
draw_screen_4:
*      Next column
       ai   r4,column_size
       inc  r5
draw_screen_5:
       bl   @check_int
       ci   r5,n_rays
       jlt  draw_screen_1
*      Done
       .endproc
*// draw_screen

*********************************************************************
*
* Calculate ROM bank for background
*
calc_background_bank:
       mov  @angle,r0
       andi r0,>01c0
       srl  r0,5
       ai   r0,background_bank_select
       mov  @x,r1
       xor  @y,r1
       andi r1,>0100
       srl  r1,3
       a    r1,r0
       mov  r0,@current_background_bank_select
       rt
*// calc_background_bank

*********************************************************************
*
* Draw even column
*
* r3: Screen buffer
* r4: Column structure
* r5: Column number
* r8: Background address
*
draw_even_column:
       .proc
       mov  @column_height(r4),r6      ; Wall height
       ci   r6,screen_height
       jle  draw_even_column_1
       li   r6,screen_height
draw_even_column_1:
*      Sky
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       srl  r2,1                       ; Div 2
       mov  r2,r7                      ; Save height of sky
       jeq  draw_even_column_3
       bl   @draw_even_background_pixels
*      Wall
draw_even_column_3:
       mov  r6,r2                      ; Wall height
       jeq  draw_even_column_5         ; Jump if zero
       a    r2,r8                      ; Add height to background source address
       mov  @column_hit_x(r4),r0
       mov  @column_texture(r4),r1     ; Color / texture number
       bl   @prepare_texture           ; Calculate texture address
       ai   r0,even_col_vector_0
*      Cartridge bank for drawing code
       mov  *r0+,r2
       seto *r2
*      Draw routine address
       mov  *r0,r2
       bl   *r2
*      Floor
draw_even_column_5:
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       s    r7,r2                      ; Minus sky height
       jeq  draw_even_column_8
       bl   @draw_even_background_pixels
draw_even_column_8:
       .endproc
*// draw_even_column

*********************************************************************
*
* Draw a column of background pixels (even)
*
* r8: Source address
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
* We can assume that if r8 is odd then r3 is also odd.
*
draw_even_background_pixels:
       mov  @current_background_bank_select,r0
       seto *r0
       coc  @one,r3
       jne  draw_even_background_pixels_0
       movb *r8+,*r3+
       dec  r2
       jeq  draw_even_background_pixels_4
draw_even_background_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_even_background_pixels_2
draw_even_background_pixels_1:
       mov  *r8+,*r3+
       mov  *r8+,*r3+
       mov  *r8+,*r3+
       mov  *r8+,*r3+
       dec  r2
       jne  draw_even_background_pixels_1
draw_even_background_pixels_2:
       andi r0,7
       jeq  draw_even_background_pixels_4
draw_even_background_pixels_3:
       movb *r8+,*r3+
       dec  r0
       jne  draw_even_background_pixels_3
draw_even_background_pixels_4:
       rt
*// draw_even_background_pixels

*********************************************************************
*
* Draw odd column
*
* r3: Screen buffer
* r4: Column structure
* r5: Column number
* r8: Background address
*
draw_odd_column:
       .proc
       mov  @column_height(r4),r6      ; Wall height
       ci   r6,screen_height
       jle  draw_odd_column_1
       li   r6,screen_height
draw_odd_column_1:
*      Sky
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       srl  r2,1                       ; Div 2
       mov  r2,r7                      ; Save height of sky
       jeq  draw_odd_column_3
       bl   @draw_odd_background_pixels
*      Wall
draw_odd_column_3:
       mov  r6,r2                      ; Wall height
       jeq  draw_odd_column_5          ; Jump if zero
       a    r2,r8                      ; Add height to background source address
       mov  @column_hit_x(r4),r0
       mov  @column_texture(r4),r1     ; Color / texture number
       bl   @prepare_texture           ; Calculate texture address
       ai   r1,2048                    ; Add offset to odd column texture
       ai   r0,odd_col_vector_0
*      Cartridge bank for drawing code
       mov  *r0+,r2
       seto *r2
*      Draw routine address
       mov  *r0,r2
       bl   *r2
*      Floor
draw_odd_column_5:
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       s    r7,r2                      ; Minus sky height
       jeq  draw_odd_column_8
       bl   @draw_odd_background_pixels
draw_odd_column_8:
       .endproc
*// draw_odd_column

*********************************************************************
*
* Draw a column of background pixels (odd)
*
* r8: Source address
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
* We can assume that if r8 is odd then r3 is also odd.
*
draw_odd_background_pixels:
       mov  @current_background_bank_select,r0
       ai   r0,>10
       seto *r0
       coc  @one,r3
       jne  draw_odd_background_pixels_0
       socb *r8+,*r3+
       dec  r2
       jeq  draw_odd_background_pixels_4
draw_odd_background_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_odd_background_pixels_2
draw_odd_background_pixels_1:
       soc  *r8+,*r3+
       soc  *r8+,*r3+
       soc  *r8+,*r3+
       soc  *r8+,*r3+
       dec  r2
       jne  draw_odd_background_pixels_1
draw_odd_background_pixels_2:
       andi r0,7
       jeq  draw_odd_background_pixels_4
draw_odd_background_pixels_3:
       socb *r8+,*r3+
       dec  r0
       jne  draw_odd_background_pixels_3
draw_odd_background_pixels_4:
       rt
*// draw_odd_background_pixels

*********************************************************************
*
* Calculate texture routine address
*
* r1: Texture number
* r4: Column structure
*
* On return r0 contains the address of the routine to draw the column,
* and r1 contains the texture source address,

prepare_texture:
*      Select SAMS bank
       swpb r1
       ai   r1,texture_sams_page
       mov  r1,@sams_reg_2
*      Texture address
       mov  r0,r1
       srl  r1,3                       ; Column of texture
       sla  r1,6                       ; * 64
       ai   r1,textures                ; Base texture column source address
*      Column drawing vector offset
       mov  @column_height(r4),r0
       ci   r0,max_texture_height_2    ; Is every second height indexed?
       jh   prepare_texture_1
;      srl  r0,1                       ; / 2
;      sla  r0,2                       ; * 4
       sla  r0,1                       ; * 2
       jmp  prepare_texture_3
prepare_texture_1:
       ci   r0,max_texture_height_8    ; Is every 8th height indexed?
       jle   prepare_texture_2
       li   r0,max_texture_height_8    ; Above max, set to max value
prepare_texture_2:
       ai   r0,-max_texture_height_2
       srl  r0,3                       ; / 8
       sla  r0,2                       ; * 4
       ai   r0,max_texture_height_2*2
prepare_texture_3:
       rt
*// prepare_texture

*********************************************************************
*
* Draw sprites
*
draw_sprites:
       .proc
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  draw_sprites_3
draw_sprites_1:
       mov  *r4,r0                     ; Active?
       jeq  draw_sprites_2
       mov  @sprite_x(r4),r0
       s    @x,r0                      ; dx
       mov  @sprite_y(r4),r1
       s    @y,r1                      ; dy
       mov  r0,r2
       abs  r2
       mov  r1,r3
       abs  r3
       a    r2,r3                      ; Taxi distance
       ci   r3,max_sprite_distance*256
       jhe  draw_sprites_2
*      Look up angle
       bl   @atan2
       mov  r6,@sprite_angle(r4)
       srl  r6,7
       s    @angle,r6
       ci   r6,-n_rays-max_sprite_width
       jlt  draw_sprites_2
       ci   r6,n_rays+max_sprite_width-1
       jgt  draw_sprites_2
*      Look up distance
       bl   @euclidian_distance
       ci   r7,max_sprite_distance*256
       jgt  draw_sprites_2
*      Sprite is within view and distance
       bl   @draw_sprite
       bl   @check_int
draw_sprites_2:
       ai   r4,sprite_size
       dec  r5
       jne  draw_sprites_1
draw_sprites_3:
       .endproc
*// draw_sprites

*********************************************************************
*
* Draw sprite
*
* r4: sprite to draw
* r6: angle relative to player (2 units per column)
* r7: distance FP 8.8 (last 6 bits are zero)
*
draw_sprite:
       .proc
       .push r4
       .push r5
*      Width, Height
       ci   r7,>0100
       jgt  draw_sprite_1
       li   r2,max_sprite_height
       jmp  draw_sprite_2
draw_sprite_1:
       clr  r2
       li   r3,max_sprite_height*256   ; max_sprite_height as FP 24.8
       div  r7,r2                      ; Size (FP 16.0) = max_sprite_height / distance
draw_sprite_2:
       mov  r2,r3                      ; Height = size
       srl  r2,2                       ; Width = size / 4
*      Column
       li   r0,screen_width
       a    r6,r0
       s    r2,r0
       sra  r0,1
*      Row
       li   r1,screen_height           ; Screen height
       s    r3,r1                      ; Minus sprite height
       srl  r1,1                       ; Divided by 2
*      Texture
       mov  @sprite_texture(r4),r4     ; Texture number
*      Distance
       mov  r7,r5                      ; Depth/distance
*      Draw sprite
       bl   @draw_texture
       .pop r5
       .pop r4
*      Speak first time
       mov  @sprite_speech(r4),r1
       jeq  draw_sprite_11
       bl   @say_phrase
       clr  @sprite_speech(r4)
draw_sprite_11:
       .endproc
*// draw_sprite

*********************************************************************
*
* Draw texture
*
* r0: column
* r1: row
* r2: width
* r3: height
* r4: texture number
* r5: depth/distance (FP 8.8)
*
* Modifies all registers except r3, r10, r15
*
* Texture organised as:
* Pixels in left nybble (32 columns x 64 rows = 2048 bytes)
* Pixels in right nybble (32 columns x 64 rows = 2048 bytes)
*
draw_texture:
       .proc
       .push r15
       andi r3,>00fe
       li   r15,r13lb
       mov  r5,r12                     ; Save depth/distance
*      Screen buffer address (r1)
       mov  r0,r8                      ; Save screen column
       mov  r0,r13                     ; Screen column
       jgt  draw_texture_0a
       neg  r13
draw_texture_0a:
       andi r13,>003e                  ; Make even
       li   r14,screen_height/2        ; Column size in bytes
       mpy  r14,r13                    ; Even column * column size in bytes
       mov  r0,r0
       jgt  draw_texture_0b
       neg  r14
draw_texture_0b:
       a    r14,r1                     ; Add to row
       ai   r1,screen_buffer           ; Add base address
*      Texture address (r0)
       swpb r4                         ; To MSB
       ai   r4,texture_sams_page       ; Add base SAMS page
       mov  r4,@sams_reg_2             ; Page it in
       li   r0,sams_window             ; Texture base address (FP 16.0)
*      Texture X offset (r4) and increment (r5)
       clr  r4                         ; Texture X offset FP 8.8
       ci   r2,texture_width           ; Check how to calculate texture width / texture width
       jgt  draw_texture_1
       clr  r13                        ; Texture width FP 24.8
       li   r14,texture_width*256
       div  r2,r13                     ; Div by texture width FP 16.0 -> increment as FP 8.8
       jmp  draw_texture_2
draw_texture_1:
       li   r13,texture_width          ; Texture width FP 16.16
       clr  r14
       div  r2,r13                     ; Div texture width FP 16.0 -> increment as FP 0.16
       srl  r13,8                      ; Increment as FP 8.8
draw_texture_2:
       mov  r13,r5                     ; Texture X offset increment per pixel FP 8.8
*      Address of unrolled drawing code
       mov  r3,r6
       sla  r6,1
       ai   r6,sprite_index
       mov  *r6+,r7
       mov  *r6,r6
*      Column loop
draw_texture_5:
       mov  r8,r13                     ; Screen column
       jlt  draw_texture_5a             ; Skip column if out of screen
       ci   r13,screen_width-1         ; Check against right side of screen
       jgt  draw_texture_5a             ; Skip column if out of screen
       sla  r13,4                      ; * 16 (size of column structure)
       c    r12,@columns+column_distance(r13)  ; Compare texture depth to wall distance
       jlt  draw_texture_6              ; Draw if less than
*      Skip column
draw_texture_5a:
       a    r3,r1
       jmp  draw_texture_11
*      Draw column
draw_texture_6:
       mov  r12,@columns+column_distance(r13)    ; Record new distance for column
       seto @columns+column_redraw(r13) ; Mark column for drawing
       andi r0,>f000                   ; Round texture address to whole 4K
       mov  r4,r13                     ; Texture x offset
       andi r13,>1f00                  ; Isolate texture column bits
       srl  r13,2                      ; Texture column index * 64
       soc  r13,r0                     ; Add to texture address
       coc  @one,r8                    ; Test if screen column is even/odd
       jeq  draw_texture_7              ; Jump if odd
*      Even destination column
       li   r9,>f000                   ; Mask for even pixel
       andi r0,>f7ff                   ; Modify texture address for even pixels
       jmp  draw_texture_8
*      Odd destination column
draw_texture_7:
       li   r9,>0f00                   ; Mask for odd pixel
       ori  r0,>0800                   ; Modify texture address for odd pixels
*      Row loop
draw_texture_8:
       seto *r7                        ; Select ROM bank for drawing routine
       bl   *r6                        ; Call drawing routine. On return r0 += texture_height, r1 += height
draw_texture_11:
       s    r3,r1                      ; Move screen buffer address back to top of column
       coc  @one,r8                    ; Test if screen column is even/odd
       jne  draw_texture_12             ; Jump if even
       ai   r1,screen_height           ; For odd column, move screen buffer address to next column
draw_texture_12:
       a    r5,r4                      ; Increment texture x offset
       inc  r8                         ; Next column
       dec  r2                         ; Column counter (width)
       jne  draw_texture_5              ; Next column
*      Return
       .pop r15
       .endproc
*// draw_texture

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       li   r14,vdpwa
       abs  @full_redraw_required
       jeq  upload_screen_3
*      Full update
       li   r0,colrtb+>4000
       li   r5,screen_buffer
*      Full sections of 64 lines
       li   r6,(screen_height/64)
upload_screen_1:
       movb @r0lb,*r14
       movb r0,*r14
       li   r7,screen_width/2
upload_screen_2:
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r5,screen_height-64
       dec  r7
       jne  upload_screen_2
       bl   @check_int
       ai   r5,64-(screen_height*screen_width/2)
       ai   r0,>800
       dec  r6
       jne  upload_screen_1
*      Remaining lines
       .ifne screen_height%64, 0
       li   r7,screen_width/2
upload_screen_2a:
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,(screen_height%64)/8
       bl   @upload_screen_loop_pad
       ai   r5,screen_height-(screen_height%64)
       ai   r0,64
       dec  r7
       jne  upload_screen_2a
       bl   @check_int
       .endif
       clr  @full_redraw_required
       jmp  upload_screen_8
*      Column update
upload_screen_3:
       li   r0,colrtb+>4000
       li   r1,columns
       li   r2,screen_width/2
       li   r5,screen_buffer
upload_screen_4:
*      Check if the column can be skipped
       abs  @column_redraw(r1)
       jne  upload_screen_5
*      Skip column
       ai   r0,64
       ai   r5,screen_height
       jmp  upload_screen_7
*      Update column
upload_screen_5:
*      Full sections of 64 lines
       li   r6,(screen_height/64)
upload_screen_6:
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r0,>800
       dec  r6
       jne  upload_screen_6
*      Remaining lines
       .ifne screen_height%64, 0
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,(screen_height%64)/8
       bl   @upload_screen_loop_pad
       .endif
       ai   r0,64-(screen_height/64*>800)
       bl   @check_int
upload_screen_7:
       ai   r1,column_size*2
       dec  r2
       jne  upload_screen_4
upload_screen_8:
       .endproc
*// upload_screen

*********************************************************************
*
* Keyboard input
*
keyboard_input:
       .proc
*      Space - Fire
       li   r0,KEY_SP
       bl   @check_key
       jeq  keyboard_input_1
       bl   @fire_bullet
*      Q - Turn left
keyboard_input_1:
       li   r0,KEY_Q
       bl   @check_key
       jeq  keyboard_input_2
       bl   @turn_left
       jmp  keyboard_input_8
*      E - Turn right
keyboard_input_2:
       li   r0,KEY_E
       bl   @check_key
       jeq  keyboard_input_3
       bl   @turn_right
       jmp  keyboard_input_8
*      S - Move back
keyboard_input_3:
       li   r0,KEY_S
       bl   @check_key
       jeq  keyboard_input_4
       bl   @move_back
       jmp  keyboard_input_8
*      W - Move forward
keyboard_input_4:
       li   r0,KEY_W
       bl   @check_key
       jeq  keyboard_input_5
       bl   @move_forward
       jmp  keyboard_input_8
*      A - Strafe left
keyboard_input_5:
       li   r0,KEY_A
       bl   @check_key
       jeq  keyboard_input_6
       bl   @move_left
       jmp  keyboard_input_8
*      D - Strafe right
keyboard_input_6:
       li   r0,KEY_D
       bl   @check_key
       jeq  keyboard_input_7
       bl   @move_right
       jmp  keyboard_input_8
*      M - Map
keyboard_input_7:
       li   r0,KEY_M
       bl   @check_key
       jeq  keyboard_input_8
       bl   @display_map
*      Done
keyboard_input_8:
       bl   @check_int
       .endproc
dirs:
       data >0100,>0000
       data >0100,>0100
       data >0000,>0100
       data ->0100,>0100
       data ->0100,>0000
       data ->0100,->0100
       data >0000,->0100
       data >0100,->0100
*// keyboard_input

*********************************************************************
*
* Turn left
*
turn_left:
       mov  @angle,r0
       ai   r0,-turn_speed             ; Turn left
       andi r0,angle_mask
       mov  r0,@angle
       srl  r0,4
       mov  r0,r1
       ai   r0,dirs
       mov  *r0+,@dx
       mov  *r0,@dy
       srl  r1,2
       mov  r1,@sal_no
       seto @full_redraw_required
       rt
*// turn_left

*********************************************************************
*
* Turn right
*
turn_right:
       mov  @angle,r0
       ai   r0,turn_speed              ; Turn right
       andi r0,angle_mask
       mov  r0,@angle
       srl  r0,4
       mov  r0,r1
       ai   r0,dirs
       mov  *r0+,@dx
       mov  *r0,@dy
       srl  r1,2
       mov  r1,@sal_no
       seto @full_redraw_required
       rt
*// turn_right

*********************************************************************
*
* Move forward
*
move_forward:
       .proc
       mov  @x,r0
       a    @dx,r0
       mov  @y,r1
       a    @dy,r1
       bl   @get_map_value
       jeq  move_forward_2
       cb   @block_goal,r2                   ; Check for goal
       jne  move_forward_1
       inc  @status                    ; Finish
       jmp  move_forward_3
move_forward_1:
       andi r2,>0100                   ; Test secret door bit
       jeq  move_forward_3             ; If not set we cannot move
*      Move:
move_forward_2:
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_forward_3:
       .endproc
*// move_forward

*********************************************************************
*
* Move back
*
move_back:
       .proc
       mov  @x,r0
       s    @dx,r0
       mov  @y,r1
       s    @dy,r1
       bl   @get_map_value
       jne  move_back_1
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_back_1:
       .endproc
*// move_back

*********************************************************************
*
* Move left
*
move_left:
       .proc
       mov  @x,r0
       a    @dy,r0
       mov  @y,r1
       s    @dx,r1
       bl   @get_map_value
       jne  move_left_1
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_left_1:
       .endproc
*// move_left

*********************************************************************
*
* Move right
*
move_right:
       .proc
       mov  @x,r0
       s    @dy,r0
       mov  @y,r1
       a    @dx,r1
       bl   @get_map_value
       jne  move_right_1
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_right_1:
       .endproc
*// move_right

*********************************************************************
*
* Joystick input
*
joystick_input:
       .proc
       clr  r1
       clr  r2
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  joystick_input_0
       mov  @pointer_click,r0
       jne  joystick_input_1
       seto @pointer_click
       jmp  joystick_input_1
joystick_input_0:
       clr  @pointer_click
*      Left
joystick_input_1:
       tb   1
       jeq  joystick_input_2
       li   r1,->0100
       jmp  joystick_input_3
*      Right
joystick_input_2:
       tb   2
       jeq  joystick_input_3
       li   r1,>0100
*      Down
joystick_input_3:
       tb   3
       jeq  joystick_input_4
       li   r2,>0100
       jmp  joystick_input_5
*      Up
joystick_input_4:
       tb   4
       jeq  joystick_input_5
       li   r2,->0100
       jmp  joystick_input_5
joystick_input_5:
       a    r1,@pointer_x
       a    r2,@pointer_y
joystick_input_6:
       .endproc
*// joystick_input

*********************************************************************
*
* Upload screen loop
*
upload_screen_loop:
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       dec  r8
       jne  upload_screen_loop
       rt
upload_screen_loop_end:
       equ  $
*// upload_screen_loop

*********************************************************************
*
* Move enemies
*
move_enemies:
       .proc
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  move_enemies_3
move_enemies_1:
       mov  *r4,r0
       jeq  move_enemies_2
       mov  @sprite_type(r4),r0
       ci   r0,sprite_type_monster
       jl   move_enemies_2
*      x
       mov  @sprite_x(r4),r0
       mov  @x,r2
       s    r0,r2
       mov  r2,r6
*      y
       mov  @sprite_y(r4),r1
       mov  @y,r3
       s    r1,r3
       mov  r3,r7
*      Check distance
       abs  r6
       abs  r7
       a    r6,r7
       ci   r7,max_sprite_distance*256
       jhe  move_enemies_2
*      x
       mov  r2,r2
       jeq  move_enemies_5
       jlt  move_enemies_4
       ci   r2,enemy_speed
       jlt  move_enemies_5
       li   r2,enemy_speed
       jmp  move_enemies_5
move_enemies_4:
       ci   r2,-enemy_speed
       jgt  move_enemies_5
       li   r2,-enemy_speed
move_enemies_5:
*      y
       mov  r3,r3
       jeq  move_enemies_7
       jlt  move_enemies_6
       ci   r3,enemy_speed
       jlt  move_enemies_7
       li   r3,enemy_speed
       jmp  move_enemies_7
move_enemies_6:
       ci   r3,-enemy_speed
       jgt  move_enemies_7
       li   r3,-enemy_speed
move_enemies_7:
*      Check map
       mov  r2,r6
       a    r2,r0
       a    r3,r1
       bl   @get_map_value
       jeq  move_enemies_8
       s    r6,r0
       bl   @get_map_value
       jeq  move_enemies_8
       a    r6,r0
       s    r3,r1
       bl   @get_map_value
       jne  move_enemies_2
move_enemies_8:
*      Move
       mov  r0,@sprite_x(r4)
       mov  r1,@sprite_y(r4)
*      Attack
       ci   r7,>0500
       jgt  move_enemies_2
       bl   @rand
       ci   r0,>f800
       jl   move_enemies_2
       bl   @path_clear
       jne  move_enemies_2
       seto @sprite_attacking(r4)
       dec  @health
       bl   @play_shot_2
       jmp  move_enemies_3
*      Next sprite
move_enemies_2:
       ai   r4,sprite_size
       dec  r5
       jne  move_enemies_1
move_enemies_3:
       bl   @check_int
       .endproc
*// move_enemies

*********************************************************************
*
* Move bullets
*
move_bullets:
       abs  @bullet_active
       jeq  move_bullets_0
       a    @bullet_vx,@bullet_x
       a    @bullet_vy,@bullet_y
       li   r0,bullet_accl_z
       a    r0,@bullet_vz
       a    @bullet_vz,@bullet_z
       a    @bullet_speed,@bullet_distance
move_bullets_0:
       rt
*// move_bullets

*********************************************************************
*
* Draw bullets
*
draw_bullets:
       abs  @bullet_active
       jeq  draw_bullets_1
*      Check angle
       mov  @bullet_angle,r0
       s    @angle,r0                  ; Subtract player angle
       ci   r0,-n_rays
       jlt  draw_bullets_1
       ci   r0,n_rays
       jgt  draw_bullets_1
       ai   r0,>78                     ; Center
       mov  @bullet_distance,r1
       srl  r1,8
       movb @bullet_distance_pattern_table(r1),r1    ; Pattern
*      Draw sprite
       movb @bullet_z,*r15             ; y
       swpb r0
       movb r0,*r15                    ; x
       movb r1,*r15                    ; pattern
       movb @bullet_color_byte,*r15    ; color
*      Return
draw_bullets_1:
       rt
bullet_distance_pattern_table:
       byte >30,>34,>38,>3c,>40,>40,>44,>44
       byte >48,>48,>48,>4c,>4c,>4c,>4c,>4c
       byte >4c,>4c
bullet_color_byte:
       byte bullet_color
*// draw_bullets

*********************************************************************
*
* Bullet collisions
*
bullet_collisions:
       .proc
       abs  @bullet_active
       jeq  bullet_collisions_0
*      Check distance
       mov  @bullet_distance,r0
       ci   r0,max_bullet_distance*256
       jgt  bullet_collisions_1
*      Check for wall collision
       mov  @bullet_x,r0
       mov  @bullet_y,r1
       bl   @get_map_address
       movb *r2,r3
       szcb @byte_80,r3
       jeq  bullet_collisions_2
       cb   r3,@block_door
       jne  bullet_collisions_1
       bl   @open_door
       jmp  bullet_collisions_1
*      Check for sprite collison
bullet_collisions_2:
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  bullet_collisions_0
bullet_collisions_3:
       mov  *r4,r2
       jeq  bullet_collisions_4
       mov  @sprite_type(r4),r2
       ci   r2,sprite_type_monster
       jl   bullet_collisions_4
       mov  @sprite_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0080
       jgt  bullet_collisions_4
       mov  @sprite_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0080
       jgt  bullet_collisions_4
*      hit
       dec  @sprite_health(r4)
       jgt  bullet_collisions_3a
       bl   @remove_sprite
       li   r0,25
       a    r0,@score
       seto @full_redraw_required
       jmp  bullet_collisions_1
bullet_collisions_3a:
       bl   @play_shot_2
       jmp  bullet_collisions_1
bullet_collisions_4:
       ai   r4,sprite_size
       dec  r5
       jne  bullet_collisions_3
       jmp  bullet_collisions_0
*      Remove bullet
bullet_collisions_1:
       clr  @bullet_active
bullet_collisions_0:
       bl   @check_int
       .endproc
*// bullet_collisions

*********************************************************************
*
* Sprite collisions
*
sprite_collisions:
       .proc
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  sprite_collisions_3
       mov  @x,r0
       mov  @y,r1
sprite_collisions_1:
       mov  *r4,r2
       jeq  sprite_collisions_2
       mov  @sprite_type(r4),r2
       ci   r2,sprite_type_monster
       jhe  sprite_collisions_2
       mov  @sprite_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0100
       jgt  sprite_collisions_2
       mov  @sprite_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0100
       jgt  sprite_collisions_2
       bl   @remove_sprite
       li   r0,100
       a    r0,@score
       bl   @play_chest
       jmp  sprite_collisions_3
sprite_collisions_2:
       ai   r4,sprite_size
       dec  r5
       jne  sprite_collisions_1
sprite_collisions_3:
       bl   @check_int
       .endproc
*// sprite_collisions

*********************************************************************
*
* Update health bar
*
update_health_bar:
       .proc
       c    @health,@old_health
       jeq  update_health_bar_4
       mov  @health,r0
       jgt  update_health_bar_0
       dec  @status
       clr  r0
update_health_bar_0:
       mov  r0,r1                      ; Copy health
       mov  r0,r2                      ; Copy health
       srl  r0,4                       ; Which sprite 0-3 to update
       sla  r0,5                       ; Sprite pattern offset
       andi r1,>0008                   ; Isolate column bit
       sla  r1,1                       ; Column offset
       a    r1,r0                      ; Add to address
       ai   r0,sprptb+(20*32)          ; Add base address
       bl   @vwad
*      Pixels within column
       li   r1,>00aa                   ; Pattern
       andi r2,>0007                   ; Number of pixels to show
       li   r0,8
       s    r2,r0                      ; Number of pixels to clear
       srl  r1,0                       ; Shift pixels out
       sla  r1,0                       ; Shift remaining pixels back
       swpb r1                         ; Pattern to MSB
       li   r2,12                      ; Number of rows to update
update_health_bar_1:
       movb r1,*r15                    ; Change sprite pattern
       movb r1,*r15                    ; Change sprite pattern
       dect r2
       jne  update_health_bar_1
*      Full columns to clear
       mov  @old_health,r2
       srl  r2,3                       ; Old column
       mov  @health,r0
       srl  r0,3                       ; New column
       s    r0,r2                      ; Column difference
       jeq  update_health_bar_3
       jlt  update_health_bar_3
       sla  r2,4                       ; columns * 16
update_health_bar_2:
       clr  *r15
       clr  *r15
       dect r2
       jne  update_health_bar_2
update_health_bar_3:
       mov  @health,@old_health
update_health_bar_4:
       .endproc
*// update_health_bar

*********************************************************************
*
* Actions when clicking with pointer on screen
*
pointer_actions:
       .proc
       mov  @pointer_click,r0
       jeq  pointer_actions_3
       jgt  pointer_actions_3
       cb   @pointer_pattern,@pointer_pattern_target
       jne  pointer_actions_4
       seto @is_target_pointer
       jmp  pointer_actions_5
pointer_actions_4:
       clr @is_target_pointer
pointer_actions_5:
       movb @pointer_pattern_arrow,@pointer_pattern
       mov  @pointer_x,r6
       sra  r6,8
       ai   r6,5
       andi r6,>00ff
       mov  @pointer_y,r7
       sra  r7,8
       ai   r7,4
       andi r7,>00ff
       ci   r7,screen_height
       jhe  pointer_actions_1
*      Raycasting area
       mov  r6,r4
       srl  r4,2                       ; Column index
       sla  r4,4                       ; Column structure offset
       ai   r4,columns                 ; Column structure address
       mov  @column_map_x(r4),r0
       swpb r0
       mov  @column_map_y(r4),r1
       swpb r1
       bl   @get_map_address
       clr  r3
       movb *r2,r3
       szcb @byte_80,r3
       jeq  pointer_actions_2
       swpb r3
       ai   r3,-first_action_block
       jlt  pointer_actions_2
       andi r3,>00fe
       mov  @block_jumptable(r3),r3
       jeq  pointer_actions_2
       bl   *r3
       jmp  pointer_actions_2
pointer_actions_1:
       ci   r7,192
       jhe  pointer_actions_2
*      Bottom panel
       mov  r6,r0
       mov  r7,r1
       ai   r1,-screen_height
       ci   r0,104
       jl   pointer_actions_1a
       ci   r0,152
       jhe  pointer_actions_1b
       ai   r0,-104
       srl  r0,4
       andi r1,>0010
       srl  r1,2
       soc  r0,r1
       sla  r1,1
       mov  @arrows_jumptable(r1),r0
       jeq  pointer_actions_2
       bl   *r0
       jmp  pointer_actions_2
pointer_actions_1a:
       mov  r0,r1
       srl  r1,5
       jmp  pointer_actions_1c
pointer_actions_1b:
       ci   r0,160
       jl   pointer_actions_2
       mov  r0,r1
       ai   r1,-160
       srl  r1,5
       ai   r1,3
pointer_actions_1c:
       sla  r1,1
       mov  @icon_jumptable(r1),r0
       jeq  pointer_actions_2
       bl   *r0
pointer_actions_2:
       abs  @pointer_click
pointer_actions_3:
       .endproc
block_jumptable:
       data door_block_clicked
       data 0
       data button_block_clicked
       data 0
       data red_potion_block_clicked
       data green_potion_block_clicked
       data key_block_clicked
       data 0
arrows_jumptable:
       data turn_left
       data move_forward
       data turn_right
       data 0
       data move_left
       data move_back
       data move_right
       data 0
icon_jumptable:
       data 0
       data display_map
       data fire_bullet
       data inventory_clicked_left
       data inventory_clicked_middle
       data inventory_clicked_right
*// pointer_actions

*********************************************************************
*
* Inventory clicked left
*
inventory_clicked_left:
       .proc
       mov  @inventory_index,r1
       dec  r1
       andi r1,inventory_size-1
       ci   r6,176
       jhe  inventory_clicked_left_1
       mov  r1,@inventory_index
       bl   @display_inventory
       movb @pointer_pattern_arrow,@pointer_pattern
       jmp  inventory_clicked_left_2
inventory_clicked_left_1:
       bl   @inventory_clicked
inventory_clicked_left_2:
       .endproc
*// inventory_clicked_left

*********************************************************************
*
* Inventory clicked middle
*
inventory_clicked_middle:
       .proc
       mov  @inventory_index,r1
       bl   @inventory_clicked
       .endproc
*// inventory_clicked_middle

*********************************************************************
*
* Inventory clicked right
*
inventory_clicked_right:
       .proc
       mov  @inventory_index,r1
       inc  r1
       andi r1,inventory_size-1
       ci   r6,240
       jl   inventory_clicked_right_1
       mov  r1,@inventory_index
       bl   @display_inventory
       movb @pointer_pattern_arrow,@pointer_pattern
       jmp  inventory_clicked_right_2
inventory_clicked_right_1:
       bl   @inventory_clicked
inventory_clicked_right_2:
       .endproc
*// inventory_clicked_right

*********************************************************************
*
* Inventory clicked
*
* r1: inventory index clicked
*
inventory_clicked:
       .proc
       mov  r1,r0
       sla  r0,1                       ; * object_size
       ai   r0,inventory
       mov  *r0,r2                     ; Get object
       jeq  inventory_clicked_1
       mov  @object_type(r2),r3        ; Get object type
       mov  @object_type_number(r3),r4
       sla  r4,1
       mov  @inventory_jumptable(r4),r4
       jeq  inventory_clicked_1
       bl   *r4
inventory_clicked_1
       .endproc
inventory_jumptable:
       data remove_inventory
       data remove_inventory
       data key_clicked
*// inventory_clicked

*********************************************************************
*
* Key clicked
*
key_clicked:
       mov  r2,@selected_object
       movb @pointer_pattern_target,@pointer_pattern
       rt
*// key_clicked

*********************************************************************
*
* Door block clicked
*
door_block_clicked:
       .proc
       abs  @is_target_pointer
       jeq  door_block_clicked_1
       mov  @selected_object,r8
       mov  @object_type(r8),r8
       ci   r8,object_type_key
       jne  door_block_clicked_1
       bl   @find_door
       mov  r8,r8
       jeq  door_block_clicked_1
       clr  @door_key(r8)
       .push r0
       .push r1
       .push r2
       mov  @inventory_index,r1
       bl   @remove_inventory
       .pop r2
       .pop r1
       .pop r0
door_block_clicked_1:
       bl   @open_door
       .endproc
*// door_block_clicked

*********************************************************************
*
* Button block clicked
*
button_block_clicked:
       .proc
       mov  @column_hit_x(r4),r0
       srl  r0,5
       ci   r0,3
       jne  button_block_clicked_1
       bl   @get_vertical_texture_pointer_position
       mov  r1,r1
       jlt  button_block_clicked_1
       andi r1,>00e0
       ci   r1,>0060
       jne  button_block_clicked_1
*      Remove block
       movb @block_space,*r2
       seto @full_redraw_required
button_block_clicked_1:
       .endproc
*// button_block_clicked

*********************************************************************
*
* Red potion block clicked
*
red_potion_block_clicked:
       .proc
       bl   @find_object
       mov  r8,r0
       jeq  red_potion_block_clicked_1
       movb @block_recess,*r2
       seto @full_redraw_required
       bl   @add_inventory
red_potion_block_clicked_1:
       .endproc
*// red_potion_block_clicked
*********************************************************************
*
* Green potion block clicked
*
green_potion_block_clicked:
       .proc
       bl   @find_object
       mov  r8,r0
       jeq  green_potion_block_clicked_1
       movb @block_recess,*r2
       seto @full_redraw_required
       bl   @add_inventory
green_potion_block_clicked_1:
       .endproc
*// green_potion_block_clicked

*********************************************************************
*
* Key block clicked
*
key_block_clicked:
       .proc
       bl   @find_object
       mov  r8,r0
       jeq  key_block_clicked_1
       movb @block_recess,*r2
       seto @full_redraw_required
       bl   @add_inventory
key_block_clicked_1:
       .endproc
*// key_block_clicked

****************************************************
*
* Get vertical texture pointer position
*
* r4: address of column structure
* r7: screen x
* On return r1 contains the relative position as FP 8.8,
* or -1 if no hit.
*
get_vertical_texture_pointer_position:
       mov  @column_height(r4),r5      ; Column height
       ci   r5,screen_height
       jle  get_vertical_texture_pointer_position_0
       li   r5,screen_height
get_vertical_texture_pointer_position_0:
       li   r8,screen_height           ; Screen height
       s    r5,r8                      ; Column height - screen height
       srl  r8,1                       ; / 2
       mov  r7,r1                      ; Screen x
       s    r8,r1                      ; Screen x - (Column height - screen height) / 2
       jlt  get_vertical_texture_pointer_position_1 ; Offset from top of column < 0?
       c    r1,r5                      ; Offset from top of column >= column height
       jhe  get_vertical_texture_pointer_position_1
*      Relative
       mov  r1,r8                      ; Offset FP 16.16
       clr  r9
       div  r5,r8                      ; Offset / height (FP 0.16)
       mov  r8,r1
       srl  r1,8
       jmp get_vertical_texture_pointer_position_2
get_vertical_texture_pointer_position_1:
       seto r1
get_vertical_texture_pointer_position_2:
       rt
* // get_vertical_texture_pointer_position

****************************************************
*
* Display score
*
display_score:
       .proc
       mov  @score,r1
       c    r1,@old_score
       jeq  display_score_1
       li   r0,26+32
       li   r2,5
       bl   @display_decimal
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Display map
*
display_map:
       .proc
*      Set colors
       li   r0,ptrntb
       li   r1,>0000
       bl   @display_map_background
       li   r0,colrtb
       li   r1,>f100
       bl   @display_map_background
*      Display map
       li   r0,ptrntb+(8*8*8)+(2*8)    ; VDP write address
       li   r6,>00c0                   ; One fat pixel = two bits to set
       li   r7,map                     ; Source address
       li   r3,map_width/4             ; Column counter
       li   r8,>003e                   ; For testing end of screen 3rd
*      Column loop
display_map_7:
       bl   @vwad                      ; Set VDP write address
       li   r4,map_height              ; Row counter
*      Line loop
display_map_6:
       clr  r2                         ; Result byte to write to VDP
       li   r5,4                       ; Fat pixels in a byte
*      Bit loop
display_map_8:
       movb *r7+,r1                    ; Get map byte
       andi r1,>8000                   ; Has it been visited?
       jeq  display_map_5              ; Don't set map bit if zero
       soc  r6,r2                      ; Set bits
display_map_5:
       sla  r2,2                       ; Shift result left to accept next bits
       dec  r5
       jne  display_map_8              ; Next bit
       movb r2,*r15                    ; Write 4 fat pixels to VDP
       movb r2,*r15                    ; Write 4 fat pixels to VDP
*      Next line
       coc  r8,r0                      ; End of screen 3rd?
       jne  display_map_9
       ai   r0,>800-62
       bl   @vwad
       jmp  display_map_10
display_map_9:
       inct r0
display_map_10:
       ai   r7,map_width-4             ; Next row of map
       dec  r4
       jne  display_map_6
*      Next column
       ai   r0,->1000+64
       ai   r7,4-map_size
       dec  r3
       jne  display_map_7              ; Next column
*      Display player position
       mov  @sal_no,r0                 ; Which table to update?
       sla  r0,7
       ai   r0,spratb+((n_fixed_hw_sprites+1)*4)
       bl   @vwad                      ; Set VDP address
       clr  r0
       movb @y,r0
       sla  r0,1
       ab   @map_y,r0
       movb r0,*r15
       movb @x,r0
       sla  r0,1
       ab   @map_x,r0
       movb r0,*r15
       li   r0,>4805
       movb r0,*r15
       movb @r0lb,*r15
*      Wait key
       bl   @mute_sound
display_map_1:
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_1
       li   r0,KEY_FI
       bl   @check_key
       jne  display_map_1
display_map_2:
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_3
       li   r0,KEY_FI
       bl   @check_key
       jeq  display_map_2
display_map_3:
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_3
       li   r0,KEY_FI
       bl   @check_key
       jne  display_map_3
*      Restore patterns
       li   r0,colrtb
       li   r1,>1100
       bl   @display_map_background
       li   r0,ptrntb
       li   r1,>f000
       bl   @display_map_background
*      Upload screen
       seto @full_redraw_required
       bl   @upload_screen
       .endproc
map_x:
       byte 64-8
map_y:
       byte 16-9
*// display_map

*********************************************************************
*
* Display map background
*
* r0: Base address
* r1: Byte to write
*
display_map_background:
       .proc
       mov  r0,r4
*      Top
       ai   r0,(8*8*8)+(2*8)
       li   r3,16
display_map_11:
       bl   @vwad                      ; Set VDP write address
       li   r2,48
display_map_12:
       movb r1,*r15
       dec  r2
       jne  display_map_12
       ai   r0,64
       dec  r3
       jne  display_map_11
*      Middle
       mov  r4,r0
       ai   r0,>800+(8*8*8)
       li   r2,64*16
       bl   @vsmw
*      Bottom
       mov  r4,r0
       ai   r0,>1000+(8*8*8)
       li   r3,16
display_map_13:
       bl   @vwad                      ; Set VDP write address
       li   r2,16
display_map_14:
       movb r1,*r15
       dec  r2
       jne  display_map_14
       ai   r0,64
       dec  r3
       jne  display_map_13
       .endproc
*// display_map_background

*********************************************************************
*
* Fire bullet
*
fire_bullet:
       .proc
       abs  @bullet_active
       jne  fire_bullet_1
       mov  @x,@bullet_x
       mov  @y,@bullet_y
       li   r3,>9000
       mov  r3,@bullet_z               ; Screen y coordinate
       mov  @angle,r2
       mov  @cos_table(r2),@bullet_vx
       mov  @sin_table(r2),@bullet_vy
       li   r3,bullet_speed_z
       mov  r3,@bullet_vz
       mov  r2,@bullet_angle
       li   r3,>0100                   ; 1.0
       mov  r3,@bullet_speed
       clr  @bullet_distance
       seto @bullet_active
       bl   @play_shot_1
fire_bullet_1:
       .endproc
*// fire_bullet

*********************************************************************
*
* Open door
*
* r0: x FP 8.8
* r1: y FP 8.8
* r2: Map address
*
open_door:
       .proc
       bl   @find_door
       mov  r8,r8
       jeq  open_door_2
       mov  @door_key(r8),r4
       jne  open_door_2
       movb @block_space,*r2
       seto @full_redraw_required
       mov  @door_sprite_inits(r8),r4
       mov  *r4,r5                     ; Already created?
       jne  open_door_2
       seto *r4+                       ; Mark as created
       mov  *r4+,r5                    ; Number of sprites to create
       jeq  open_door_2
open_door_1:
       bl   @create_sprite
       ai   r4,sprite_init_size
       dec  r5
       jne  open_door_1
open_door_2:
       .endproc
*// open_door

*********************************************************************
*
* Find door
*
* r0: x FP 8.8
* r1: y FP 8.8
*
find_door:
       li   r8,doors
       mov  @n_doors,r9
       jeq  find_door_3
find_door_1:
       cb   r0,@door_x(r8)
       jne  find_door_2
       cb   r1,@door_y(r8)
       jeq  find_door_4
find_door_2:
       ai   r8,door_size
       dec  r9
       jne  find_door_1
find_door_3:
       clr  r8
find_door_4:
       rt
*// find_door

*********************************************************************
*
* Find object
*
* r0: x FP 8.8
* r1: y FP 8.8
*
find_object:
       li   r8,objects
       mov  @n_objects,r9
find_object_1:
       cb   r0,@object_map_x(r8)
       jne  find_object_2
       cb   r1,@object_map_y(r8)
       jeq  find_object_4
find_object_2:
       ai   r8,object_size
       dec  r9
       jne  find_object_1
find_object_3:
       clr  r8
find_object_4:
       rt
*// find_object

*********************************************************************
*
* Path clear
* Is path from sprite to player clear?
*
* r4: Sprite pointer
*
* On return eq is set if path is clear.
*
path_clear:
       .proc
       mov  @sprite_x(r4),r0
       mov  @sprite_y(r4),r1
       mov  @sprite_angle(r4),r6
       ai   r6,>8000
       srl  r6,8
       sla  r6,1
       mov  @cos_table(r6),r7
       mov  @sin_table(r6),r8
       li   r6,max_steps
path_clear_1:
       bl   @get_map_value
       jne  path_clear_3
       cb   r0,@x
       jne  path_clear_2
       cb   r1,@y
       jne  path_clear_2
       .pop r11
       c    r1,r1
       rt
path_clear_2:
       a    r7,r0
       a    r8,r1
       dec  r6
       jne  path_clear_1
path_clear_3:
       .endproc
*// path_clear

*********************************************************************
*
* Get map value
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the map byte. r0 and r1 are preserved.
*
get_map_value:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       movb @map(r2),r2
       szcb @byte_80,r2
       rt
*// get_map_value

*********************************************************************
*
* Get map address
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the address. r0 and r1 are preserved.
*
get_map_address:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       ai   r2,map
       rt
*// get_map_address

*********************************************************************
*
* Reset sprites
*
reset_sprites:
       li   r5,sprites
       li   r6,max_sprites
reset_sprites_1:
       clr  *r5
       ai   r5,sprite_size
       dec  r6
       jne  reset_sprites_1
       rt
*// reset_sprites

*********************************************************************
*
* Create sprite
*
* r4: Sprite init data
*
* On return r6 contains the address of the sprite, or 0 if it failed
* Uses: r2,r3,r6,r7
*
create_sprite:
       li   r6,sprites
       clr  r7
create_sprite_1:
       mov  *r6,r3                     ; Sprite active?
       jne  create_sprite_2
       inc  *r6                        ; set active
       mov  @sprite_init_type(r4),r2
       mov  r2,@sprite_type(r6)
       movb @sprite_init_x(r4),@sprite_x(r6)
       movb @byte_80,@sprite_x+1(r6)
       movb @sprite_init_y(r4),@sprite_y(r6)
       movb @byte_80,@sprite_y+1(r6)
       mov  @sprite_type_texture(r2),@sprite_texture(r6)
       mov  @sprite_type_speech(r2),@sprite_speech(r6)
       mov  @sprite_type_health(r2),@sprite_health(r6)
       clr  @sprite_attacking(r6)
*      Next sprite
       c    r7,@n_sprites
       jlt  create_sprite_3
       inc  @n_sprites
       jmp  create_sprite_3
create_sprite_2:
       ai   r6,sprite_size
       inc  r7
       ci   r7,max_sprites
       jlt  create_sprite_1
       clr  r6
create_sprite_3:
       rt
*// create_sprite

*********************************************************************
*
* Remove sprite
*
* r4: Address of sprite
*
remove_sprite:
       .proc
       mov  r4,r0
       ai   r0,sprite_size
       mov  r4,r1
       li   r2,sprites+(sprite_size*max_sprites)
       s    r4,r2
       bl   @copy
       li   r0,sprites+(sprite_size*(max_sprites-1))
       clr  *r0
       dec  @n_sprites
       .endproc
*// remove_sprite

*********************************************************************
*
* Add object to inventory
*
* r0: Address of object to add
*
add_inventory:
       .proc
       mov  @inventory_index,r1
       li   r2,inventory_size
add_inventory_0:
       mov  r1,r3
       sla  r3,1                       ; * object_size
       mov  @inventory(r3),r4          ; Get object
       jne  add_inventory_1
       mov  r0,@inventory(r3)          ; Store object
       mov  r1,@inventory_index
       bl   @display_inventory
       jmp  add_inventory_3
add_inventory_1:
       inc  r1
       andi r1,inventory_size-1
       dec  r2
       jne  add_inventory_0
add_inventory_3:
       .endproc
*// add_inventory

*********************************************************************
*
* Remove object from inventory
*
* r1: Inventory index to remove
*
remove_inventory:
       .proc
       sla  r1,1                       ; * object_size
       ai   r1,inventory
       mov  *r1,r0                     ; Get object
       clr  *r1
       bl   @display_inventory
       .endproc
*// remove_inventory

*********************************************************************
*
* Display inventory
*
display_inventory:
       .proc
       mov  @inventory_index,r7
       dec  r7
       andi r7,inventory_size-1
       li   r8,20
       li   r9,3
display_inventory_1:
       mov  r8,r0
       mov  r7,r12
       sla  r12,1                       ; * object_size
       mov  @inventory(r12),r1
       jeq  display_inventory_2
       mov  @object_type(r1),r1
       mov  @object_type_panel_graphics(r1),r1
       jmp  display_inventory_3
display_inventory_2:
       li   r1,empty_patterns
display_inventory_3:
       li   r2,4
       bl   @display_panel_graphics
       inc  r7
       andi r7,inventory_size-1
       ai   r8,4
       dec  r9
       jne  display_inventory_1
       .endproc
*// display_inventory

*********************************************************************
*
* Initialize level
*
init_level:
       .proc
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@angle
       mov  @start_dx,@dx
       mov  @start_dy,@dy
       li   r0,initial_health
       mov  r0,@health
       mov  r0,@old_health
       clr  @score
       seto @old_score
       clr  @status
       seto @full_redraw_required
       li   r0,>7800
       mov  r0,@pointer_x
       li   r0,>6000
       mov  r0,@pointer_y
       li   r0,>2c0f
       mov  r0,@pointer_pattern
*      Init columns
       li   r1,columns
       li   r2,n_rays
init_level_0:
       seto @column_redraw(r1)
       ai   r1,column_size
       dec  r2
       jne  init_level_0
*      Init doors
       li   r4,doors
       mov  @n_doors,r5
       jeq  init_level_1a
init_level_1:
       clr  r0
       movb @door_x(r4),r0
       clr  r1
       movb @door_y(r4),r1
       bl   @get_map_address
       movb @block_door,*r2
       mov  @door_sprite_inits(r4),r6
       clr  *r6                        ; Mark as not completed
       ai   r4,door_size
       dec  r5
       jne  init_level_1
init_level_1a:
*      Init sprites
       bl   @reset_sprites
       li   r4,sprite_init_data
       mov  *r4+,r5
       jeq  init_level_2a
init_level_2:
       bl   @create_sprite
       ai   r4,sprite_init_size
       dec  r5
       jne  init_level_2
init_level_2a:
*      Init inventory
       li   r4,inventory
       li   r5,inventory_size
init_level_3:
       clr  *r4+
       dec  r5
       jne  init_level_3
       clr  @inventory_index
       li   r0,objects
       bl   @add_inventory
       bl   @display_inventory
*      Speak
       li   r1,start_of_level
       bl   @say_phrase
*      Sprite patterns
       li   r0,sprptb+(20*32)
       li   r1,SPR20
       li   r2,4*32
       bl   @vmbw
       .endproc
*// init_level

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r0,1
       mov  r0,@one
*      Display message
       li   r0,11*32+9
       li   r1,txt_please_wait
       li   r2,14
       bl   @vmbw
*      Init SAMS
       bl   @init_sams
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Copy textures to SAMS
       li   r0,texture_bank_select
       li   r1,texture_sams_page
       li   r12,n_texture_banks
one_time_init_0:
       bl   @copy_textures_to_sams
       dec  r12
       jne  one_time_init_0
*      Init speech
       bl   @init_speech
*      Graphics smode
       bl   @graphics_mode
*      Patterns
       li   r0,ptrntb
       li   r1,>f000
       li   r2,>1800
       bl   @vsmw
*      Colors
       li   r0,colrtb
       clr  r1
       li   r2,>1800
       bl   @vsmw
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r3,24
one_time_init_4:
       li   r2,32
one_time_init_5:
       movb r1,*r15
       ai   r1,>0800
       dec  r2
       jne  one_time_init_5
       ai   r1,>0100
       andi r1,>0700
       dec  r3
       jne  one_time_init_4
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,n_hw_sprite_patterns*32
       bl   @vmbw
*      Sprite attribute tables
       li   r0,spratb+4
       li   r3,8
       li   r4,sal_compass
one_time_init_1:
       bl   @vwad
       li   r2,(n_fixed_hw_sprites-n_compass_hw_sprites)*4
       li   r1,sal_fixed
one_time_init_2:
       movb *r1+,*r15
       dec  r2
       jne  one_time_init_2
       li   r2,n_compass_hw_sprites*4
one_time_init_3:
       movb *r4+,*r15
       dec  r2
       jne  one_time_init_3
       ai   r0,>80
       dec  r3
       jne  one_time_init_1
*      Bottom panel
       bl   @display_panel
       .endproc
txt_please_wait:
       text "PLEASE WAIT..."
*// one_time_init

*********************************************************************
*
* Display bottom panel
*
display_panel:
       .proc
       clr  r7
       li   r8,8
display_panel_1:
       mov  r7,r0
       li   r1,empty_patterns
       li   r2,4
       bl   @display_panel_graphics
       ai   r7,4
       dec  r8
       jne  display_panel_1
       li   r0,0
       li   r1,score_patterns
       li   r2,4
       bl   @display_panel_graphics
       li   r0,4
       li   r1,map_patterns
       li   r2,4
       bl   @display_panel_graphics
       li   r0,8
       li   r1,attack_patterns
       li   r2,4
       bl   @display_panel_graphics
       li   r0,12
       li   r1,arrows_patterns
       li   r2,8
       bl   @display_panel_graphics
       .endproc
*// display_panel

*********************************************************************
*
* Display panel graphics
*
* r0: Column (0-31)
* r1: Address of graphics data (patterns followed by colors)
* r2: Width in columns
*
* Modifies r0-r6
*
display_panel_graphics:
       .proc
       seto @bottom_panel_bank_select
       sla  r0,6                       ; * 64
       ai   r0,ptrntb+>1020
       mov  r0,r4
       mov  r2,r5
       li   r6,2
display_panel_graphics_1:
       bl   @vwad
       li   r3,32
display_panel_graphics_2:
       movb *r1+,*r15
       dec  r3
       jne  display_panel_graphics_2
       ai   r0,64
       dec  r2
       jne  display_panel_graphics_1
       mov  r4,r0
       ai   r0,>2000
       mov  r5,r2
       dec  r6
       jne  display_panel_graphics_1
       .endproc
*// display_panel_graphics

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; 3 color tables
       byte ptrntb/>800+>03            ; 3 pattern tables
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte backdrop_color             ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       ai   r0,nametb
       mov  r0,r4
       bl   @vwad
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       ai   r0,char_0
       swpb r0
       movb r0,*r15
       dec  r2
       jne  display_decimal_1
       ai   r1,char_0
       swpb r1
       movb r1,*r15
       .endproc
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// display_decimal

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source (even)
* r1: destination (even)
* r2: number of bytes (even)
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Arcus tangent 2 function
*
* Calculates the angle of the vector with coordinates (x,y) = (r0,r1)
* Uses r2-r3
* Result in r6 as FP 8.8
*
atan2:
       clr  r3                         ; For division
       mov  r1,r1                      ; if (y >= 0) {
       jlt  atan2_4
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_2
*      Q1
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_1
       jlt  !
       li   r6,>2000
       rt
!      mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2                      ; Result in r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       rt                              ;             result = 0x00 + a;
atan2_1:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x40 - a;
       ai   r6,>4000
       rt                              ;         }
atan2_2:                               ;     } else {
*      Q2
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_3
       jlt  !
       li   r6,>6000
       rt
!      mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x80 - a;
       ai   r6,>8000
       rt
atan2_3:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>4000                   ;                 result = 0x40 + a;
       rt                              ;         }
                                       ;     }
atan2_4:                               ; } else {
       neg  r1                         ;     y = -y;
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_6
*      Q4
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_5
       jlt  !
       li   r6,>e000
       rt
!       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x100 - a;
       rt
atan2_5:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>c000                   ;                 result = 0xc0 + a;
       rt                              ;         }
atan2_6:                               ;     } else {
*      Q3
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_7
       jlt  !
       li   r6,>a000
       rt
!
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>8000                   ;                 result = 0x80 + a;
       rt
atan2_7:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0xc0 - a;
       ai   r6,>c000
       rt                              ;         }
                                       ;     }
                                       ; }
*// atan2

*********************************************************************
*
* Euclidian distance
*
* Calculates the length of the vector with coordinates
* (x,y) = (r0,r1) in FP 8.8 format.
* Result in r7 as FP 8.8
*
euclidian_distance:
       abs  r0
       abs  r1
       ci   r0,>00ff
       jgt  euclidian_distance_1
       ci   r1,>00ff
       jgt  euclidian_distance_1
       srl  r0,4                       ; To FP 12.4
       srl  r1,4                       ; To FP 12.4
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,6                       ; To FP 8.8
       rt
euclidian_distance_1:
       ci   r0,>03ff
       jgt  euclidian_distance_2
       ci   r1,>03ff
       jgt  euclidian_distance_2
       srl  r0,6                       ; To FP 14.2
       srl  r1,6                       ; To FP 14.2
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,4                       ; To FP 8.8
       rt
euclidian_distance_2:
       srl  r0,8                       ; To FP 16.0
       srl  r1,8                       ; To FP 16.0
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,2                       ; To FP 8.8
       rt
*// euclidian_distance

*********************************************************************
*
* Program files
*
       copy "vdp.a99"
       copy "sams.a99"
       copy "speech.a99"
       copy "sound-fx-routines.a99"
;      copy "music-player.a99"
       copy "sound-player.a99"

***************************************************************
*
* Data
*
start_x:
       data >0180
start_y:
       data >0280
start_dir:
       data 0
start_dx:
       data >0100
start_dy:
       data >0000
bullet_active:
       data 0
bullet_x:
       data 0
bullet_y:
       data 0
bullet_z:
       data 0
bullet_vx:
       data 0
bullet_vy:
       data 0
bullet_vz:
       data 0
bullet_angle:
       data 0
bullet_speed:
       data 0
bullet_distance:
       data 0

**
* Constants
*
byte_00:
       byte >00
byte_01:
       byte >01
byte_80:
       byte >80
block_space:
       byte 0
block_door:
       byte 32
block_goal:
       byte 34
block_button:
       byte 36
block_recess:
       byte 38
block_red_potion:
       byte 40
block_green_potion:
       byte 42
block_key:
       byte 44
block_unused:
       byte 46
pointer_pattern_arrow:
       byte >2c
pointer_pattern_target:
       byte >68

**
* Column list
*
columns:
       bss  n_rays*column_size

**
* Sprite list
*
n_sprites:
       data 0
sprites:
       bss  max_sprites*sprite_size

**
* Sprite init data
*
sprite_init_data:
       data 2
       data sprite_type_barrel
       byte >11                      ; x
       byte >02                      ; y
       data sprite_type_eye
       byte >02                      ; x
       byte >06                      ; y

**
* Object types
*
object_type_red_position:
       data 0
       data potion_red_patterns
object_type_green_position:
       data 1
       data potion_green_patterns
object_type_key:
       data 2
       data key_patterns

**
* Objects
*
objects:
       data object_type_red_position
       byte 0
       byte 0
       data object_type_key
       byte 9
       byte 3
       data object_type_key
       byte 8
       byte 1
       data object_type_red_position
       byte 14
       byte 3
       data object_type_red_position
       byte 1
       byte 12
       data object_type_green_position
       byte 14
       byte 1
n_objects:
       data (n_objects - objects) / object_size

**
* Inventory
*
inventory:
       bss  object_size*inventory_size

***************************************************************
*
* Data files
*

       copy "math_tables.a99"          ; 2K
       copy "sound-fx.a99"
       copy "sprite-types.a99"
doors:
       copy "doors.a99"
col_index:
       copy "../TexGen/col-index.a99"
sprite_index:
       copy "../TexGen/sprite-index.a99"

***************************************************************
*
*      Screen buffer (6K for full screen)
*
*      Organised as n columns of m bytes
*      First m bytes for column 0, next m bytes for column 1 etc.
*      Each column contains 2 fat (4x1, 16 color) pixels horizontally
*      and m pixels vertically.

screen_buffer:
       bss  screen_height*screen_width/2
upper_ram_max:
       equ  $

**
*      One time init data
*      Loaded on top of screen buffer
*
       aorg screen_buffer
       copy "hw-sprite-init.a99"
       copy "hw-sprite-patterns.a99"

***************************************************************
*
* Lower RAM
*
***************************************************************

       aorg >2000

textures:
       bss  >1000
map:
       equ  >3000
       copy "map.a99"

lower_ram_max:
       equ  $

***************************************************************
*
* Cartridge
* Included to calculate label values only.
*
***************************************************************

       aorg >6000
       copy "../panel/bottom-panel.a99"

***************************************************************
*
* End
       end  main
*
***************************************************************


