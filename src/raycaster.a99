*********************************************************************
*
* Raycaster
* For the TI-99/4A home computer
*
* April 2020
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >1000                      ; Pattern table base 2
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
nametb equ  >2800                      ; Name table base 1
namet2 equ  >2c00                      ; Name table base 2
spratb equ  >2f00                      ; Sprite attribute table base 1
sprat2 equ  >2f80                      ; Sprite attribute table base 2
colrt2 equ  >3000                      ; Color table base 2

**
* Constants
*
map_width:
       equ  256
map_height:
       equ  32
screen_width:
       equ  32
screen_height:
       equ  24
n_directions:
       equ  128
n_rays:
       equ  screen_width
max_steps:
       equ  24
n_tile_patterns:
       equ  121
n_sprite_patterns:
       equ  0

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables

**
* PAD variables
*
rand_no:
       equ  padvar+2
dbl_buffer_flag:
       equ  rand_no+2
x:
       equ  dbl_buffer_flag+2
y:
       equ  x+2
dir:
       equ  y+2
ray_count:
       equ  dir+2
ray_idx:
       equ  ray_count+2
column_ptr:
       equ  ray_idx+2
column_ptrs:
       equ  column_ptr+2
cast_ray_pad:
       equ  column_ptrs+(n_rays*2)
upload_screen_loop_pad:
       equ  cast_ray_pad+50
pad_max:
       equ  upload_screen_loop_pad+24

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@dir
main_loop:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @cast_rays
       bl   @upload_screen
       bl   @user_input
       jmp  main_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,r12
       rt
*// vsync

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set name table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
*      Set sprite attribute table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>055e
       bl   @vwtr
*      Flip flag
       inv  @dbl_buffer_flag
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,column_ptrs
       mov  r0,@column_ptr
       li   r2,n_rays
       mov  r2,@ray_count
       mov  @dir,r2
       ai  r2,-n_rays/2
       andi r2,n_directions-1
       mov  r2,@ray_idx
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_idx,r2
       bl   @cast_ray_pad
*      Calculate which column to display
       li   r4,19*screen_height        ; Size of a column set
       mpy  r3,r4                      ; Multiple by color
       mov  r2,r4                      ; Distance
       sla  r4,1
       a    @dist_column_lookup(r4),r5
       ai   r5,columns
       mov  @column_ptr,r6
       mov  r5,*r6+
       mov  r6,@column_ptr
*      Next ray
       mov  @ray_idx,r2
       inc  r2
       andi r2,n_directions-1
       mov  r2,@ray_idx
       dec  @ray_count
       jne  cast_rays_1
       .endproc
*// cast_rays

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the map entry/color
*
cast_ray:
       sla  r2,1
       mov  @unit_vectors_x(r2),r3     ; xdir
       mov  @unit_vectors_y(r2),r4     ; ydir
       li   r8,max_steps               ; Step counter
       li   r5,r6lb                    ; Cache r6lb
cast_ray_1:
       a    r3,r0                      ; x += xdir
       a    r4,r1                      ; y += ydir
       movb r1,r6                      ; y -> r6 msb
       movb r0,*r5                     ; x -> r6 lsb
       movb @map(r6),r7                ; Get map entry
       jne  cast_ray_2                 ; Not zero is a hit
       dec  r8                         ; Distance count down
       jne  cast_ray_1                 ; Loop until we give up
cast_ray_2:
       li   r2,max_steps               ; Calculate distance
       s    r8,r2                      ; max_steps - steps_left
       clr  r3
       movb r7,@r3lb                   ; map entry/color
       rt                              ; Return
cast_ray_end:
       equ  $
*// cast_ray

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       sla  r0,10
       ai   r0,nametb
       bl   @vwad
       li   r3,screen_height
       bl   @upload_screen_loop_pad
       .endproc
*// upload_screen

*********************************************************************
*
* Upload screen loop
*
upload_screen_loop:
       li   r1,column_ptrs
       li   r2,screen_width
upload_screen_loop_1:
       mov  *r1,r0                     ; Get column pointer
       movb *r0+,*r15                  ; Write byte to VDP (r15 contains VDPWD)
       mov  r0,*r1+                    ; Write pointer back
       dec  r2
       jne  upload_screen_loop_1       ; Next column
       dec  r3
       jne  upload_screen_loop         ; Next row
       rt
upload_screen_loop_end:
       equ  $
*// upload_screen_loop

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1

*      Left
user_input_1:
       tb   1
       jeq  user_input_2
       mov  @dir,r0
       dect r0
       andi r0,n_directions-1
       mov  r0,@dir
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       mov  @dir,r0
       inct r0
       andi r0,n_directions-1
       mov  r0,@dir
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       mov  @dir,r2
       sla  r2,1
       mov  @x,r0
       s    @unit_vectors_x(r2),r0
       mov  @y,r1
       s    @unit_vectors_y(r2),r1
       movb r1,r2
       movb r0,@r2lb
       movb @map(r2),r2
       jne  user_input_5
       mov  r0,@x
       mov  r1,@y
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       mov  @dir,r2
       sla  r2,1
       mov  @x,r0
       a    @unit_vectors_x(r2),r0
       mov  @y,r1
       a    @unit_vectors_y(r2),r1
       movb r1,r2
       movb r0,@r2lb
       movb @map(r2),r2
       jne  user_input_5
       mov  r0,@x
       mov  r1,@y
user_input_5:
       .endproc
*// user_input

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       bl   @graphics_mode
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray
       li   r1,cast_ray_pad
       li   r2,cast_ray_end-cast_ray
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Patterns
       li   r0,ptrntb
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,COL0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Sprite patterns
;       li   r0,sprptb
;       li   r1,SPR0
;       li   r2,n_sprite_patterns*32
;       bl   @vmbw
;       li   r0,spratb
;       li   r1,>d000
;       bl   @vsbw
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >0e                        ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       b    *r11
*// rand

*********************************************************************
*
* Program files
*
       copy "vdp.a99"

***************************************************************
*
* Data
*
start_x:
       data >1d00
start_y:
       data >1900
start_dir:
       data 96

dist_column_lookup:
       data 0*screen_height
       data 1*screen_height
       data 2*screen_height
       data 3*screen_height
       data 4*screen_height
       data 5*screen_height
       data 6*screen_height
       data 7*screen_height
       data 8*screen_height
       data 9*screen_height
       data 10*screen_height
       data 11*screen_height
       data 12*screen_height
       data 12*screen_height
       data 13*screen_height
       data 13*screen_height
       data 14*screen_height
       data 14*screen_height
       data 15*screen_height
       data 15*screen_height
       data 16*screen_height
       data 16*screen_height
       data 17*screen_height
       data 17*screen_height
       data 18*screen_height

unit_vectors_x:
       data >0100,>0100,>00ff,>00fd,>00fb,>00f8,>00f5,>00f1
       data >00ed,>00e7,>00e2,>00dc,>00d5,>00ce,>00c6,>00be
       data >00b5,>00ac,>00a2,>0098,>008e,>0084,>0079,>006d
       data >0062,>0056,>004a,>003e,>0032,>0026,>0019,>000d
       data >0000,>fff3,>ffe7,>ffda,>ffce,>ffc2,>ffb6,>ffaa
       data >ff9e,>ff93,>ff87,>ff7c,>ff72,>ff68,>ff5e,>ff54
       data >ff4b,>ff42,>ff3a,>ff32,>ff2b,>ff24,>ff1e,>ff19
       data >ff13,>ff0f,>ff0b,>ff08,>ff05,>ff03,>ff01,>ff00
       data >ff00,>ff00,>ff01,>ff03,>ff05,>ff08,>ff0b,>ff0f
       data >ff13,>ff19,>ff1e,>ff24,>ff2b,>ff32,>ff3a,>ff42
       data >ff4b,>ff54,>ff5e,>ff68,>ff72,>ff7c,>ff87,>ff93
       data >ff9e,>ffaa,>ffb6,>ffc2,>ffce,>ffda,>ffe7,>fff3
       data >0000,>000d,>0019,>0026,>0032,>003e,>004a,>0056
       data >0062,>006d,>0079,>0084,>008e,>0098,>00a2,>00ac
       data >00b5,>00be,>00c6,>00ce,>00d5,>00dc,>00e2,>00e7
       data >00ed,>00f1,>00f5,>00f8,>00fb,>00fd,>00ff,>0100

unit_vectors_y:
       data >0000,>000d,>0019,>0026,>0032,>003e,>004a,>0056
       data >0062,>006d,>0079,>0084,>008e,>0098,>00a2,>00ac
       data >00b5,>00be,>00c6,>00ce,>00d5,>00dc,>00e2,>00e7
       data >00ed,>00f1,>00f5,>00f8,>00fb,>00fd,>00ff,>0100
       data >0100,>0100,>00ff,>00fd,>00fb,>00f8,>00f5,>00f1
       data >00ed,>00e7,>00e2,>00dc,>00d5,>00ce,>00c6,>00be
       data >00b5,>00ac,>00a2,>0098,>008e,>0084,>0079,>006d
       data >0062,>0056,>004a,>003e,>0032,>0026,>0019,>000d
       data >0000,>fff3,>ffe7,>ffda,>ffce,>ffc2,>ffb6,>ffaa
       data >ff9e,>ff93,>ff87,>ff7c,>ff72,>ff68,>ff5e,>ff54
       data >ff4b,>ff42,>ff3a,>ff32,>ff2b,>ff24,>ff1e,>ff19
       data >ff13,>ff0f,>ff0b,>ff08,>ff05,>ff03,>ff01,>ff00
       data >ff00,>ff00,>ff01,>ff03,>ff05,>ff08,>ff0b,>ff0f
       data >ff13,>ff19,>ff1e,>ff24,>ff2b,>ff32,>ff3a,>ff42
       data >ff4b,>ff54,>ff5e,>ff68,>ff72,>ff7c,>ff87,>ff93
       data >ff9e,>ffaa,>ffb6,>ffc2,>ffce,>ffda,>ffe7,>fff3

***************************************************************
*
* Data files
*
columns:
       copy "columns.a99"
       copy "chars.a99"

       aorg >2000
map:
       copy "map.a99"

       end  main
