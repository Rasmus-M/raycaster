*********************************************************************
*
* Raycaster
* For the TI-99/4A home computer
*
* April 2020
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "sound-defs.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >0800                      ; Pattern table base 2
ptrnt3 equ  >1000                      ; Pattern table base 3
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
colrt2 equ  >2800                      ; Color table base 2
colrt3 equ  >3000                      ; Color table base 3
nametb equ  >3800                      ; Name table base
spratb equ  >3c00                      ; Sprite attribute table base 1
sprat2 equ  >3c80                      ; Sprite attribute table base 2
sprat3 equ  >3d00                      ; Sprite attribute table base 3
sprat4 equ  >3d80                      ; Sprite attribute table base 4
sprat5 equ  >3e00                      ; Sprite attribute table base 5
sprat6 equ  >3e80                      ; Sprite attribute table base 6
sprat7 equ  >3f00                      ; Sprite attribute table base 7
sprat8 equ  >3f80                      ; Sprite attribute table base 8

**
* Constants
*
map_width:
       equ  64
map_height:
       equ  64
screen_width:
       equ  64
screen_height:
       equ  192
n_directions:
       equ  256
angle_mask:
       equ  2*n_directions-1
n_rays:
       equ  screen_width
max_steps:
       equ  24
max_wall_height:
       equ  528
object_height:
       equ  160
max_object_distance:
       equ  16
max_bullet_distance:
       equ  16
max_object_width:
       equ  32
max_objects:
       equ  16
n_sprite_patterns:
       equ  25
n_fixed_sprites:
       equ  10
guard_speed:
       equ  >0010
bullet_speed_z:
       equ  ->0c00
bullet_accl_z:
       equ  >0100
gun_color:
       equ  >01
bullet_color:
       equ  >0f
backdrop_color:
       equ  >0e
char_0:
       equ  >30
first_texture_index:
       equ  10
initial_health:
       equ  63
texture_bank_select:
       equ  >6040
texture_sams_page:                     ; 16
       equ  >1000
n_texture_banks:
       equ  24
texture_width:                         ; Width in fat pixels
       equ  16
sprite_texture_width:                  ; Width in not so fat pixels
       equ  32
texture_height:
       equ  64
texture_size:
       equ  (texture_width/2)*texture_height;
background_address:
       equ  >6800

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
one:
       equ  padcon
**
* PAD variables
*
padvar:
       equ  one+2                      ; Start of pad variables
interrupt_count:
       equ  padvar
rand_no:
       equ  interrupt_count+2
sal_no:
       equ  rand_no+2
score:
       equ  sal_no+2
old_score:
       equ  score+2
health:
       equ  old_score+2
old_health:
       equ  health+2
status:
       equ  old_health+2
x:                                     ; Player x FP 8.8
       equ  status+2
y:                                     ; Player y FP 8.8
       equ  x+2
dx:
       equ  y+2
dy:
       equ  dx+2
angle:                                 ; Player direction 0 - 2 * n_directions (even only)
       equ  dy+2
ray_count:
       equ  angle+2
ray_angle:
       equ  ray_count+2
distance:
       equ  ray_angle+2
column_ptr:
       equ  distance+2
cast_required:
       equ  column_ptr+2
muzzle_flash:
       equ  cast_required+2
snd_channel_1:
       equ  muzzle_flash+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
module_speed:
       equ  snd_track_3+snd_track_size
get_speech_status:
       equ  module_speed+2
speech_ptr:
       equ  get_speech_status+6
speech_on:
       equ  speech_ptr+2
background_bank_select:
       equ  speech_on+2
old_angle:
       equ  background_bank_select+2
angle_diff:
       equ  old_angle+2
old_even_height:
       equ  angle_diff+2
cast_ray_loop_pad:
       equ  old_even_height+2
upload_screen_loop_pad:
       equ  cast_ray_loop_pad+40
pad_max:
       equ  upload_screen_loop_pad+22

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
restart:
       bl   @init_level
main_loop:
       clr  @interrupt_count
       bl   @vsync
       bl   @set_vdp_regs
       abs  @cast_required
       jeq  main_loop_1
       bl   @cast_rays
       clr  @cast_required
       jmp  main_loop_2
main_loop_1:
       bl   @skip_cast_rays
       bl   @vsync
main_loop_2:
       bl   @draw_screen
       bl   @draw_objects
       bl   @upload_screen
       bl   @user_input
       bl   @move_enemies
       bl   @move_bullets
       bl   @draw_bullets
       bl   @bullet_collisions
       bl   @object_collisions
;      bl   @update_health_bar
;      bl   @display_score
       bl   @speak
       mov  @status,r0
       jeq  main_loop
       jgt  finish
       bl   @play_die
       jmp  pause
finish:
       bl   @play_finish
pause:
       li   r14,120
pause_loop:
       bl   @vsync
       dec  r14
       jne  pause_loop
pause_loop_1:
       bl   @vsync
       li   r0,KEY_FI
       bl   @check_key
       jeq  pause_loop_1
       jmp  restart

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12                ; Clear any pending interrupt
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       inc  @interrupt_count
       movb @vdpsta,r12
       .push r11
       bl   @snd_player
       .pop r11
       rt
*// vsync

*********************************************************************
*
* Check for interrupt
*
check_int:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  check_int_1
       inc  @interrupt_count
       movb @vdpsta,r12
       .push r11
       bl   @snd_player
       .pop r11
check_int_1:
       rt
*// check_int

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set sprite attribute table
       li   r0,>0500+(spratb/>80)
       a    @sal_no,r0
       bl   @vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,columns
       mov  r0,@column_ptr
       li   r2,n_rays                  ; Number of rays to cast
       mov  r2,@ray_count              ; Init count-down
       mov  @angle,r2                  ; Player direction (even only)
       ai  r2,-n_rays                  ; Direction of leftmost ray
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_angle,r2              ; Direction
       bl   @cast_ray                  ; Cast ray (r2=distance, r3=side, r4=color)
       mov  r2,@distance               ; Save euclidian distance
       bl   @fish_eye_correction       ; Adjust distance in r2
*      Calculate height and color of column
       mov  @column_ptr,r5
       mov  r2,r0                      ; Distance as FP 8.8
       jne  cast_rays_2
       li   r0,max_wall_height         ; Max height
       jmp  cast_rays_3
cast_rays_2:
       clr  r0
       li   r1,screen_height*256       ; 192 as FP 24.8
       div  r2,r0                      ; height = 192 / distance, as FP 16.0
cast_rays_3:
       mov  @column_height(r5),@column_height_old(r5)
       andi r0,>fffe                   ; Make height even
       mov  r0,@column_height(r5)
       mov  @distance,@column_distance(r5)
       mov  @distance,@column_distance_copy(r5)
       bl   @wall_color
       ai   r5,column_size
       mov  r5,@column_ptr
*      Next ray
       mov  @ray_angle,r2              ; Get ray direction
       inct r2                         ; Increment it
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save it
       bl   @check_int
       dec  @ray_count                 ; Count down
       jne  cast_rays_1                ; Loop if more rays to cast
       .endproc
*// cast_rays

*********************************************************************
*
* Skip cast rays
*
skip_cast_rays:
       li   r4,columns
       li   r5,n_rays                  ; Number of columns
skip_cast_rays_1:
       mov  @column_height(r4),@column_height_old(r4)
       szc  @full_redraw_bit,@column_height(r4)
       mov  @column_color(r4),@column_color_old(r4)
       mov  @column_distance_copy(r4),@column_distance(r4)
*      Next column
       ai   r4,column_size
       dec  r5                         ; Count down
       jne  skip_cast_rays_1           ; Loop if more columns
       rt
*// skip_cast_rays

*********************************************************************
*
* Fish-eye correction
* Calculate perpendicualar distance from euclidian distance in r2
*
fish_eye_correction:
       mov  @ray_angle,r12             ; Ray direction
       s    @angle,r12                 ; Angle offset
       andi r12,angle_mask             ; Wrap around
       mov  @cos_table(r12),r12        ; Cosine of angle (positive)
       mpy  r2,r12                     ; Multiply by distance
       movb @r12lb,r2                  ; Move result back
       movb r13,@r2lb                  ; into r2
       rt
*// fish_eye_correction

*********************************************************************
*
* Calculate wall color from map color
*
* r3: 0 = x face, 1 = y face
* r4: map color
* r5: column to update
*
* Updates column.column_color and column.column_hit_x.
* If no texture column.column_hit_x is set to -1.
*
wall_color:
       mov  r4,r4                      ; Color
       jne  wall_color_0               ; Jump if wall
       li   r4,15                      ; No wall color
       seto @column_hit_x(r5)          ; No texture
       jmp  wall_color_6               ; Return
wall_color_0:
       ci   r4,first_texture_index     ; Check for texture
       jhe  wall_color_1               ; Jump if texture
*      Single color
       andi r4,>fffe                   ; Clear secret door bit
       dect r4                         ; Shift to zero base
       a    r3,r4                      ; Different color on x/y facing walls
       sla  r4,1
       mov  @wall_colors(r4),r4        ; Color
       seto @column_hit_x(r5)          ; No texture
       jmp  wall_color_6               ; Return
*      Texture
wall_color_1:
       mov  @ray_angle,r12             ; Ray direction
       mov  r3,r3                      ; Check side
       jne  wall_color_3               ; Jump if y side
*      Texture x side
       mov  @sin_table(r12),r12        ; dirY
       jlt  wall_color_2
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @y,r12                     ; playerY + sin(a)
       jmp  wall_color_5
wall_color_2:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @y,r12                     ; playerY + sin(a)
       jmp  wall_color_5
*      Texture y side
wall_color_3:
       mov  @cos_table(r12),r12        ; dirX
       jlt  wall_color_4
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @x,r12                     ; playerY + sin(a)
       jmp  wall_color_5
wall_color_4:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @x,r12                     ; playerY + sin(a)
wall_color_5:
       ai   r4,-first_texture_index    ; Texture index
       andi r12,>00ff
       mov  r12,@column_hit_x(r5)
wall_color_6:
       mov  @column_color(r5),@column_color_old(r5)
       mov  r4,@column_color(r5)
       rt
wall_colors:
       data 14,15
       data 6,9
       data 12,3
       data 4,5
*// wall_color

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the side hit (0 = x-side, 1 = y-side)
* r4 contains the map entry/color
*
cast_ray:
       .proc
*      Set up variables
       mov  r0,r6                      ; Player x
       mov  r1,r8                      ; Player y
       andi r0,>ff00                   ; mapX
       andi r1,>ff00                   ; mapY
       andi r6,>00ff                   ; fracX
       andi r8,>00ff                   ; fracY
       mov  @inv_cos_table(r2),r4      ; deltaDistX
       mov  @inv_sin_table(r2),r5      ; deltaDistY
*      Calculate sideDistX
       mov  @cos_table(r2),r3          ; dirX
       jlt  cast_ray_1                 ; dirX < 0 ?
       jgt  cast_ray_2                 ; dirX > 0 ?
       clr  r6                         ; stepX
       li   r7,>7f00                   ; sideDistX (max value)
       jmp  cast_ray_3
cast_ray_1:
       mpy  r4,r6                      ; sideDistX = fracX * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,-1                      ; stepX = -1
       jmp  cast_ray_3
cast_ray_2:
       neg  r6                         ; -fracX
       ai   r6,>0100                   ; 1 - fracX
       mpy  r4,r6                      ; sideDistX = (1 - fracX) * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,1                       ; stepX = 1
*      Calculate sideDistY
cast_ray_3:
       mov  @sin_table(r2),r3          ; dirY
       jlt  cast_ray_4                 ; dirY < 0 ?
       jgt  cast_ray_5                 ; dirY < 0 ?
       clr  r8                         ; stepY
       li   r9,>7f00                   ; sideDistY (max value)
       jmp  cast_ray_6
cast_ray_4:
       mpy  r5,r8                      ; sideDistY = fracY * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,-map_width              ; stepY = -1
       jmp  cast_ray_6
cast_ray_5:
       neg  r8                         ; -fracY
       ai   r8,>0100                   ; 1 - fracY
       mpy  r5,r8                      ; sideDistY = (1 - fracY) * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,map_width               ; stepY = 1
*      Map address from coordinates
cast_ray_6:
       bl   @get_map_address
       mov  r2,r12
*      Cast the ray
       li   r2,max_steps               ; Step counter
       bl   @cast_ray_loop_pad
*      Update visible map
       socb @byte_80,*r12
       szcb @byte_80,r13
*      Coordinates from map address (maybe not required)
;       ai   r12,-map
;       movb @r12lb,r0
;       movb r12,r1
*      Calculate distance
       mov  r2,r2                      ; Steps left
       jne  cast_ray_7
       li   r2,max_steps*256           ; Max distance
       clr  r4                         ; Reset color
       jmp  cast_ray_10
cast_ray_7:
       mov  r3,r3                      ; xSide ?
       jne  cast_ray_8
       s    r4,r7                      ; sideDistX -= deltaDistX
       mov  r7,r2                      ; Distance
       jmp  cast_ray_9
cast_ray_8:
       s    r5,r9                      ; sideDistY -= deltaDistY
       mov  r9,r2                      ; Distance
*      Color and side
cast_ray_9:
       clr  r4                         ; Clear color
       movb r13,@r4lb                  ; Set color
cast_ray_10:
       abs  r3                         ; Side
       .endproc                        ; Return
*// cast_ray

***************************************************************
*
* Cast ray loop
*
cast_ray_loop:
       c    r7,r9                      ; sideDistX < sideDistY ?
       jgt  cast_ray_loop_1
       a    r4,r7                      ; sideDistX += deltaDistX
       a    r6,r12                     ; mapX += stepX
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_2            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_1:
       a    r5,r9                      ; sideDistY += deltaDistY
       a    r8,r12                     ; mapY += stepY
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_3            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_2:
       clr  r3                         ; xSide = 1
       rt
cast_ray_loop_3:
       seto r3                         ; xSide = -1
       rt
cast_ray_loop_end:
       equ  $
*// cast_ray_loop

*********************************************************************
*
* Draw screen
*
draw_screen:
       .proc
       bl   @calc_background_bank
       mov  @angle,r0
       s    @old_angle,r0
       mov  r0,@angle_diff
       li   r3,screen_buffer
       li   r4,columns
       clr  r5
       li   r8,background_address
draw_screen_1:
*      Check even or odd
       mov  r5,r0
       andi r0,1
       jne  draw_screen_3
*      Check if column and next can be skipped
       abs  @angle_diff
       jne  draw_screen_2
       c    @column_height(r4),@column_height_old(r4)
       jne  draw_screen_2
       c    @column_color(r4),@column_color_old(r4)
       jne  draw_screen_2
       c    @column_height+column_size(r4),@column_height_old+column_size(r4)
       jne  draw_screen_2
       c    @column_color+column_size(r4),@column_color_old+column_size(r4)
       jne  draw_screen_2
*      No need to redraw columns
       seto @column_skip(r4)
       ai   r3,screen_height
       ai   r8,screen_height
       ai   r4,column_size*2
       inct r5
       jmp  draw_screen_5
draw_screen_2:
*      Draw even column
       clr  @column_skip(r4)
       bl   @draw_even_column
       ai   r3,-screen_height
       ai   r8,-screen_height
       jmp  draw_screen_4
draw_screen_3:
*      Draw odd column
       clr  @column_skip(r4)
       bl   @draw_odd_column
draw_screen_4:
*      Next column
       ai   r4,column_size
       inc  r5
draw_screen_5:
       ci   r5,n_rays
       jlt  draw_screen_1
*      Done
       mov  @angle,@old_angle
       bl   @check_int
       .endproc
*// draw_screen

*********************************************************************
*
* Calculate ROM bank for background
*
calc_background_bank:
       mov  @angle,r0
       andi r0,>01c0
       srl  r0,5
       ai   r0,>6020
       mov  r0,@background_bank_select
       rt
*// calc_background_bank

*********************************************************************
*
* Draw even column
*
* r3: Screen buffer
* r4: Column structure
* r5: Column number
* r8: Background address
*
draw_even_column:
       .proc
       mov  @column_height(r4),r6      ; Wall height
       ci   r6,screen_height
       jle  draw_even_column_1
       li   r6,screen_height
draw_even_column_1:
*      Old height
       mov  @column_height_old(r4),r9                ; Get old wall height
       c    r9,@column_height_old+column_size(r4)    ; Check if odd wall was taller
       jhe  draw_even_column_9
       mov  @column_height_old+column_size(r4),r9    ; Use the tallest of the two walls
draw_even_column_9:
       ci   r9,screen_height
       jle  draw_even_column_10
       li   r9,screen_height
draw_even_column_10:
       s    r6,r9                      ; Old minus new
       sra  r9,1                       ; / 2
*      Sky
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       srl  r2,1                       ; Div 2
       mov  r2,r7                      ; Save height of sky
       jeq  draw_even_column_3
       abs  @angle_diff
       jeq  draw_even_column_2
*      Redraw whole column
       bl   @draw_even_background_pixels
       jmp  draw_even_column_3
*      Redraw part or none
draw_even_column_2:
       a    r7,r3                      ; Advance screen buffer address
       a    r7,r8                      ; Advance source address
       mov  r9,r9                      ; Wall difference
       jlt  draw_even_column_3         ; New wall taller
       jeq  draw_even_column_3         ; New wall equal
*      Redraw part
       s    r9,r3                      ; Backtrack screen buffer address
       s    r9,r8                      ; Backtrack source address
       mov  r9,r2                      ; Number of pixels to draw
       bl   @draw_even_background_pixels
*      Wall
draw_even_column_3:
       mov  r6,r2                      ; Wall height
       jeq  draw_even_column_5         ; Jump if zero
       a    r2,r8                      ; Add height to background source address
       mov  @column_color(r4),r1       ; Color / texture number
       mov  @column_hit_x(r4),r0       ; Check for texture
       jlt  draw_even_column_4         ; No texture if -1
*      Wall textured
       bl   @prepare_texture           ; Calculate texture address
       ai   r0,even_col_vector_0
*      Cartridge bank for drawing code
       mov  *r0+,r2
       seto *r2
*      Draw routine address
       mov  *r0,r2
       bl   *r2
       jmp  draw_even_column_5
draw_even_column_4:
*      Wall single color
       sla  r1,4
       movb @r1lb,r1
       bl   @draw_even_pixels
*      Floor
draw_even_column_5:
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       s    r7,r2                      ; Minus sky height
       jeq  draw_even_column_8
       abs  @angle_diff
       jeq  draw_even_column_6
*      Redraw whole column
       bl   @draw_even_background_pixels
       jmp  draw_even_column_8
*      Redraw part or none
draw_even_column_6:
       mov  r9,r9                      ; Old wall height minus new
       jlt  draw_even_column_7         ; New wall taller
       jeq  draw_even_column_7         ; New wall equal
*      Redraw part
       mov  r2,r12
       mov  r9,r2                      ; Number of pixels to draw
       bl   @draw_even_background_pixels
       s    r9,r12
       mov  r12,r2
draw_even_column_7:
       a    r2,r3                      ; Advance screen buffer address
       a    r2,r8                      ; Advance source address
draw_even_column_8:
       .endproc
*// draw_even_column

*********************************************************************
*
* Draw a column of background pixels (even)
*
* r8: Source address
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
* We can assume that if r8 is odd then r3 is also odd.
*
draw_even_background_pixels:
       mov  @background_bank_select,r0
       seto *r0
       coc  @one,r3
       jne  draw_even_background_pixels_0
       movb *r8+,*r3+
       dec  r2
       jeq  draw_even_background_pixels_4
draw_even_background_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_even_background_pixels_2
draw_even_background_pixels_1:
       mov  *r8+,*r3+
       mov  *r8+,*r3+
       mov  *r8+,*r3+
       mov  *r8+,*r3+
       dec  r2
       jne  draw_even_background_pixels_1
draw_even_background_pixels_2:
       andi r0,7
       jeq  draw_even_background_pixels_4
draw_even_background_pixels_3:
       movb *r8+,*r3+
       dec  r0
       jne  draw_even_background_pixels_3
draw_even_background_pixels_4:
       rt
*// draw_even_background_pixels

*********************************************************************
*
* Draw a column of identical pixels (even)
*
* r1: Color in upper nybble of MSB and LSB
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
*
draw_even_pixels:
       coc  @one,r3
       jne  draw_even_pixels_0
       movb r1,*r3+
       dec  r2
       jeq  draw_even_pixels_4
draw_even_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_even_pixels_2
draw_even_pixels_1:
       mov  r1,*r3+
       mov  r1,*r3+
       mov  r1,*r3+
       mov  r1,*r3+
       dec  r2
       jne  draw_even_pixels_1
draw_even_pixels_2:
       andi r0,7
       jeq  draw_even_pixels_4
draw_even_pixels_3:
       movb r1,*r3+
       dec  r0
       jne  draw_even_pixels_3
draw_even_pixels_4:
       rt
*// draw_even_pixels

*********************************************************************
*
* Draw odd column
*
* r3: Screen buffer
* r4: Column structure
* r5: Column number
* r8: Background address
*
draw_odd_column:
       .proc
       mov  @column_height(r4),r6      ; Wall height
       ci   r6,screen_height
       jle  draw_odd_column_1
       li   r6,screen_height
draw_odd_column_1:
*      Old height
       mov  @column_height_old(r4),r9                ; Get old wall height
       c    r9,@column_height_old-column_size(r4)    ; Check if even wall was taller
       jhe  draw_odd_column_9
       mov  @column_height_old-column_size(r4),r9    ; Use tallest of the two walls
draw_odd_column_9:
       ci   r9,screen_height
       jle  draw_odd_column_10
       li   r9,screen_height
draw_odd_column_10:
       s    r6,r9                      ; Old minus new
       sra  r9,1                       ; / 2
*      Sky
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       srl  r2,1                       ; Div 2
       mov  r2,r7                      ; Save height of sky
       jeq  draw_odd_column_3
       abs  @angle_diff
       jeq  draw_odd_column_2
*      Redraw whole column
       bl   @draw_odd_background_pixels
       jmp  draw_odd_column_3
*      Redraw part or none
draw_odd_column_2:
       a    r7,r3                      ; Advance screen buffer address
       a    r7,r8                      ; Advance source address
       mov  r9,r9                      ; Wall difference
       jlt  draw_odd_column_3          ; New wall taller
       jeq  draw_odd_column_3          ; New wall equal
*      Redraw part
       s    r9,r3                      ; Backtrack screen buffer address
       s    r9,r8                      ; Backtrack source address
       mov  r9,r2                      ; Number of pixels to draw
       bl   @draw_odd_background_pixels
*      Wall
draw_odd_column_3:
       mov  r6,r2                      ; Wall height
       jeq  draw_odd_column_5          ; Jump if zero
       a    r2,r8                      ; Add height to background source address
       mov  @column_color(r4),r1       ; Color / texture number
       mov  @column_hit_x(r4),r0       ; Check for texture
       jlt  draw_odd_column_4          ; No texture if -1
*      Wall textured
       bl   @prepare_texture           ; Calculate texture address
       ai   r1,2048                    ; Add offset to odd column texture
       ai   r0,odd_col_vector_0
*      Cartridge bank for drawing code
       mov  *r0+,r2
       seto *r2
*      Draw routine address
       mov  *r0,r2
       bl   *r2
       jmp  draw_odd_column_5
draw_odd_column_4:
*      Wall single color
       movb @r1lb,r1
       bl   @draw_odd_pixels
*      Floor
draw_odd_column_5:
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       s    r7,r2                      ; Minus sky height
       jeq  draw_odd_column_8
       abs  @angle_diff
       jeq  draw_odd_column_6
*      Redraw whole column
       bl   @draw_odd_background_pixels
       jmp  draw_odd_column_8
*      Redraw part or none
draw_odd_column_6:
       mov  r9,r9                      ; Old wall height minus new
       jlt  draw_odd_column_7         ; New wall taller
       jeq  draw_odd_column_7         ; New wall equal
*      Redraw part
       mov  r2,r12
       mov  r9,r2                      ; Number of pixels to draw
       bl   @draw_odd_background_pixels
       s    r9,r12
       mov  r12,r2
draw_odd_column_7:
       a    r2,r3                      ; Advance screen buffer address
       a    r2,r8                      ; Advance source address
draw_odd_column_8:
       .endproc
*// draw_odd_column

*********************************************************************
*
* Draw a column of background pixels (odd)
*
* r8: Source address
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
* We can assume that if r8 is odd then r3 is also odd.
*
draw_odd_background_pixels:
       mov  @background_bank_select,r0
       ai   r0,>10
       seto *r0
       coc  @one,r3
       jne  draw_odd_background_pixels_0
       socb *r8+,*r3+
       dec  r2
       jeq  draw_odd_background_pixels_4
draw_odd_background_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_odd_background_pixels_2
draw_odd_background_pixels_1:
       soc  *r8+,*r3+
       soc  *r8+,*r3+
       soc  *r8+,*r3+
       soc  *r8+,*r3+
       dec  r2
       jne  draw_odd_background_pixels_1
draw_odd_background_pixels_2:
       andi r0,7
       jeq  draw_odd_background_pixels_4
draw_odd_background_pixels_3:
       socb *r8+,*r3+
       dec  r0
       jne  draw_odd_background_pixels_3
draw_odd_background_pixels_4:
       rt
*// draw_odd_background_pixels

*********************************************************************
*
* Draw a column of identical pixels (odd)
*
* r1: Color in lower nybble of MSB and LSB
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
*
draw_odd_pixels:
       coc  @one,r3
       jne  draw_odd_pixels_0
       socb r1,*r3+
       dec  r2
       jeq  draw_odd_pixels_4
draw_odd_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_odd_pixels_2
draw_odd_pixels_1:
       soc  r1,*r3+
       soc  r1,*r3+
       soc  r1,*r3+
       soc  r1,*r3+
       dec  r2
       jne  draw_odd_pixels_1
draw_odd_pixels_2:
       andi r0,7
       jeq  draw_odd_pixels_4
draw_odd_pixels_3:
       socb r1,*r3+
       dec  r0
       jne  draw_odd_pixels_3
draw_odd_pixels_4:
       rt
*// draw_odd_pixels

*********************************************************************
*
* Calculate texture address
*
* r0: Texture hit x (FP 8.8)
* r1: Texture number
* r4: Column structure
*
* On return r0 contains the address of the routine to draw the column,
* and r1 contains the texture source address,

prepare_texture:
*      Select SAMS bank
       swpb r1
       ai   r1,texture_sams_page
       mov  r1,@sams_reg_2
*      Texture address
       mov  r0,r1
       srl  r1,3                       ; Column of texture
       sla  r1,6                       ; * 64
       ai   r1,textures                ; Base texture column source address
*      Column drawing vector offset
       mov  @column_height(r4),r0
       ci   r0,screen_height
       jh   prepare_texture_1
;      srl  r0,1                       ; / 2
;      sla  r0,2                       ; * 4
       sla  r0,1                       ; * 2
       jmp  prepare_texture_3
prepare_texture_1:
       ci   r0,528
       jle   prepare_texture_2
       li   r0,528
prepare_texture_2:
       ai   r0,-192
       srl  r0,3                       ; / 8
       sla  r0,2                       ; * 4
       ai   r0,192*2
prepare_texture_3:
       rt
*// prepare_texture

*********************************************************************
*
* Draw objects
*
draw_objects:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  draw_objects_3
draw_objects_1:
       mov  *r4,r0                     ; Active?
       jeq  draw_objects_2
       mov  @object_x(r4),r0
       s    @x,r0                      ; dx
       mov  @object_y(r4),r1
       s    @y,r1                      ; dy
       mov  r0,r2
       abs  r2
       mov  r1,r3
       abs  r3
       a    r2,r3                      ; Taxi distance
       ci   r3,max_object_distance*256
       jhe  draw_objects_2
*      Look up angle
       bl   @atan2
       srl  r6,7
       s    @angle,r6
       ci   r6,-n_rays-max_object_width
       jlt  draw_objects_2
       ci   r6,n_rays+max_object_width-1
       jgt  draw_objects_2
*      Look up distance
       bl   @euclidian_distance
       ci   r7,max_object_distance*256
       jgt  draw_objects_2
*      Object is within view and distance
       bl   @draw_object
;      jmp  draw_objects_3             ; Only draw one object
draw_objects_2:
       ai   r4,object_size
       dec  r5
       jne  draw_objects_1
draw_objects_3:
       bl   @check_int
       .endproc
*// draw_objects

*********************************************************************
*
* Draw object
*
* r4: object to draw
* r6: angle relative to player (2 units per column)
* r7: distance FP 8.8 (last 6 bits are zero)
*
draw_object:
       .proc
       .push r4
       .push r5
*      Width, Height
       ci   r7,>0100
       jgt  draw_object_1
       li   r2,object_height
       jmp  draw_object_2
draw_object_1:
       clr  r2
       li   r3,object_height*256       ; 192 as FP 24.8
       div  r7,r2                      ; Size (FP 16.0) = 192 / distance
draw_object_2:
       mov  r2,r3                      ; Height = size
       srl  r2,2                       ; Width = size / 4
*      Column
       li   r0,screen_width
       a    r6,r0
       s    r2,r0
       sra  r0,1
*      Row
       li   r1,screen_height           ; Screen height
       s    r3,r1                      ; Minus sprite height
       srl  r1,1                       ; Divided by 2
*      Texture
       mov  @object_texture(r4),r4     ; Texture number
*      Distance
       mov  r7,r5                      ; Depth/distance
*      Draw sprite
       bl   @draw_sprite
       .pop r5
       .pop r4
*      Speak first time
       mov  @object_speech(r4),r1
       jeq  draw_object_11
       bl   @say_phrase
       clr  @object_speech(r4)
;*      Muzzle flash
;draw_object_10:
;       abs  @object_fire(r4)
;       jeq  draw_object_11
;       mov  r6,r0
;       dec  r0
;       sla  r0,3
;       ori  r0,>6000
;       mov  r0,@muzzle_flash
;       clr  @object_fire(r4)
draw_object_11:
       .endproc
*// draw_object

*********************************************************************
*
* Draw sprite
*
* r0: column
* r1: row
* r2: width
* r3: height
* r4: texture number
* r5: depth/distance (FP 8.8)
*
* Modifies all registers except r3, r10, r15
*
* Texture organised as:
* Pixels in even nibble (16 column x 64 bytes = 1024 bytes)
* Pixels in odd nibble (16 column x 64 bytes = 1024 bytes)
*
draw_sprite:
       .push r15
       li   r15,r13lb
       mov  r5,r12                     ; Save depth/distance
*      Screen buffer address (r1)
       mov  r0,r8                      ; Save screen column
       mov  r0,r13                     ; Screen column
       jgt  draw_sprite_0a
       neg  r13
draw_sprite_0a:
       andi r13,>003e                  ; Make even
       li   r14,screen_height/2        ; Column size in bytes
       mpy  r14,r13                    ; Even column * column size in bytes
       mov  r0,r0
       jgt  draw_sprite_0b
       neg  r14
draw_sprite_0b:
       a    r14,r1                     ; Add to row
       ai   r1,screen_buffer           ; Add base address
*      Texture address (r0)
       swpb r4                         ; To MSB
       ai   r4,texture_sams_page       ; Add base SAMS page
       mov  r4,@sams_reg_2             ; Page it in
       li   r0,sams_window             ; Texture base address (FP 16.0)
*      Texture X offset (r4) and increment (r5)
       clr  r4                         ; Texture X offset FP 8.8
       ci   r2,sprite_texture_width    ; Check how to calculate texture width / sprite width
       jgt  draw_sprite_1
       clr  r13                        ; Texture width FP 24.8
       li   r14,sprite_texture_width*256
       div  r2,r13                     ; Div by sprite width FP 16.0 -> increment as FP 8.8
       jmp  draw_sprite_2
draw_sprite_1:
       li   r13,sprite_texture_width   ; Texture width FP 16.16
       clr  r14
       div  r2,r13                     ; Div sprite width FP 16.0 -> increment as FP 0.16
       srl  r13,8                      ; Increment as FP 8.8
draw_sprite_2:
       mov  r13,r5                     ; Texture X offset increment per pixel FP 8.8
*      Texture Y offset (r6) and increment (r7)
       clr  r6                         ; Texture Y offset FP 8.8
       ci   r3,texture_height          ; Check how to calulate texture height / sprite height
       jgt  draw_sprite_3
       clr  r13                        ; Texture height FP 24.8
       li   r14,texture_height*256
       div  r3,r13                     ; Div by sprite height FP 16.0 -> y-step as FP 8.8
       jmp  draw_sprite_4
draw_sprite_3:
       li   r13,texture_height         ; Texture height FP 16.16
       clr  r14
       div  r3,r13                     ; Div sprite height FP 16.0 -> y-step as FP 0.16
       srl  r13,8                      ; y-step as FP 8.8
draw_sprite_4:
       mov  r13,r7                     ; Texture X offset increment per pixel FP 8.8
*      Column loop
draw_sprite_5:
       mov  r8,r13                     ; Screen column
       jlt  draw_sprite_5a             ; Skip column if out of screen
       ci   r13,screen_width-1         ; Check against right side of screen
       jgt  draw_sprite_5a             ; Skip column if out of screen
       sla  r13,4                      ; * 16 (size of column structure)
       c    r12,@columns+column_distance(r13)  ; Compare sprite depth to wall distance
       jlt  draw_sprite_6              ; Draw if less than
*      Skip column
draw_sprite_5a:
       a    r3,r1
       jmp  draw_sprite_11
*      Draw column
draw_sprite_6:
       mov  r12,@columns+column_distance(r13)    ; Record new distance for column
       soc  @full_redraw_bit,@columns+column_height(r13)    ; Redraw floor/ceiling next frame
       clr  @columns+column_skip(r13)  ; Upload column this frame
       andi r0,>f000                   ; Round texture address to whole 4K
       mov  r4,r13                     ; Texture x offset
       andi r13,>1f00                  ; Isolate texture column bits
       srl  r13,2                      ; Texture column index * 64
       soc  r13,r0                     ; Add to texture address
       coc  @one,r8                    ; Test if screen column is even/odd
       jeq  draw_sprite_7              ; Jump if odd
*      Even destination column
       li   r9,>f000                   ; Mask for even pixel
       andi r0,>f7ff                   ; Modify texture address for even pixels
       jmp  draw_sprite_8
*      Odd destination column
draw_sprite_7:
       li   r9,>0f00                   ; Mask for odd pixel
       ori  r0,>0800                   ; Modify texture address for odd pixels
*      Row loop
draw_sprite_8:
       mov  r3,r14                     ; Set screen row counter to height
draw_sprite_9:
       mov  r0,r13                     ; Texture column start address
       ab   r6,*r15                    ; Add offset to LSB (r15 is r6 low byte)
       movb *r13,r13                   ; Get texture byte
       jeq  draw_sprite_10             ; Skip if zero
       szcb r9,*r1                     ; Remove existing pixel from screen buffer
       socb r13,*r1+                   ; Set new pixel in screen buffer
       a    r7,r6                      ; Increment texture y offset
       dec  r14                        ; Screen row counter
       jne  draw_sprite_9              ; Next row
       jmp  draw_sprite_11             ; Jump out
draw_sprite_10:
       inc  r1                         ; Next screen buffer address
       a    r7,r6                      ; Increment texture y offset
       dec  r14                        ; Screen row counter
       jne  draw_sprite_9              ; Next row
draw_sprite_11:
       s    r3,r1                      ; Move screen buffer address back to top of column
       coc  @one,r8                    ; Test if screen column is even/odd
       jne  draw_sprite_12             ; Jump if even
       ai   r1,screen_height           ; For odd column, move screen buffer address to next column
draw_sprite_12:
       a    r5,r4                      ; Increment texture x offset
       clr  r6                         ; Clear texture y offset
       inc  r8                         ; Next column
       dec  r2                         ; Column counter (width)
       jne  draw_sprite_5              ; Next column
*      Return
       .pop r15
       rt
full_redraw_bit:
       data 1024
*// draw_sprite

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       abs  @angle_diff
       jeq  upload_screen_3
*      Full update
       li   r0,colrtb
       bl   @vwad
       li   r5,screen_buffer
       li   r6,3
upload_screen_1:
       li   r7,32
upload_screen_2:
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r5,192-64
       dec  r7
       jne  upload_screen_2
       bl   @check_int
       ai   r5,64-(32*192)
       dec  r6
       jne  upload_screen_1
       jmp  upload_screen_8
*      Column update
upload_screen_3:
       li   r0,colrtb+>4000
       li   r1,columns
       li   r2,32
       li   r5,screen_buffer
       li   r9,64
       li   r14,vdpwa
upload_screen_4:
       abs  @column_skip(r1)
       jeq  upload_screen_5
       ai   r0,64
       ai   r5,192
       jmp  upload_screen_7
upload_screen_5:
       c    @column_height(r1),r9
       jgt  upload_screen_9
       c    @column_height_old(r1),r9
       jgt  upload_screen_9
       c    @column_height+column_size(r1),r9
       jgt  upload_screen_9
       c    @column_height_old+column_size(r1),r9
       jgt  upload_screen_9
*      Update middle 3rd only
       ai   r0,>800
       movb @r0lb,*r14
       movb r0,*r14
       ai   r5,64
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r0,->800+64
       ai   r5,64
       jmp  upload_screen_7
*      Update whole column
upload_screen_9:
       li   r4,3
upload_screen_6:
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r0,>800
       dec  r4
       jne  upload_screen_6
       ai   r0,->1800+64
upload_screen_7:
       ai   r1,column_size*2
       dec  r2
       jne  upload_screen_4
upload_screen_8:
       .endproc
*// upload_screen

*********************************************************************
*
* Upload screen loop
*
upload_screen_loop:
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       dec  r8
       jne  upload_screen_loop
       rt
upload_screen_loop_end:
       equ  $
*// upload_screen_loop

*********************************************************************
*
* Read user input
*
user_input:
       .proc
*      Map
       li   r0,KEY_M
       bl   @check_key
       jeq  user_input_0
       bl   @display_map
       jmp  user_input_8
*      Joystick
user_input_0:
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       abs  @bullet_active
       jne  user_input_1
       bl   @fire_bullet
*      Left
user_input_1:
       tb   1
       jeq  user_input_2
       mov  @angle,r0
       ai   r0,-64                    ; Turn left
       andi r0,angle_mask
       mov  r0,@angle
       srl  r0,4
       mov  r0,r1
       ai   r0,dirs
       mov  *r0+,@dx
       mov  *r0,@dy
       srl  r1,2
       mov  r1,@sal_no
       seto @cast_required
       jmp  user_input_3
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       mov  @angle,r0
       ai   r0,64                     ; Turn right
       andi r0,angle_mask
       mov  r0,@angle
       srl  r0,4
       mov  r0,r1
       ai   r0,dirs
       mov  *r0+,@dx
       mov  *r0,@dy
       srl  r1,2
       mov  r1,@sal_no
       seto @cast_required
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       mov  @x,r0
       s    @dx,r0
       mov  @y,r1
       s    @dy,r1
       bl   @get_map_value
       jne  user_input_8
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_8
       mov  @x,r0
       a    @dx,r0
       mov  @y,r1
       a    @dy,r1
       bl   @get_map_value
       jeq  user_input_5
       cb   @goal,r2                   ; Check for goal
       jne  user_input_9
       inc  @status                    ; Finish
       jmp  user_input_8
user_input_9:
       ci   r2,first_texture_index*256 ; Check for texture
       jhe  user_input_8               ; Cannot move through texture
       andi r2,>0100                   ; Test secret door bit
       jeq  user_input_8               ; If not set we cannot move
*      Move
user_input_5:
       mov  r0,@x
       mov  r1,@y
       seto @cast_required
user_input_8:
       bl   @check_int
       .endproc
dirs:
       data >0100,>0000
       data >0100,>0100
       data >0000,>0100
       data ->0100,>0100
       data ->0100,>0000
       data ->0100,->0100
       data >0000,->0100
       data >0100,->0100
*// user_input

*********************************************************************
*
* Move enemies
*
move_enemies:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  move_enemies_3
move_enemies_1:
       mov  *r4,r0
       jeq  move_enemies_2
       mov  @object_type(r4),r0
       ci   r0,object_type_monster
       jlt  move_enemies_2
*      x
       mov  @object_x(r4),r0
       mov  @x,r2
       s    r0,r2
       mov  r2,r6
*      y
       mov  @object_y(r4),r1
       mov  @y,r3
       s    r1,r3
       mov  r3,r7
*      Check distance
       abs  r6
       abs  r7
       a    r6,r7
       ci   r7,max_object_distance*256
       jhe  move_enemies_2
*      x
       mov  r2,r2
       jeq  move_enemies_5
       jlt  move_enemies_4
       ci   r2,guard_speed
       jlt  move_enemies_5
       li   r2,guard_speed
       jmp  move_enemies_5
move_enemies_4:
       ci   r2,-guard_speed
       jgt  move_enemies_5
       li   r2,-guard_speed
move_enemies_5:
*      y
       mov  r3,r3
       jeq  move_enemies_7
       jlt  move_enemies_6
       ci   r3,guard_speed
       jlt  move_enemies_7
       li   r3,guard_speed
       jmp  move_enemies_7
move_enemies_6:
       ci   r3,-guard_speed
       jgt  move_enemies_7
       li   r3,-guard_speed
move_enemies_7:
*      Check map
       mov  r2,r6
       a    r2,r0
       a    r3,r1
       bl   @get_map_value
       jeq  move_enemies_8
       s    r6,r0
       bl   @get_map_value
       jeq  move_enemies_8
       a    r6,r0
       s    r3,r1
       bl   @get_map_value
       jne  move_enemies_2
move_enemies_8:
*      Move
       mov  r0,@object_x(r4)
       mov  r1,@object_y(r4)
*      Fire
;move_enemies_9:
;       bl   @rand
;       ci   r0,>f800
;       jl   move_enemies_2
;       seto @object_fire(r4)
;       dec  @health
;       bl   @play_shot_2
*      Next object
move_enemies_2:
       ai   r4,object_size
       dec  r5
       jne  move_enemies_1
move_enemies_3:
       bl   @check_int
       .endproc
*// move_enemies

*********************************************************************
*
* Move bullets
*
move_bullets:
       abs  @bullet_active
       jeq  move_bullets_0
       a    @bullet_vx,@bullet_x
       a    @bullet_vy,@bullet_y
       li   r0,bullet_accl_z
       a    r0,@bullet_vz
       a    @bullet_vz,@bullet_z
       a    @bullet_speed,@bullet_distance
move_bullets_0:
       rt
*// move_bullets

*********************************************************************
*
* Draw bullets
*
draw_bullets:
       .proc
       mov  @sal_no,r0                 ; Which buffer to update?
       sla  r0,7
       ai   r0,spratb+(n_fixed_sprites*4)
       bl   @vwad                      ; Set VDP address
       abs  @bullet_active
       jeq  draw_bullets_0
*      Check angle
       mov  @bullet_angle,r0
       s    @angle,r0                  ; Subtract player angle
       ci   r0,-n_rays
       jlt  draw_bullets_0
       ci   r0,n_rays
       jgt  draw_bullets_0
       ai   r0,>78                     ; Center
       mov  @bullet_distance,r1
       srl  r1,8
       movb @bullet_distance_pattern_table(r1),r1    ; Pattern
*      Draw sprite
       movb @bullet_z,*r15             ; y
       movb @r0lb,*r15                 ; x
       movb r1,*r15                    ; pattern
       movb @bullet_color_byte,*r15    ; color
*      Muzzle flash
draw_bullets_0:
       mov  @muzzle_flash,r0
       jeq  draw_bullets_1
       movb r0,*r15
       movb @r0lb,*r15
       li   r0,>600b
       movb r0,*r15
       movb @r0lb,*r15
       clr  @muzzle_flash
*      End marker
draw_bullets_1:
       movb @end_marker_byte,*r15
       bl   @check_int
       .endproc
bullet_distance_pattern_table:
       byte >30,>34,>38,>3c,>40,>40,>44,>44
       byte >48,>48,>48,>4c,>4c,>4c,>4c,>4c
       byte >4c,>4c
bullet_color_byte:
       byte bullet_color
end_marker_byte:
       byte >d0
*// draw_bullets

*********************************************************************
*
* Bullet collisions
*
bullet_collisions:
       .proc
       abs  @bullet_active
       jeq  bullet_collisions_0
*      Check distance
       mov  @bullet_distance,r0
       ci   r0,max_bullet_distance*256
       jgt  bullet_collisions_1
*      Check for wall collision
       mov  @bullet_x,r0
       mov  @bullet_y,r1
       bl   @get_map_address
       movb *r2,r3
       szcb @byte_80,r3
       jeq  bullet_collisions_2
       cb   r3,@door
       jne  bullet_collisions_1
       bl   @open_door
       seto @cast_required
       jmp  bullet_collisions_1
*      Check for object collison
bullet_collisions_2:
       li   r4,objects
       mov  @n_objects,r5
       jeq  bullet_collisions_0
bullet_collisions_3:
       mov  *r4,r2
       jeq  bullet_collisions_4
       mov  @object_type(r4),r2
       ci   r2,object_type_monster
       jlt  bullet_collisions_4
       mov  @object_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0080
       jgt  bullet_collisions_4
       mov  @object_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0080
       jgt  bullet_collisions_4
*      hit
       dec  @object_health(r4)
       jgt  bullet_collisions_3a
       bl   @remove_object
       li   r0,25
       a    r0,@score
       seto @cast_required
       jmp  bullet_collisions_1
bullet_collisions_3a:
       bl   @play_shot_2
       jmp  bullet_collisions_1
bullet_collisions_4:
       ai   r4,object_size
       dec  r5
       jne  bullet_collisions_3
       jmp  bullet_collisions_0
*      Remove bullet
bullet_collisions_1:
       clr  @bullet_active
bullet_collisions_0:
       bl   @check_int
       .endproc
*// bullet_collisions

*********************************************************************
*
* Object collisions
*
object_collisions:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  object_collisions_3
       mov  @x,r0
       mov  @y,r1
object_collisions_1:
       mov  *r4,r2
       jeq  object_collisions_2
       mov  @object_type(r4),r2
       ci   r2,object_type_monster
       jhe  object_collisions_2
       mov  @object_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0100
       jgt  object_collisions_2
       mov  @object_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0100
       jgt  object_collisions_2
       bl   @remove_object
       li   r0,100
       a    r0,@score
       bl   @play_chest
       jmp  object_collisions_3
object_collisions_2:
       ai   r4,object_size
       dec  r5
       jne  object_collisions_1
object_collisions_3:
       bl   @check_int
       .endproc
*// object_collisions

*********************************************************************
*
* Update health bar
*
update_health_bar:
       .proc
       c    @health,@old_health
       jeq  update_health_bar_4
       mov  @health,r0
       jgt  update_health_bar_0
       dec  @status
       clr  r0
update_health_bar_0:
       mov  r0,r1
       mov  r0,r2
       srl  r0,4                       ; Which sprite 0-3 to update
       sla  r0,5                       ; Sprite pattern offset
       andi r1,>0008                   ; Isolate column bit
       sla  r1,1                       ; Column offset
       a    r1,r0                      ; Add to address
       ai   r0,sprptb+(20*32)          ; Add base address
       bl   @vwad
*      Pixels within column
       li   r1,>00aa                   ; Pattern
       andi r2,>0007                   ; Number of pixels to show
       li   r0,8
       s    r2,r0                      ; Number of pixels to clear
       srl  r1,0
       sla  r1,0
       swpb r1
       li   r2,12
update_health_bar_1:
       movb r1,*r15
       movb r1,*r15
       dect r2
       jne  update_health_bar_1
*      Full columns to clear
       mov  @old_health,r2
       srl  r2,3                       ; Old column
       mov  @health,r2
       srl  r0,3                       ; New column
       s    r0,r2                      ; Column difference
       jeq  update_health_bar_3
       jlt  update_health_bar_3
       sla  r2,4                       ; columns * 16
update_health_bar_2:
       clr  *r15
       clr  *r15
       dect r2
       jne  update_health_bar_2
update_health_bar_3:
       mov  @health,@old_health
update_health_bar_4:
       .endproc
*// update_health_bar

*********************************************************************
*
* Display score
*
display_score:
       .proc
       mov  @score,r1
       c    r1,@old_score
       jeq  display_score_1
       li   r0,26+32
       li   r2,5
       bl   @display_decimal
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Display map
*
display_map:
       .proc
*      Set patterns and colors
       li   r0,ptrnt2+(12*8*8)
       clr  r1
       li   r2,64*8
       bl   @vsmw
       li   r0,colrt2+(12*8*8)
       li   r1,>f100
       li   r2,64*8
       bl   @vsmw
*      Display map
       li   r0,ptrnt2+(12*8*8)
       bl   @vwad
       li   r6,>0080                   ; A bit to set
       li   r0,map                     ; Source address
       li   r3,map_width/8             ; Column counter
*      Column loop
display_map_7:
       li   r4,map_height            ; Row counter
*      Line loop
display_map_6:
       clr  r2                         ; Result byte to write to VDP
       li   r5,8                       ; Bits in a byte
*      Bit loop
display_map_8:
       movb *r0+,r1                    ; Get map byte
       andi r1,>8000
       jeq  display_map_5              ; Don't set map bit if zero
       soc  r6,r2                      ; Set bit
display_map_5:
       sla  r2,1                       ; Shift result left to accept next bit
       dec  r5
       jne  display_map_8              ; Next bit
       movb r2,*r15                    ; Write 8 pixels to VDP
       ai   r0,map_width-8             ; Next row of map
       dec  r4
       jne  display_map_6
       ai   r0,(-map_height*map_width)+8
       dec  r3
       jne  display_map_7              ; Next column
*      Display player position
       mov  @sal_no,r0                 ; Which table to update?
       sla  r0,7
       ai   r0,spratb+(n_fixed_sprites*4)
       bl   @vwad                      ; Set VDP address
       movb @y,r0
       ab   @map_y,r0
       movb r0,*r15
       movb @x,r0
       ab   @map_x,r0
       movb r0,*r15
       li   r0,>4805
       movb r0,*r15
       movb @r0lb,*r15
*      Wait key
display_map_1:
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_1
display_map_2:
       li   r0,KEY_UP
       bl   @check_key
       jeq  display_map_2
*      Restore patterns
       li   r0,colrt2+(12*8*8)
       li   r1,>1100
       li   r2,64*8
       bl   @vsmw
       li   r0,ptrnt2+(12*8*8)
       li   r1,>f000
       li   r2,64*8
       bl   @vsmw
*      Upload screen
       seto @angle_diff
       bl   @upload_screen
       .endproc
map_x:
       byte 96-8
map_y:
       byte 64-9

*// display_map

*********************************************************************
*
* Fire bullet
*
fire_bullet:
       .proc
       mov  @x,@bullet_x
       mov  @y,@bullet_y
       li   r3,>9000
       mov  r3,@bullet_z               ; Screen y coordinate
       mov  @angle,r2
       mov  @cos_table(r2),@bullet_vx
       mov  @sin_table(r2),@bullet_vy
       li   r3,bullet_speed_z
       mov  r3,@bullet_vz
       mov  r2,@bullet_angle
       li   r3,>0100                   ; 1.0
       mov  r3,@bullet_speed
       clr  @bullet_distance
       seto @bullet_active
       bl   @play_shot_1
       .endproc
*// fire_bullet

*********************************************************************
*
* Open door
*
* r0: x FP 8.8
* r1: y FP 8.8
* r2: Map address
*
open_door:
       .proc
       movb @space,*r2
       li   r8,doors
       mov  @n_doors,r9
       jeq  open_door_3
open_door_1:
       cb   r0,@door_x(r8)
       jne  open_door_2
       cb   r1,@door_y(r8)
       jne  open_door_2
       mov  @door_object_inits(r8),r4
       mov  *r4,r5                     ; Already created?
       jne  open_door_3
       seto *r4+                       ; Mark as created
       mov  *r4+,r5                    ; Number of objects to create
       jeq  open_door_3
open_door_4:
       bl   @create_object
       ai   r4,object_init_size
       dec  r5
       jne  open_door_4
       jmp  open_door_3
open_door_2:
       ai   r8,door_size
       dec  r9
       jne  open_door_1
open_door_3:
       .endproc
*// open_door

*********************************************************************
*
* Get map value
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the map byte. r0 and r1 are preserved.
*
get_map_value:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       movb @map(r2),r2
       szcb @byte_80,r2
       rt
*// get_map_value

*********************************************************************
*
* Get map address
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the address. r0 and r1 are preserved.
*
get_map_address:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       ai   r2,map
       rt
*// get_map_address

*********************************************************************
*
* Reset objects
*
reset_objects:
       li   r5,objects
       li   r6,max_objects
reset_objects_1:
       clr  *r5
       ai   r5,object_size
       dec  r6
       jne  reset_objects_1
       rt
*// reset_objects

*********************************************************************
*
* Create object
*
* r4: Object init data
*
* On return r6 contains the address of the object, or 0 if it failed
* Uses: r2,r3,r6,r7
*
create_object:
       li   r6,objects
       clr  r7
create_object_1:
       mov  *r6,r3                     ; Object active?
       jne  create_object_2
       inc  *r6                        ; set active
       mov  @object_init_type(r4),r2
       mov  r2,@object_type(r6)
       movb @object_init_x(r4),@object_x(r6)
       movb @byte_80,@object_x+1(r6)
       movb @object_init_y(r4),@object_y(r6)
       movb @byte_80,@object_y+1(r6)
       mov  r2,r3
       sla  r3,1
       mov  @object_texture_table(r3),@object_texture(r6)
       mov  @object_speech_table(r3),@object_speech(r6)
       mov  @object_health_table(r3),@object_health(r6)
       clr  @object_fire(r6)
*      Next object
       c    r7,@n_objects
       jlt  create_object_3
       inc  @n_objects
       jmp  create_object_3
create_object_2:
       ai   r6,object_size
       inc  r7
       ci   r7,max_objects
       jlt  create_object_1
       clr  r6
create_object_3:
       rt
*// create_object

*********************************************************************
*
* Remove object
*
* r4: Address of object
*
remove_object:
       .proc
       mov  r4,r0
       ai   r0,object_size
       mov  r4,r1
       li   r2,objects+(object_size*max_objects)
       s    r4,r2
       bl   @copy
       li   r0,objects+(object_size*(max_objects-1))
       clr  *r0
       dec  @n_objects
       .endproc
*// remove_object

*********************************************************************
*
* Initialize level
*
init_level:
       .proc
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@angle
       mov  @start_dir,@old_angle
       mov  @start_dx,@dx
       mov  @start_dy,@dy
       li   r0,initial_health
       mov  r0,@health
       mov  r0,@old_health
       clr  @score
       seto @old_score
       clr  @status
       seto @cast_required
*      Init columns
       li   r0,screen_height
       li   r1,columns
       li   r2,n_rays
init_level_0:
       mov  r0,@column_height(r1)
       seto @column_color(r1)
       ai   r1,column_size
       dec  r2
       jne  init_level_0
*      Init doors
       li   r4,doors
       mov  @n_doors,r5
       jeq  init_level_1a
init_level_1:
       clr  r0
       movb @door_x(r4),r0
       clr  r1
       movb @door_y(r4),r1
       bl   @get_map_address
       movb @door,*r2
       mov  @door_object_inits,r6
       clr  *r6                        ; Mark as not completed
       ai   r4,door_size
       dec  r5
       jne  init_level_1
init_level_1a:
*      Init objects
       bl   @reset_objects
       li   r4,object_init_data
       mov  *r4+,r5
       jeq  init_level_2a
init_level_2:
       bl   @create_object
       ai   r4,object_init_size
       dec  r5
       jne  init_level_2
init_level_2a:
*      Speak
       li   r1,start_of_level
       bl   @say_phrase
*      Sprite patterns
       li   r0,sprptb+(20*32)
       li   r1,SPR20
       li   r2,4*32
       bl   @vmbw
       .endproc
*// init_level

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r0,1
       mov  r0,@one
       bl   @init_sams
       bl   @graphics_mode
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Copy textures to RAM
       li   r0,texture_bank_select
       li   r1,texture_sams_page
       li   r6,n_texture_banks
one_time_init_0:
       bl   @copy_rom_to_sams
       dec  r6
       jne  one_time_init_0
*      Init speech
       bl   @init_speech
*      Patterns
       li   r0,ptrntb
       li   r1,>f000
       li   r2,>1800
       bl   @vsmw
*      Colors
       li   r0,colrtb
       clr  r1
       li   r2,>1800
       bl   @vsmw
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r3,24
one_time_init_4:
       li   r2,32
one_time_init_5:
       movb r1,*r15
       ai   r1,>0800
       dec  r2
       jne  one_time_init_5
       ai   r1,>0100
       andi r1,>0700
       dec  r3
       jne  one_time_init_4
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,n_sprite_patterns*32
       bl   @vmbw
*      Sprite attribute tables
       li   r0,spratb
       li   r3,8
       li   r4,sal_compass
one_time_init_1:
       bl   @vwad
       li   r2,4*4
       li   r1,sal_health
one_time_init_2:
       movb *r1+,*r15
       dec  r2
       jne  one_time_init_2
       li   r2,(n_fixed_sprites-4)*4
one_time_init_3:
       movb *r4+,*r15
       dec  r2
       jne  one_time_init_3
       ai   r0,>80
       dec  r3
       jne  one_time_init_1
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; 3 color tables
       byte ptrntb/>800+>03            ; 3 pattern tables
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte backdrop_color             ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       ai   r0,nametb
       mov  r0,r4
       bl   @vwad
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       ai   r0,char_0
       swpb r0
       movb r0,*r15
       dec  r2
       jne  display_decimal_1
       ai   r1,char_0
       swpb r1
       movb r1,*r15
       .endproc
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// display_decimal

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source (even)
* r1: destination (even)
* r2: number of bytes (even)
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Arcus tangent 2 function
*
* Calculates the angle of the vector with coordinates (x,y) = (r0,r1)
* Uses r2-r3
* Result in r6 as FP 8.8
*
atan2:
       clr  r3                         ; For division
       mov  r1,r1                      ; if (y >= 0) {
       jlt  atan2_4
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_2
*      Q1
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_1
       jlt  !
       li   r6,>2000
       rt
!      mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2                      ; Result in r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       rt                              ;             result = 0x00 + a;
atan2_1:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x40 - a;
       ai   r6,>4000
       rt                              ;         }
atan2_2:                               ;     } else {
*      Q2
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_3
       jlt  !
       li   r6,>6000
       rt
!      mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x80 - a;
       ai   r6,>8000
       rt
atan2_3:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>4000                   ;                 result = 0x40 + a;
       rt                              ;         }
                                       ;     }
atan2_4:                               ; } else {
       neg  r1                         ;     y = -y;
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_6
*      Q4
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_5
       jlt  !
       li   r6,>e000
       rt
!       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x100 - a;
       rt
atan2_5:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>c000                   ;                 result = 0xc0 + a;
       rt                              ;         }
atan2_6:                               ;     } else {
*      Q3
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_7
       jlt  !
       li   r6,>a000
       rt
!
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>8000                   ;                 result = 0x80 + a;
       rt
atan2_7:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0xc0 - a;
       ai   r6,>c000
       rt                              ;         }
                                       ;     }
                                       ; }
*// atan2

*********************************************************************
*
* Euclidian distance
*
* Calculates the length of the vector with coordinates
* (x,y) = (r0,r1) in FP 8.8 format.
* Result in r7 as FP 8.8
*
euclidian_distance:
       abs  r0
       abs  r1
       ci   r0,>00ff
       jgt  euclidian_distance_1
       ci   r1,>00ff
       jgt  euclidian_distance_1
       srl  r0,4                       ; To FP 12.4
       srl  r1,4                       ; To FP 12.4
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,6                       ; To FP 8.8
       rt
euclidian_distance_1:
       ci   r0,>03ff
       jgt  euclidian_distance_2
       ci   r1,>03ff
       jgt  euclidian_distance_2
       srl  r0,6                       ; To FP 14.2
       srl  r1,6                       ; To FP 14.2
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,4                       ; To FP 8.8
       rt
euclidian_distance_2:
       srl  r0,8                       ; To FP 16.0
       srl  r1,8                       ; To FP 16.0
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,2                       ; To FP 8.8
       rt
*// euclidian_distance

*********************************************************************
*
* Program files
*
       copy "vdp.a99"
       copy "sams.a99"
       copy "speech.a99"
       copy "sound-fx-routines.a99"
;      copy "music-player.a99"
       copy "sound-player.a99"

***************************************************************
*
* Data
*
start_x:
       data >0180
start_y:
       data >0280
start_dir:
       data 0
start_dx:
       data >0100
start_dy:
       data >0000
bullet_active:
       data 0
bullet_x:
       data 0
bullet_y:
       data 0
bullet_z:
       data 0
bullet_vx:
       data 0
bullet_vy:
       data 0
bullet_vz:
       data 0
bullet_angle:
       data 0
bullet_speed:
       data 0
bullet_distance:
       data 0

**
* Constants
*
space:
       byte 0
door:
       byte 13
goal:
       byte 1
checkered:
       byte 15
byte_00:
       byte >00
byte_01:
       byte >01
byte_80:
       byte >80
byte_xx:
       byte >00

**
* Column data structure
*
column_height:
       equ  0
column_distance:
       equ  2
column_color:
       equ  4
column_distance_copy:
       equ  6
column_hit_x:
       equ  8
column_height_old:
       equ  10
column_color_old:
       equ  12
column_skip:
       equ  14
column_size:
       equ  16

**
* Column list
*
columns:
       bss  n_rays*column_size

**
* Object data structure
*
object_active:                         ; 0 = inactive, <> 0 = active,
       equ  0
object_type:
       equ  2
object_x:
       equ  4
object_y:
       equ  6
object_texture:
       equ  8
object_speech:
       equ  10
object_fire:
       equ  12
object_health:
       equ  14
object_size:
       equ  16

**
* Object list
*
n_objects:
       data 0
objects:
       bss  object_size*16

**
* Object init data structure
*
object_init_type:
       equ  0
object_init_x:
       equ  2
object_init_y:
       equ  3
object_init_size:
       equ  4

**
* Object init data
*
object_init_data:
       data 2
       data object_type_barrel
       byte >11                      ; x
       byte >02                      ; y
       data object_type_eye
       byte >02                      ; x
       byte >06                      ; y

**
* Door structure
*
door_x:
       equ  0
door_y:
       equ  1
door_object_inits:
       equ  2
door_size:
       equ  4

***************************************************************
*
* Data files
*

       copy "math_tables.a99"
       copy "sprites.a99"
       copy "sprite-patterns.a99"
       copy "sound-fx.a99"
       copy "objects.a99"
doors:
       copy "doors.a99"
col_index:
       copy "../TexGen/col-index.a99"

**
*      Screen buffer (6K)
*
*      Organised as 32 columns of 192 bytes
*      First 192 bytes for column 0, next 192 bytes for column 1 etc.
*      Each column contains 2 fat (4x1, 16 color) pixels horizontally
*      and 192 pixels vertically.

screen_buffer:
       bss  >1800

upper_ram_max:
       equ  $

***************************************************************
*
* Lower RAM
*
***************************************************************

       aorg >2000

textures:                              ; Must be at 256 byte boundary address
       bss  >1000
map:
       equ  >3000
       copy "map.a99"

lower_ram_max:
       equ  $

       end  main

