*********************************************************************
*
* Raycaster
* For the TI-99/4A home computer
*
* April 2020
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "sound-defs.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >1000                      ; Pattern table base 2
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
nametb equ  >2800                      ; Name table base 1
namet2 equ  >2c00                      ; Name table base 2
spratb equ  >2f00                      ; Sprite attribute table base 1
sprat2 equ  >2f80                      ; Sprite attribute table base 2
sprat3 equ  >3000                      ; Sprite attribute table base 3
sprat4 equ  >3080                      ; Sprite attribute table base 4
sprat5 equ  >3100                      ; Sprite attribute table base 5
sprat6 equ  >3180                      ; Sprite attribute table base 6
sprat7 equ  >3200                      ; Sprite attribute table base 7
sprat8 equ  >3280                      ; Sprite attribute table base 8

**
* Constants
*
map_width:
       equ  64
map_height:
       equ  64
screen_width:
       equ  32
screen_height:
       equ  24
n_directions:
       equ  128
angle_mask:
       equ  2*n_directions-1
n_rays:
       equ  screen_width
max_steps:
       equ  24
max_object_distance:
       equ  16
max_bullet_distance:
       equ  16
max_object_width:
       equ  8
max_objects:
       equ  16
n_tile_patterns:
       equ  256
n_sprite_patterns:
       equ  25
n_fixed_sprites:
       equ  16
guard_speed:
       equ  >0004
bullet_speed_z:
       equ  ->0c00
bullet_accl_z:
       equ  >0100
gun_color:
       equ  >01
bullet_color:
       equ  >01
backdrop_color:
       equ  >0b
char_0:
       equ  >f0

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>10                  ; Start of pad variables

**
* PAD variables
*
interrupt_count:
       equ  padvar
rand_no:
       equ  interrupt_count+2
dbl_buffer_flag:
       equ  rand_no+2
sal_no:
       equ  dbl_buffer_flag+2
sal_no_inc:
       equ  sal_no+2
health:
       equ  sal_no_inc+2
old_health:
       equ  health+2
x:                                     ; Player x FP 8.8
       equ  old_health+2
y:                                     ; Player y FP 8.8
       equ  x+2
angle:                                 ; Player direction 0 - 2 * n_directions (even only)
       equ  y+2
ray_count:
       equ  angle+2
ray_angle:
       equ  ray_count+2
distance:
       equ  ray_angle+2
depth_buffer_ptr:
       equ  distance+2
column_ptr:
       equ  depth_buffer_ptr+2
column_ptrs:
       equ  column_ptr+2
tmp:
       equ  column_ptrs+(n_rays*2)
muzzle_flash:
       equ  tmp+2
snd_channel_1:
       equ  muzzle_flash+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
module_speed:
       equ  snd_track_3+snd_track_size
get_speech_status:
       equ  module_speed+2
speech_ptr:
       equ  get_speech_status+6
speech_on:
       equ  speech_ptr+2
cast_ray_loop_pad:
       equ  speech_on+2
pad_max:
       equ  cast_ray_loop_pad+40

***************************************************************
*
* Main program
*
       aorg >2000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
       bl   @init_level
main_loop:
       clr  @interrupt_count
       bl   @vsync
       bl   @set_vdp_regs
       bl   @cast_rays
       bl   @upload_screen
       bl   @draw_objects
       bl   @user_input
       bl   @move_enemies
       bl   @move_bullets
       bl   @draw_bullets
       bl   @bullets_collisions
       bl   @object_collisions
       bl   @update_health_bar
       bl   @speak
;      bl   @display_frame_rate
       jmp  main_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12                ; Clear any pending interrupt
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       inc  @interrupt_count
       movb @vdpsta,r12
       rt
*// vsync

*********************************************************************
*
* Check for interrupt
*
check_int:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  check_int_1
       inc  @interrupt_count
       movb @vdpsta,r12
       .push r11
       bl   @snd_player
       .pop r11
check_int_1:
       rt
*// check_int

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set name table
       mov  @dbl_buffer_flag,r0
       andi r0,>0001
       ori  r0,>020a
       bl   @vwtr
*      Set sprite attribute table
       li   r0,>0500+(spratb/>80)
       a    @sal_no,r0
       bl   @vwtr
*      Flip flag
       inv  @dbl_buffer_flag
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,column_ptrs
       mov  r0,@column_ptr
       li   r0,depth_buffer
       mov  r0,@depth_buffer_ptr
       li   r2,n_rays                  ; Number of rays to cast
       mov  r2,@ray_count              ; Init count-down
       mov  @angle,r2                  ; Player direction (even only)
       ai  r2,-n_rays                  ; Direction of leftmost ray
       andi r2,angle_mask          ; Wrap around
       mov  r2,@ray_angle              ; Save
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_angle,r2              ; Direction
       bl   @cast_ray                  ; Cast ray (r2=distance, r3=side, r4=color)
       mov  r2,@distance               ; Save euclidian distance
       mov  @depth_buffer_ptr,r5
       mov  r2,*r5+
       mov  r5,@depth_buffer_ptr
       bl   @fish_eye_correction       ; Adjust distance in r2
*      Calculate which column to display
       bl   @get_column_set            ; Returns column set index in r4
       sla  r4,1                       ; To word offset
       mov  @columns_set_table(r4),r4  ; Get columns set address
       mov  r2,r5                      ; Distance
       srl  r5,5                       ; To FP 13.3
       movb @dist_column_table(r5),r5  ; Get column index
       srl  r5,8
       li   r6,screen_height           ; Column byte size
       mpy  r6,r5                      ; Column index * column size
       a    r4,r6                      ; Add to column set base
       mov  @column_ptr,r7             ; Get address of column pointer
       mov  r6,*r7+                    ; Set column pointer and increment
       mov  r7,@column_ptr             ; Save address of next column pointer
*      Next ray
       mov  @ray_angle,r2              ; Get ray direction
       inct r2                         ; Increment it
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save it
       bl   @check_int
       dec  @ray_count                 ; Count down
       jne  cast_rays_1                ; Loop if more rays to cast
       .endproc
*// cast_rays

*********************************************************************
*
* Fish-eye correction
* Calculate perpendicualar distance from euclidian distance in r2
*
fish_eye_correction:
       mov  @ray_angle,r12             ; Ray direction
       s    @angle,r12                 ; Angle offset
       andi r12,angle_mask         ; Wrap around
       mov  @cos_table(r12),r12        ; Cosine of angle (positive)
       mpy  r2,r12                     ; Multiply by distance
       movb @r12lb,r2                  ; Move result back
       movb r13,@r2lb                  ; into r2
       rt
*// fish_eye_correction

*********************************************************************
*
* Calculate column set from map color
* r4: map color
* Returns columns set index in r4
*
get_column_set:
       mov  r4,r4                      ; Color
       jeq  get_column_set_6           ; Return if no wall
       ci   r4,10
       jhe  get_column_set_1
*      Single column set
       dec  r4                         ; Color--
       a    r3,r4                      ; Different color on x/y facing walls
       jmp  get_column_set_6
*      Texture
get_column_set_1:
       mov  @ray_angle,r12             ; Ray direction
       mov  r3,r3                      ; Check side
       jne  get_column_set_3           ; Jump if y side
*      Texture x side
       mov  @sin_table(r12),r12        ; dirY
       jlt  get_column_set_2
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @y,r12                     ; playerY + sin(a)
       jmp  get_column_set_5
get_column_set_2:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @y,r12                     ; playerY + sin(a)
       jmp  get_column_set_5
*      Texture y side
get_column_set_3:
       mov  @cos_table(r12),r12        ; dirX
       jlt  get_column_set_4
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @x,r12                     ; playerY + sin(a)
       jmp  get_column_set_5
get_column_set_4:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @x,r12                     ; playerY + sin(a)
get_column_set_5:
       ai   r4,-10                     ; Texture index
       sla  r4,5                       ; * 32
       andi r12,>00f0                  ; Isolate the bits we need
       srl  r12,3                      ; Shift to word offset
       a    r12,r4                     ; Add to texture index
       mov  @textures(r4),r4           ; Get column set index
get_column_set_6:
       rt
*// get_column_set

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the side hit (0 = x-side, 1 = y-side)
* r4 contains the map entry/color
*
cast_ray:
       .proc
*      Set up variables
       mov  r0,r6                      ; Player x
       mov  r1,r8                      ; Player y
       andi r0,>ff00                   ; mapX
       andi r1,>ff00                   ; mapY
       andi r6,>00ff                   ; fracX
       andi r8,>00ff                   ; fracY
       mov  @inv_cos_table(r2),r4      ; deltaDistX
       mov  @inv_sin_table(r2),r5      ; deltaDistY
*      Calculate sideDistX
       mov  @cos_table(r2),r3          ; dirX
       jlt  cast_ray_1                 ; dirX < 0 ?
       jgt  cast_ray_2                 ; dirX > 0 ?
       clr  r6                         ; stepX
       li   r7,>7f00                   ; sideDistX (max value)
       jmp  cast_ray_3
cast_ray_1:
       mpy  r4,r6                      ; sideDistX = fracX * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,-1                      ; stepX = -1
       jmp  cast_ray_3
cast_ray_2:
       neg  r6                         ; -fracX
       ai   r6,>0100                   ; 1 - fracX
       mpy  r4,r6                      ; sideDistX = (1 - fracX) * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,1                       ; stepX = 1
*      Calculate sideDistY
cast_ray_3:
       mov  @sin_table(r2),r3          ; dirY
       jlt  cast_ray_4                 ; dirY < 0 ?
       jgt  cast_ray_5                 ; dirY < 0 ?
       clr  r8                         ; stepY
       li   r9,>7f00                   ; sideDistY (max value)
       jmp  cast_ray_6
cast_ray_4:
       mpy  r5,r8                      ; sideDistY = fracY * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,-map_width              ; stepY = -1
       jmp  cast_ray_6
cast_ray_5:
       neg  r8                         ; -fracY
       ai   r8,>0100                   ; 1 - fracY
       mpy  r5,r8                      ; sideDistY = (1 - fracY) * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,map_width               ; stepY = 1
*      Map address from coordinates
cast_ray_6:
       bl   @get_map_address
       mov  r2,r12
*      Cast the ray
       li   r2,max_steps               ; Step counter
       bl   @cast_ray_loop_pad
*      Coordinates from map address (maybe not required)
;       ai   r12,-map
;       movb @r12lb,r0
;       movb r12,r1
*      Calculate distance
       mov  r2,r2                      ; Steps left
       jne  cast_ray_7
       li   r2,max_steps*256           ; Max distance
       clr  r4                         ; Reset color
       jmp  cast_ray_10
cast_ray_7:
       mov  r3,r3                      ; xSide ?
       jne  cast_ray_8
       s    r4,r7                      ; sideDistX -= deltaDistX
       mov  r7,r2                      ; Distance
       jmp  cast_ray_9
cast_ray_8:
       s    r5,r9                      ; sideDistY -= deltaDistY
       mov  r9,r2                      ; Distance
*      Color and side
cast_ray_9:
       clr  r4                         ; Clear color
       movb r13,@r4lb                  ; Set color
cast_ray_10:
       abs  r3                         ; Side
       .endproc                        ; Return
*// cast_ray

***************************************************************
*
* Cast ray loop
*
cast_ray_loop:
       c    r7,r9                      ; sideDistX < sideDistY ?
       jgt  cast_ray_loop_1
       a    r4,r7                      ; sideDistX += deltaDistX
       a    r6,r12                     ; mapX += stepX
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_2            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_1:
       a    r5,r9                      ; sideDistY += deltaDistY
       a    r8,r12                     ; mapY += stepY
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_3            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_2:
       clr  r3                         ; xSide = 1
       rt
cast_ray_loop_3:
       seto r3                         ; xSide = -1
       rt
cast_ray_loop_end:
       equ  $
*// cast_ray_loop

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       mov  @dbl_buffer_flag,r0        ; Which buffer to update?
       andi r0,>0001
       sla  r0,10
       ai   r0,nametb
       bl   @vwad                      ; Set VDP address
       li   r3,screen_height           ; Row counter
upload_screen_loop:
       lwpi column_ptrs
       mov  r15,@tmp
       li   r15,vdpwd
       movb *r0+,*r15
       movb *r1+,*r15
       movb *r2+,*r15
       movb *r3+,*r15
       movb *r4+,*r15
       movb *r5+,*r15
       movb *r6+,*r15
       movb *r7+,*r15
       movb *r8+,*r15
       movb *r9+,*r15
       movb *r10+,*r15
       movb *r11+,*r15
       movb *r12+,*r15
       movb *r13+,*r15
       movb *r14+,*r15
       mov  @tmp,r15
       movb *r15+,@vdpwd
       lwpi column_ptrs+32
       mov  r15,@tmp
       li   r15,vdpwd
       movb *r0+,*r15
       movb *r1+,*r15
       movb *r2+,*r15
       movb *r3+,*r15
       movb *r4+,*r15
       movb *r5+,*r15
       movb *r6+,*r15
       movb *r7+,*r15
       movb *r8+,*r15
       movb *r9+,*r15
       movb *r10+,*r15
       movb *r11+,*r15
       movb *r12+,*r15
       movb *r13+,*r15
       movb *r14+,*r15
       mov  @tmp,r15
       movb *r15+,@vdpwd
       lwpi wrksp
       dec  r3
       jne  upload_screen_loop         ; Next row
       bl   @check_int
       .endproc
*// upload_screen

*********************************************************************
*
* Draw objects
*
draw_objects:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  draw_objects_3
draw_objects_1:
       mov  *r4,r0                     ; Active?
       jeq  draw_objects_2
       mov  @object_x(r4),r0
       s    @x,r0                      ; dx
       mov  @object_y(r4),r1
       s    @y,r1                      ; dy
       mov  r0,r2
       abs  r2
       mov  r1,r3
       abs  r3
       a    r2,r3                      ; Taxi distance
       ci   r3,max_object_distance*256
       jhe  draw_objects_2
*      Look up angle
       bl   @atan2
       sb   @angle+1,r6                ; Subtract player angle
       sra  r6,8                       ; Extend to 16-bit
       ci   r6,-n_rays-max_object_width
       jlt  draw_objects_2
       ci   r6,n_rays+max_object_width-1
       jgt  draw_objects_2
*      Look up distance
       bl   @euclidian_distance
       ci   r7,max_object_distance*256
       jgt  draw_objects_2
*      Object is within view and distance
       bl   @draw_object
draw_objects_2:
       ai   r4,object_size
       dec  r5
       jne  draw_objects_1
draw_objects_3:
       bl   @check_int
       .endproc
*// draw_objects

*********************************************************************
*
* Draw object
*
* r4: object to draw
* r6: angle relative to player
* r7: distance FP 8.8 (last 6 bits are zero)
*
draw_object:
       .proc
*      Find map to use
       mov  r7,r8                      ; Distance FP 8.8
       srl  r8,5                       ; To FP 14.2 + word offset
       a    @object_depth_table(r4),r8 ; Add depth table base for object
       mov  *r8,r8                     ; Map address
       jeq  draw_object_10             ; Zero means don't draw
       mov  *r8+,r1                    ; Width
       mov  *r8+,r2                    ; Height
       inct r8                         ; Skip size word
*      Screen address
       mov  @dbl_buffer_flag,r0        ; Which buffer to update?
       andi r0,>0001
       sla  r0,10                      ; x 1024
       ai   r0,nametb+(screen_width*(screen_height/2)) ; Middle screen row
       clr  r3                         ; For distance
       movb r7,@r3lb                   ; Distance integer
       sla  r3,1                       ; To word offset
       mov  @floor_offset_from_center(r3),r3            ; Floor offset from center
       s    r2,r3                      ; Minus object height
       sla  r3,5                       ; * 32
       a    r3,r0                      ; Add row offset
*      Find start column to render
       ai   r6,screen_width            ; Center screen column * 2
       s    r1,r6                      ; Leftmost screen column * 2
       mov  r6,r12                     ; Index to depth buffer
       sra  r6,1                       ; Leftmost screen column
       mov  r1,r3                      ; Column counter
       mov  r1,r13                     ; Adjusted width
draw_object_5:
       mov  r6,r6                      ; Check if out of screen
       jlt  draw_object_6              ; Jump if out of screen
       c    r7,@depth_buffer(r12)      ; Check if behind wall
       jhe  draw_object_6              ; Jump if at or behind wall
       jmp  draw_object_7              ; Column OK
draw_object_6:
       inc  r6                         ; Next column
       inct r12                        ; Next depth buffer index
       dec  r13                        ; Decrease width
       inc  r8                         ; Increase map address
       dec  r3                         ; Decrease columns left
       jne  draw_object_5              ; Loop until no more columns
       jmp  draw_object_10             ; No columns to render
draw_object_7:
       a    r6,r0                      ; Add start column to screen address
*      Find end column to render
draw_object_8:
       ci   r6,screen_width-1          ; Check if out of screen
       jgt  draw_object_9              ; Jump if out of screen
       c    r7,@depth_buffer(r12)      ; Check if behind wall
       jhe  draw_object_9              ; Jump if at or behind wall
       inc  r6                         ; Next column
       inct r12                        ; Next depth buffer index
       dec  r3                         ; Decrease columns left
       jne  draw_object_8              ; Loop until no more columns
draw_object_9:
       s    r3,r13                     ; Substract remaining columns from width
       jeq  draw_object_10             ; No columns to render
*      Draw to VDP
draw_object_1:
       bl   @vwad                      ; Set VDP address
       mov  r13,r3                     ; Column counter
draw_object_2:
       movb *r8+,r9                    ; Get map byte
       jeq  draw_object_3              ; Zero is transparent
       movb r9,*r15                    ; Write to VDP
       dec  r3                         ; Decrease colum counter
       jne  draw_object_2              ; Loop until done
       jmp  draw_object_4              ; To next row
draw_object_3:
       movb @vdprd,r9                  ; Increment VDP address
       dec  r3                         ; Decrease colum counter
       jne  draw_object_2              ; Loop until done
draw_object_4:
       a    r1,r8                      ; Add width to map address
       s    r13,r8                     ; Substract adjusted width
       ai   r0,screen_width            ; One VDP row down
       dec  r2                         ; Decrease row counter
       jne  draw_object_1              ; Loop until done
*      Speak first time
       mov  @object_speech(r4),r1
       jeq  draw_object_11
       bl   @say_phrase
       clr  @object_speech(r4)
*      Muzzle flash
draw_object_11:
       abs  @object_fire(r4)
       jeq  draw_object_10
       li   r0,>6080
       mov  r0,@muzzle_flash
       clr  @object_fire(r4)
draw_object_10:
       .endproc
*// draw_object

*********************************************************************
*
* Read user input
*
user_input:
       .proc
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       abs  @bullet_active
       jne  user_input_1
       bl   @fire_bullet
*      Left
user_input_1:
       tb   1
       jeq  user_input_2
       mov  @angle,r0
       dect r0                         ; Turn left
       dect r0                         ; Turn left
       andi r0,angle_mask
       mov  r0,@angle
       jmp  user_input_3
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       mov  @angle,r0
       inct r0                         ; Turn right
       inct r0                         ; Turn right
       andi r0,angle_mask
       mov  r0,@angle
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       mov  @angle,r2
       mov  @x,r0
       mov  @cos_table(r2),r3
       sra  r3,1
       s    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r4
       sra  r4,1
       s    r4,r1
       bl   @get_map_value
       jne  user_input_8
       neg  r3
       neg  r4
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_8
       mov  @angle,r2
       mov  @x,r0
       mov  @cos_table(r2),r3
       sra  r3,1
       a    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r4
       sra  r4,1
       a    r4,r1
       bl   @get_map_value
       jeq  user_input_5
       cb   @door,r2
       jeq  user_input_5
       jmp  user_input_8
*      Move
user_input_5:
       sra  r3,1
       sra  r4,1
       s    r3,r0
       s    r4,r1
       mov  r0,@x
       mov  r1,@y
       mov  @sal_no,r0
       mov  @sal_no_inc,r1
       jlt  user_input_6
       ci   r0,7
       jlt  user_input_7
       neg  r1
       mov  r1,@sal_no_inc
       jmp  user_input_7
user_input_6:
       ci   r0,0
       jgt  user_input_7
       neg  r1
       mov  r1,@sal_no_inc
user_input_7:
       a    r1,r0
       mov  r0,@sal_no
user_input_8:
       bl   @check_int
       .endproc
*// user_input

*********************************************************************
*
* Move enemies
*
move_enemies:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  move_enemies_3
move_enemies_1:
       mov  *r4,r0
       jeq  move_enemies_2
       mov  @object_type(r4),r0
       ci   r0,object_type_guard
       jne  move_enemies_2
*      x
       mov  @object_x(r4),r0
       mov  @x,r2
       s    r0,r2
       mov  r2,r6
*      y
       mov  @object_y(r4),r1
       mov  @y,r3
       s    r1,r3
       mov  r3,r7
*      Check distance
       abs  r6
       abs  r7
       a    r6,r7
       ci   r7,max_object_distance*256
       jhe  move_enemies_2
*      x
       mov  r2,r2
       jeq  move_enemies_5
       jlt  move_enemies_4
       ci   r2,guard_speed
       jlt  move_enemies_5
       li   r2,guard_speed
       jmp  move_enemies_5
move_enemies_4:
       ci   r2,-guard_speed
       jgt  move_enemies_5
       li   r2,-guard_speed
move_enemies_5:
*      y
       mov  r3,r3
       jeq  move_enemies_7
       jlt  move_enemies_6
       ci   r3,guard_speed
       jlt  move_enemies_7
       li   r3,guard_speed
       jmp  move_enemies_7
move_enemies_6:
       ci   r3,-guard_speed
       jgt  move_enemies_7
       li   r3,-guard_speed
move_enemies_7:
*      Check map
       a    r2,r0
       a    r3,r1
       bl   @get_map_value
       jeq  move_enemies_8
       s    r2,r0
       bl   @get_map_value
       jeq  move_enemies_8
       a    r2,r0
       s    r3,r1
       bl   @get_map_value
       jne  move_enemies_2
move_enemies_8:
*      Move
       mov  r0,@object_x(r4)
       mov  r1,@object_y(r4)
*      Shoot
move_enemies_9:
*      Fire
       bl   @rand
       ci   r0,>f800
       jl   move_enemies_2
       seto @object_fire(r4)
       dec  @health
       bl   @play_shot_2
*      Next object
move_enemies_2:
       ai   r4,object_size
       dec  r5
       jne  move_enemies_1
move_enemies_3:
       bl   @check_int
       .endproc
*// move_enemies

*********************************************************************
*
* Move bullets
*
move_bullets:
       abs  @bullet_active
       jeq  move_bullets_0
       a    @bullet_vx,@bullet_x
       a    @bullet_vy,@bullet_y
       li   r0,bullet_accl_z
       a    r0,@bullet_vz
       a    @bullet_vz,@bullet_z
       a    @bullet_speed,@bullet_distance
move_bullets_0:
       rt
*// move_bullets

*********************************************************************
*
* Draw bullets
*
draw_bullets:
       .proc
       mov  @sal_no,r0                 ; Which buffer to update?
       sla  r0,7
       ai   r0,spratb+(n_fixed_sprites*4)
       bl   @vwad                      ; Set VDP address
       abs  @bullet_active
       jeq  draw_bullets_0
*      Check angle
       mov  @bullet_angle,r0
       s    @angle,r0                  ; Subtract player angle
       ci   r0,-n_rays
       jlt  draw_bullets_0
       ci   r0,n_rays
       jgt  draw_bullets_0
       ai   r0,>78                     ; Center
       mov  @bullet_distance,r1
       srl  r1,8
       movb @bullet_distance_pattern_table(r1),r1    ; Pattern
*      Draw sprite
       movb @bullet_z,*r15             ; y
       movb @r0lb,*r15                 ; x
       movb r1,*r15                    ; pattern
       movb @bullet_color_byte,*r15    ; color
*      Muzzle flash
draw_bullets_0:
       mov  @muzzle_flash,r0
       jeq  draw_bullets_1
       movb r0,*r15
       movb @r0lb,*r15
       li   r0,>600b
       movb r0,*r15
       movb @r0lb,*r15
       clr  @muzzle_flash
*      End marker
draw_bullets_1:
       movb @end_marker_byte,*r15
       bl   @check_int
       .endproc
bullet_distance_pattern_table:
       byte >30,>34,>38,>3c,>40,>40,>44,>44
       byte >48,>48,>48,>4c,>4c,>4c,>4c,>4c
       byte >4c,>4c
bullet_color_byte:
       byte bullet_color
end_marker_byte:
       byte >d0
*// draw_bullets

*********************************************************************
*
* Bullet collisions
*
bullets_collisions:
       .proc
       abs  @bullet_active
       jeq  bullets_collisions_0
*      Check distance
       mov  @bullet_distance,r0
       ci   r0,max_bullet_distance*256
       jgt  bullets_collisions_1
*      Check for wall collision
       mov  @bullet_x,r0
       mov  @bullet_y,r1
       bl   @get_map_address
       movb *r2,r3
       jeq  bullets_collisions_2
       movb @space,*r2
       jmp  bullets_collisions_1
*      Check for enemy collison
bullets_collisions_2:
       li   r4,objects
       mov  @n_objects,r5
       jeq  bullets_collisions_0
bullets_collisions_3:
       mov  *r4,r2
       jeq  bullets_collisions_4
       mov  @object_type(r4),r2
       ci   r2,object_type_guard
       jne  bullets_collisions_4
       mov  @object_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0080
       jgt  bullets_collisions_4
       mov  @object_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0080
       jgt  bullets_collisions_4
*      hit
       bl   @remove_object
       jmp  bullets_collisions_1
bullets_collisions_4:
       ai   r4,object_size
       dec  r5
       jne  bullets_collisions_3
       jmp  bullets_collisions_0
*      Remove bullet
bullets_collisions_1:
       clr  @bullet_active
bullets_collisions_0:
       bl   @check_int
       .endproc
*// bullets_collisions

*********************************************************************
*
* Object collisions
*
object_collisions:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  object_collisions_3
       mov  @x,r0
       mov  @y,r1
object_collisions_1:
       mov  *r4,r2
       jeq  object_collisions_2
       mov  @object_type(r4),r2
       ci   r2,object_type_chest
       jne  object_collisions_2
       mov  @object_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0100
       jgt  object_collisions_2
       mov  @object_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0100
       jgt  object_collisions_2
       bl   @remove_object
       jmp  object_collisions_3
object_collisions_2:
       ai   r4,object_size
       dec  r5
       jne  object_collisions_1
object_collisions_3:
       bl   @check_int
       .endproc
*// object_collisions

*********************************************************************
*
* Display frame rate
*
display_frame_rate:
       .proc
       mov  @dbl_buffer_flag,r0        ; Which buffer to update?
       andi r0,>0001
       sla  r0,10
       ai   r0,nametb+30
       bl   @vwad                      ; Set VDP address
       mov  @interrupt_count,r2
       sla  r2,1
       ai   r2,frame_rate_from_ints
       movb *r2+,*r15
       movb *r2,*r15
       .endproc
frame_rate_from_ints:
       byte char_0+0,char_0+0
       byte char_0+6,char_0+0
       byte char_0+3,char_0+0
       byte char_0+2,char_0+0
       byte char_0+1,char_0+5
       byte char_0+1,char_0+2
       byte char_0+1,char_0+0
       byte char_0+0,char_0+9
*// display_frame_rate

*********************************************************************
*
* Fire bullet
*
fire_bullet:
       .proc
       mov  @x,@bullet_x
       mov  @y,@bullet_y
       li   r3,>9000
       mov  r3,@bullet_z               ; Screen y coordinate
       mov  @angle,r2
       mov  @cos_table(r2),@bullet_vx
       mov  @sin_table(r2),@bullet_vy
       li   r3,bullet_speed_z
       mov  r3,@bullet_vz
       mov  r2,@bullet_angle
       li   r3,>0100                   ; 1.0
       mov  r3,@bullet_speed
       clr  @bullet_distance
       seto @bullet_active
       bl   @play_shot_1
       .endproc
*// fire_bullet

*********************************************************************
*
* Get map value
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the map byte. r0 and r1 are preserved.
*
get_map_value:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       movb @map(r2),r2
       rt
*// get_map_value

*********************************************************************
*
* Get map address
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the address. r0 and r1 are preserved.
*
get_map_address:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       ai   r2,map
       rt
*// get_map_address

*********************************************************************
*
* Reset objects
*
reset_objects:
       li   r5,objects
       li   r6,max_objects
reset_objects_1:
       clr  *r5
       ai   r5,object_size
       dec  r6
       jne  reset_objects_1
       rt
*// reset_objects

*********************************************************************
*
* Create object
*
* r0: x FP 8.8
* r1: y FP 8.8
* r2: Object type
*
* On return r5 contains the address of the object, or 0 if it failed
*
create_object:
       li   r5,objects
       clr  r6
create_object_1:
       mov  *r5,r7                     ; Object active?
       jne  create_object_2
       li   r7,1
       mov  r7,*r5
       mov  r2,@object_type(r5)
       mov  r0,@object_x(r5)
       mov  r1,@object_y(r5)
       mov  r2,r7
       sla  r7,1
       mov  @object_depth_tables(r7),@object_depth_table(r5)
       mov  @object_speech_table(r7),@object_speech(r5)
       clr  @object_fire(r5)
       c    r6,@n_objects
       jlt  create_object_3
       inc  @n_objects
       jmp  create_object_3
create_object_2:
       ai   r5,object_size
       inc  r6
       ci   r6,max_objects
       jlt  create_object_1
       clr  r5
create_object_3:
       rt
*// create_object

*********************************************************************
*
* Remove object
*
* r4: Address of object
*
remove_object:
       .proc
       mov  r4,r0
       ai   r0,object_size
       mov  r4,r1
       li   r2,objects+(object_size*max_objects)
       s    r4,r2
       bl   @copy
       li   r0,objects+(object_size*(max_objects-1))
       clr  *r0
       dec  @n_objects
       .endproc
*// remove_object

*********************************************************************
*
* Update health bar
*
update_health_bar:
       .proc
       mov  @old_health,r3
       s    @health,r3
       jeq  update_health_bar_4
       mov  @health,r0
       jlt  update_health_bar_4
       mov  r0,r1
       mov  r0,r2
       srl  r0,4                       ; Which sprite 0-3 to update
       sla  r0,5                       ; Sprite pattern offset
       andi r1,>0008                   ; Isolate column bit
       sla  r1,1                       ; Column offset
       a    r1,r0                      ; Add to address
       ai   r0,sprptb+(20*32)          ; Add base address
       bl   @vwad
*      Pixels within column
       li   r1,>00aa                   ; Pattern
       andi r2,>0007                   ; Number of pixels to show
       li   r0,8
       s    r2,r0                      ; Number of pixels to clear
       srl  r1,0
       sla  r1,0
       swpb r1
       li   r2,12
update_health_bar_1:
       movb r1,*r15
       movb r1,*r15
       dect r2
       jne  update_health_bar_1
*      Full columns to clear
       srl  r3,3                       ; columns
       jeq  update_health_bar_3
       sla  r3,4                       ; columns * 16
update_health_bar_2:
       clr  *r15
       clr  *r15
       dect r3
       jne  update_health_bar_2
update_health_bar_3:
       mov  @health,@old_health
update_health_bar_4:
       .endproc
*// update_health_bar

*********************************************************************
*
* Initialize level
*
init_level:
       .proc
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@angle
       li   r0,63
       mov  r0,@health
       mov  r0,@old_health
*      Init objects
       bl   @reset_objects
       li   r3,object_init_data
       li   r4,(object_init_data_end-object_init_data)/6
init_level_1:
       mov  *r3+,r2
       mov  *r3+,r0
       mov  *r3+,r1
       bl   @create_object
       dec  r4
       jne  init_level_1
*      Speak
       li   r1,green_things_near
       bl   @say_phrase
       .endproc
object_init_data:
       data object_type_guard
       data >0c00                      ; x
       data >1900                      ; y
       data object_type_guard
       data >2500                      ; x
       data >2f00                      ; y
       data object_type_guard
       data >3400                      ; x
       data >3c00                      ; y
       data object_type_guard
       data >3900                      ; x
       data >0400                      ; y
       data object_type_guard
       data >1000                      ; x
       data >0c00                      ; y
       data object_type_guard
       data >1b00                      ; x
       data >3d00                      ; y
       data object_type_chest
       data >0e00                      ; x
       data >1100                      ; y
object_init_data_end:
       equ  $
*// init_level

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       bl   @graphics_mode
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
*      Init speech
       bl   @init_speech
*      Patterns
       li   r0,ptrntb
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>800
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
       li   r0,ptrntb+>1000
       li   r1,PAT0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Colors
       li   r0,colrtb
       li   r1,COL0
       li   r2,n_tile_patterns*8
       bl   @vmbw
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,n_sprite_patterns*32
       bl   @vmbw
*      Sprite attribute tables
       li   r0,spratb
       li   r3,8
       li   r4,>ff00
one_time_init_1:
       bl   @vwad
       li   r2,n_fixed_sprites
       li   r1,sal
one_time_init_2:
       movb *r1+,r5
       ci   r2,n_fixed_sprites-4
       jgt  one_time_init_3
       ab   r4,r5
one_time_init_3:
       movb r5,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r2
       jne  one_time_init_2
       ai   r0,>80
       ai   r4,>0100
       dec  r3
       jne  one_time_init_1
       inc  @sal_no_inc
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte backdrop_color             ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       b    *r11
*// rand

*********************************************************************
*
* Arcus tangent 2 function
*
* Calculates the angle of the vector with coordinates (x,y) = (r0,r1)
* Uses r2-r3
* Result in r6 as FP 8.8
*
atan2:
       clr  r3                         ; For division
       mov  r1,r1                      ; if (y >= 0) {
       jlt  atan2_4
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_2
*      Q1
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_1
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2                      ; Result in r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       rt                              ;             result = 0x00 + a;
atan2_1:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x40 - a;
       ai   r6,>4000
       rt                              ;         }
atan2_2:                               ;     } else {
*      Q2
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_3
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x80 - a;
       ai   r6,>8000
       rt
atan2_3:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>4000                   ;                 result = 0x40 + a;
       rt                              ;         }
                                       ;     }
atan2_4:                               ; } else {
       neg  r1                         ;     y = -y;
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_6
*      Q4
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_5
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x100 - a;
       rt
atan2_5:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>c000                   ;                 result = 0xc0 + a;
       rt                              ;         }
atan2_6:                               ;     } else {
*      Q3
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_7
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>8000                   ;                 result = 0x80 + a;
       rt
atan2_7:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0xc0 - a;
       ai   r6,>c000
       rt                              ;         }
                                       ;     }
                                       ; }
*// atan2

*********************************************************************
*
* Euclidian distance
*
* Calculates the length of the vector with coordinates (x,y) = (r0,r1)
* Result in r7 as FP 8.8
*
euclidian_distance:
       abs  r0
       ai   r0,>0080                   ; x += 0.5
       srl  r0,8                       ; round(x)
       abs  r1
       ai   r1,>0080                   ; y += 0.5
       srl  r1,8                       ; round(y)
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; +x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,2                       ; To FP 8.8
       rt
*// euclidian_distance

*********************************************************************
*
* Program files
*
       copy "vdp.a99"
       copy "speech.a99"
       copy "sound-fx-routines.a99"
;      copy "music-player.a99"
       copy "sound-player.a99"

***************************************************************
*
* Data
*
start_x:
       data >2000
start_y:
       data >2000
start_dir:
       data >c0
space:
       byte 0
door:
       byte 10
byte_00:
       byte 00
byte_01:
       byte 01

depth_buffer:
       bss  n_rays*2

**
* Objects
*
object_active:                         ; 0 = inactive, <> 0 = active,
       equ  0
object_type:
       equ  2
object_x:
       equ  4
object_y:
       equ  6
object_depth_table:
       equ  8
object_speech:
       equ  10
object_fire:
       equ  12
object_size:
       equ  14

object_type_guard:
       equ  1
object_type_chest:
       equ  2

n_objects:
       data 0
objects:
       bss  object_size*16

object_depth_tables:
       data 0
       data guard_depth_table
       data chest_depth_table
object_speech_table:
       data 0
       data hand_up
       data come_and_get_me

bullet_active:
       data 0
bullet_x:
       data 0
bullet_y:
       data 0
bullet_z:
       data 0
bullet_vx:
       data 0
bullet_vy:
       data 0
bullet_vz:
       data 0
bullet_angle:
       data 0
bullet_speed:
       data 0
bullet_distance:
       data 0

**
* This table lists, for each distance
* 1 <= d < 24 step 0.125
* the index of one of the 23 pre-drawn
* columns to use.
* 23*8 = 192 entries (+1)
*
dist_column_table:
       byte 00,00,00,00,00,00,00,00
       byte 00,01,02,03,04,05,06,07
       byte 08,09,10,11,12,13,14,14
       byte 15,16,16,17,17,18,18,19
       byte 19,19,20,20,20,21,21,21
       byte 21,22,22,22,22,22,23,23
       byte 23,23,23,23,24,24,24,24
       byte 24,24,24,24,25,25,25,25
       byte 25,25,25,25,25,25,26,26
       byte 26,26,26,26,26,26,26,26
       byte 26,26,26,26,26,26,27,27
       byte 27,27,27,27,27,27,27,27
       byte 27,27,27,27,27,27,27,27
       byte 27,27,27,27,27,27,28,28
       byte 28,28,28,28,28,28,28,28
       byte 28,28,28,28,28,28,28,28
       byte 28,28,28,28,28,28,28,28
       byte 28,28,28,28,28,28,28,28
       byte 28,28,28,28,28,28,28,28
       byte 28,28,29,29,29,29,29,29
       byte 29,29,29,29,29,29,29,29
       byte 29,29,29,29,29,29,29,29
       byte 29,29,29,29,29,29,29,29
       byte 29,29,29,29,29,29,29,29
       byte 30,30,30,30,30,30,30,30    ; This row should actually be 29
       byte 31,00                      ; Used when max steps are reached

**
* These are the heights of the pre-drawn colums,
* but the numbers are not used for anything here.
*
*      24.0,21.5,19.0,17.5,16.0,15.0,13.5,13.0
*      12.0,11.5,10.5,10.0,9.5,9.0,8.5,8.0
*      7.5,7.0,6.5,6.0,5.5,5.0,4.5,4.0
*      3.5,3.0,2.5,2.0,1.5,1.0,0.5,0.0

**
* Addresses of the different column sets,
* each with a different color or texture.
*
columns_set_table:
       data MD1,MD2,MD3,MD4,MD5,MD6,MD7,MD8
       data MD9,MD10,MD11,MD12

**
* Floor offset from vertical center of screen at different distances
*
floor_offset_from_center:
* Rounded to nearest
       data 12                         ; 12/0 = Inf
       data 12                         ; 12/1 = 12
       data 6                          ; 12/2 = 6
       data 4                          ; 12/3 = 4
       data 3                          ; 12/4 = 3
       data 2                          ; 12/5 = 2.4
       data 2                          ; 12/6 = 2
       data 2                          ; 12/7 = 1.7
       data 2                          ; 12/8 = 1.5
       data 1                          ; 12/9 = 1.3
       data 1                          ; 12/10 = 1.2
       data 1                          ; 12/11 = 1.1
       data 1                          ; 12/12 = 1
       data 1                          ; 12/13 = 0.9
       data 1                          ; 12/14 = 0.9
       data 1                          ; 12/15 = 0.8
       data 1                          ; 12/16 = 0.8

***************************************************************
*
* Data files
*
       copy "math_tables.a99"
       copy "textures.a99"
       copy "objects.a99"
       copy "sprites.a99"
       copy "sound-fx.a99"

lower_ram_max:
       equ  $
**
*      Upper RAM
*
       aorg >a000

       copy "graphics.a99"
map:
       equ  MD0

upper_ram_max:
       equ  $

       end  main

