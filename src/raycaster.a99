*********************************************************************
*
* Raycaster
* For the TI-99/4A home computer
*
* April 2020
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "sound-defs.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >0800                      ; Pattern table base 2
ptrnt3 equ  >1000                      ; Pattern table base 3
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
colrt2 equ  >2800                      ; Color table base 2
colrt3 equ  >3000                      ; Color table base 3
nametb equ  >3800                      ; Name table base
spratb equ  >3c00                      ; Sprite attribute table base 1
sprat2 equ  >3c80                      ; Sprite attribute table base 2
sprat3 equ  >3d00                      ; Sprite attribute table base 3
sprat4 equ  >3d80                      ; Sprite attribute table base 4
sprat5 equ  >3e00                      ; Sprite attribute table base 5
sprat6 equ  >3e80                      ; Sprite attribute table base 6
sprat7 equ  >3f00                      ; Sprite attribute table base 7
sprat8 equ  >3f80                      ; Sprite attribute table base 8

**
* Constants
*
map_width:
       equ  64
map_height:
       equ  64
screen_width:
       equ  64
screen_height:
       equ  192
n_directions:
       equ  256
angle_mask:
       equ  2*n_directions-1
n_rays:
       equ  screen_width
max_steps:
       equ  24
max_object_distance:
       equ  16
max_bullet_distance:
       equ  16
max_object_width:
       equ  8
max_objects:
       equ  16
n_sprite_patterns:
       equ  25
n_fixed_sprites:
       equ  16
guard_speed:
       equ  >0008
bullet_speed_z:
       equ  ->0c00
bullet_accl_z:
       equ  >0100
gun_color:
       equ  >01
bullet_color:
       equ  >01
backdrop_color:
       equ  >0b
char_0:
       equ  >30
first_texture_index:
       equ  10
initial_objects:
       equ  5
initial_health:
       equ  63
texture_bank_select:
       equ  >6008
texture_width:                         ; Width in fat pixels
       equ  16
texture_height:
       equ  64
texture_size:
       equ  (texture_width/2)*texture_height;

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
one:
       equ  padcon
**
* PAD variables
*
padvar:
       equ  one+2                      ; Start of pad variables
interrupt_count:
       equ  padvar
rand_no:
       equ  interrupt_count+2
sal_no:
       equ  rand_no+2
sal_no_inc:
       equ  sal_no+2
score:
       equ  sal_no_inc+2
old_score:
       equ  score+2
health:
       equ  old_score+2
old_health:
       equ  health+2
status:
       equ  old_health+2
x:                                     ; Player x FP 8.8
       equ  status+2
y:                                     ; Player y FP 8.8
       equ  x+2
angle:                                 ; Player direction 0 - 2 * n_directions (even only)
       equ  y+2
update_screen:
       equ  angle+2
ray_count:
       equ  update_screen+2
ray_angle:
       equ  ray_count+2
distance:
       equ  ray_angle+2
depth_buffer_ptr:
       equ  distance+2
column_ptr:
       equ  depth_buffer_ptr+2
muzzle_flash:
       equ  column_ptr+2
snd_channel_1:
       equ  muzzle_flash+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
module_speed:
       equ  snd_track_3+snd_track_size
get_speech_status:
       equ  module_speed+2
speech_ptr:
       equ  get_speech_status+6
speech_on:
       equ  speech_ptr+2
cast_ray_loop_pad:
       equ  speech_on+2
upload_screen_loop_pad:
       equ  cast_ray_loop_pad+40
pad_max:
       equ  upload_screen_loop_pad+22

***************************************************************
*
* Main program
*
       aorg >2000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
restart:
       bl   @init_level
main_loop:
       clr  @interrupt_count
       bl   @vsync
       bl   @set_vdp_regs
       abs  @update_screen
       jeq  no_screen_update
       bl   @cast_rays
       bl   @draw_screen
;       bl   @draw_objects
       bl   @upload_screen
       clr  @update_screen
       jmp   after_screen_update
no_screen_update:
       bl   @vsync
       bl   @vsync
after_screen_update:
       bl   @user_input
;       bl   @move_enemies
       bl   @move_bullets
       bl   @draw_bullets
       bl   @bullet_collisions
;       bl   @object_collisions
;       bl   @update_health_bar
;       bl   @display_score
       bl   @speak
       mov  @status,r0
       jeq  main_loop
       jgt  finish
       bl   @play_die
       jmp  pause
finish:
       bl   @play_finish
pause:
       li   r14,120
pause_loop:
       bl   @vsync
       dec  r14
       jne  pause_loop
pause_loop_1:
       bl   @vsync
       li   r0,KEY_FI
       bl   @check_key
       jeq  pause_loop_1
       jmp  restart

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12                ; Clear any pending interrupt
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       inc  @interrupt_count
       movb @vdpsta,r12
       .push r11
       bl   @snd_player
       .pop r11
       rt
*// vsync

*********************************************************************
*
* Check for interrupt
*
check_int:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  check_int_1
       inc  @interrupt_count
       movb @vdpsta,r12
       .push r11
       bl   @snd_player
       .pop r11
check_int_1:
       rt
*// check_int

***************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Set sprite attribute table
       li   r0,>0500+(spratb/>80)
       a    @sal_no,r0
       bl   @vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,columns
       mov  r0,@column_ptr
       li   r0,depth_buffer
       mov  r0,@depth_buffer_ptr
       li   r2,n_rays                  ; Number of rays to cast
       mov  r2,@ray_count              ; Init count-down
       mov  @angle,r2                  ; Player direction (even only)
       ai  r2,-n_rays                  ; Direction of leftmost ray
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_angle,r2              ; Direction
       bl   @cast_ray                  ; Cast ray (r2=distance, r3=side, r4=color)
       mov  r2,@distance               ; Save euclidian distance
       mov  @depth_buffer_ptr,r5
       mov  r2,*r5+
       mov  r5,@depth_buffer_ptr
       bl   @fish_eye_correction       ; Adjust distance in r2
*      Calculate height and color of column
       mov  @column_ptr,r5
       mov  r2,r0                      ; Distance as FP 8.8
       jne  cast_rays_2
       li   r0,8*192                   ; Max height
       jmp  cast_rays_3
cast_rays_2:
       clr  r0
       li   r1,screen_height*256       ; 192 as FP 24.8
       div  r2,r0                      ; height = 192 / distance as FP 16.0
cast_rays_3:
       andi r0,>fffe                   ; Make height even
       mov  r0,@column_height(r5)
       mov  r3,@column_side(r5)
       bl   @wall_color
       ai   r5,column_size
       mov  r5,@column_ptr
*      Next ray
       mov  @ray_angle,r2              ; Get ray direction
       inct r2                         ; Increment it
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save it
       bl   @check_int
       dec  @ray_count                 ; Count down
       jne  cast_rays_1                ; Loop if more rays to cast
       .endproc
*// cast_rays

*********************************************************************
*
* Fish-eye correction
* Calculate perpendicualar distance from euclidian distance in r2
*
fish_eye_correction:
       mov  @ray_angle,r12             ; Ray direction
       s    @angle,r12                 ; Angle offset
       andi r12,angle_mask             ; Wrap around
       mov  @cos_table(r12),r12        ; Cosine of angle (positive)
       mpy  r2,r12                     ; Multiply by distance
       movb @r12lb,r2                  ; Move result back
       movb r13,@r2lb                  ; into r2
       rt
*// fish_eye_correction

*********************************************************************
*
* Calculate wall color from map color
*
* r3: 0 = x face, 1 = y face
* r4: map color
* r5: column to update
*
* Updates column.column_color and column.column_hit_x.
* If no texture column.column_hit_x is set to -1.
*
wall_color:
       mov  r4,r4                      ; Color
       jne  wall_color_0               ; Jump if wall
       li   r4,15                      ; No wall color
       jmp  wall_color_6               ; Return
wall_color_0:
       ci   r4,first_texture_index     ; Check for texture
       jhe  wall_color_1               ; Jump if texture
*      Single color
       andi r4,>fffe                   ; Clear secret door bit
       dect r4                         ; Shift to zero base
       a    r3,r4                      ; Different color on x/y facing walls
       sla  r4,1
       mov  @wall_colors(r4),r4
       seto @column_hit_x(r5)
       jmp  wall_color_6               ; Return
*      Texture
wall_color_1:
       mov  @ray_angle,r12             ; Ray direction
       mov  r3,r3                      ; Check side
       jne  wall_color_3               ; Jump if y side
*      Texture x side
       mov  @sin_table(r12),r12        ; dirY
       jlt  wall_color_2
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @y,r12                     ; playerY + sin(a)
       jmp  wall_color_5
wall_color_2:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @y,r12                     ; playerY + sin(a)
       jmp  wall_color_5
*      Texture y side
wall_color_3:
       mov  @cos_table(r12),r12        ; dirX
       jlt  wall_color_4
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       a    @x,r12                     ; playerY + sin(a)
       jmp  wall_color_5
wall_color_4:
       neg  r12
       mpy  @distance,r12              ; Multiply by distance
       swpb r12                        ; Rearrange result
       movb r13,@r12lb                 ; as FP 8.8
       neg  r12
       a    @x,r12                     ; playerY + sin(a)
wall_color_5:
       ai   r4,-first_texture_index    ; Texture index
       andi r12,>00ff
       mov  r12,@column_hit_x(r5)
wall_color_6:
       mov  r4,@column_color(r5)
       rt
wall_colors:
       data 14,15
       data 6,9
       data 12,3
       data 4,5
*// wall_color

***************************************************************
*
* r0: x position to cast from (FP 8.8)
* r1: y position to cast from (FP 8.8)
* r2: Direction index of ray to cast
*
* On return r0,r1 contains the map coordinates
* r2 contains the distance, or -1 if no hit
* r3 contains the side hit (0 = x-side, 1 = y-side)
* r4 contains the map entry/color
*
cast_ray:
       .proc
*      Set up variables
       mov  r0,r6                      ; Player x
       mov  r1,r8                      ; Player y
       andi r0,>ff00                   ; mapX
       andi r1,>ff00                   ; mapY
       andi r6,>00ff                   ; fracX
       andi r8,>00ff                   ; fracY
       mov  @inv_cos_table(r2),r4      ; deltaDistX
       mov  @inv_sin_table(r2),r5      ; deltaDistY
*      Calculate sideDistX
       mov  @cos_table(r2),r3          ; dirX
       jlt  cast_ray_1                 ; dirX < 0 ?
       jgt  cast_ray_2                 ; dirX > 0 ?
       clr  r6                         ; stepX
       li   r7,>7f00                   ; sideDistX (max value)
       jmp  cast_ray_3
cast_ray_1:
       mpy  r4,r6                      ; sideDistX = fracX * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,-1                      ; stepX = -1
       jmp  cast_ray_3
cast_ray_2:
       neg  r6                         ; -fracX
       ai   r6,>0100                   ; 1 - fracX
       mpy  r4,r6                      ; sideDistX = (1 - fracX) * deltaDistX
       swpb r7                         ; Fractional part to LSB
       movb @r6lb,r7                   ; Integer part to MSB
       li   r6,1                       ; stepX = 1
*      Calculate sideDistY
cast_ray_3:
       mov  @sin_table(r2),r3          ; dirY
       jlt  cast_ray_4                 ; dirY < 0 ?
       jgt  cast_ray_5                 ; dirY < 0 ?
       clr  r8                         ; stepY
       li   r9,>7f00                   ; sideDistY (max value)
       jmp  cast_ray_6
cast_ray_4:
       mpy  r5,r8                      ; sideDistY = fracY * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,-map_width              ; stepY = -1
       jmp  cast_ray_6
cast_ray_5:
       neg  r8                         ; -fracY
       ai   r8,>0100                   ; 1 - fracY
       mpy  r5,r8                      ; sideDistY = (1 - fracY) * deltaDistY
       swpb r9                         ; Fractional part to LSB
       movb @r8lb,r9                   ; Integer part to MSB
       li   r8,map_width               ; stepY = 1
*      Map address from coordinates
cast_ray_6:
       bl   @get_map_address
       mov  r2,r12
*      Cast the ray
       li   r2,max_steps               ; Step counter
       bl   @cast_ray_loop_pad
*      Coordinates from map address (maybe not required)
;       ai   r12,-map
;       movb @r12lb,r0
;       movb r12,r1
*      Calculate distance
       mov  r2,r2                      ; Steps left
       jne  cast_ray_7
       li   r2,max_steps*256           ; Max distance
       clr  r4                         ; Reset color
       jmp  cast_ray_10
cast_ray_7:
       mov  r3,r3                      ; xSide ?
       jne  cast_ray_8
       s    r4,r7                      ; sideDistX -= deltaDistX
       mov  r7,r2                      ; Distance
       jmp  cast_ray_9
cast_ray_8:
       s    r5,r9                      ; sideDistY -= deltaDistY
       mov  r9,r2                      ; Distance
*      Color and side
cast_ray_9:
       clr  r4                         ; Clear color
       movb r13,@r4lb                  ; Set color
cast_ray_10:
       abs  r3                         ; Side
       .endproc                        ; Return
*// cast_ray

***************************************************************
*
* Cast ray loop
*
cast_ray_loop:
       c    r7,r9                      ; sideDistX < sideDistY ?
       jgt  cast_ray_loop_1
       a    r4,r7                      ; sideDistX += deltaDistX
       a    r6,r12                     ; mapX += stepX
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_2            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_1:
       a    r5,r9                      ; sideDistY += deltaDistY
       a    r8,r12                     ; mapY += stepY
       movb *r12,r13                   ; Check map
       jne  cast_ray_loop_3            ; Exit if not empty
       dec  r2                         ; Distance count down
       jne  cast_ray_loop              ; Loop until we give up
       rt
cast_ray_loop_2:
       clr  r3                         ; xSide = 1
       rt
cast_ray_loop_3:
       seto r3                         ; xSide = -1
       rt
cast_ray_loop_end:
       equ  $
*// cast_ray_loop

*********************************************************************
*
* Draw screen
*
draw_screen:
       .proc
       li   r3,screen_buffer
       li   r4,columns
       clr  r5
draw_screen_1:
       mov  r5,r0
       andi r0,1
       jne  draw_screen_2
       bl   @draw_even_column
       ai   r3,-screen_height
       jmp  draw_screen_3
draw_screen_2:
       bl   @draw_odd_column
draw_screen_3:
       ai   r4,column_size
       inc  r5
       ci   r5,n_rays
       jlt  draw_screen_1
       bl   @check_int
       .endproc
*// draw_screen

*********************************************************************
*
* Draw even column
*
* r3: Screen buffer
* r4: Column structure
* r5: Column number
*
draw_even_column:
       .proc
       mov  @column_height(r4),r6      ; Wall height
       ci   r6,screen_height
       jle  draw_even_column_1
draw_even_column_0:
       li   r6,screen_height
draw_even_column_1:
*      Sky
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       srl  r2,1                       ; Div 2
       mov  r2,r7                      ; Save height of sky
       jeq  draw_even_column_3
       li   r1,>7070                   ; Color of sky
       bl   @draw_even_pixels
*      Wall
draw_even_column_3:
       mov  r6,r2                      ; Wall height
       jeq  draw_even_column_5         ; Jump if zero
       mov  @column_color(r4),r1       ; Color / texture number
       mov  @column_hit_x(r4),r0       ; Check for texture
       jlt  draw_even_column_8         ; No texture if -1
*      Wall textured
       bl   @prepare_texture           ; Calculate texture address and y-step
       ai   r0,even_col_vector_0
*      Cartridge bank
       mov  *r0+,r2
       seto *r2
*      Draw routine address
       mov  *r0,r2
       bl   *r2
       jmp  draw_even_column_5
draw_even_column_8:
*      Wall single color
       sla  r1,4
       movb @r1lb,r1
       bl   @draw_even_pixels
*      Floor
draw_even_column_5:
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       s    r7,r2                      ; Minus sky height
       jeq  draw_even_column_7
       li   r1,>a0a0                   ; Color of floor
       bl   @draw_even_pixels
draw_even_column_7:
       .endproc
*// draw_even_column

*********************************************************************
*
* Draw a column of identical pixels (even)
*
* r1: Color in upper nybble of MSB and LSB
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
*
draw_even_pixels:
       coc  @one,r3
       jne  draw_even_pixels_0
       movb r1,*r3+
       dec  r2
       jeq  draw_even_pixels_4
draw_even_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_even_pixels_2
draw_even_pixels_1:
       mov  r1,*r3+
       mov  r1,*r3+
       mov  r1,*r3+
       mov  r1,*r3+
       dec  r2
       jne  draw_even_pixels_1
draw_even_pixels_2:
       andi r0,7
       jeq  draw_even_pixels_4
draw_even_pixels_3:
       movb r1,*r3+
       dec  r0
       jne  draw_even_pixels_3
draw_even_pixels_4:
       rt
*// draw_even_pixels

*********************************************************************
*
* Draw odd column
*
* r3: Screen buffer
* r4: Column structure
* r5: Column number
*
draw_odd_column:
       .proc
       mov  @column_height(r4),r6      ; Wall height
       ci   r6,screen_height
       jle  draw_odd_column_1
draw_odd_column_0:
       li   r6,screen_height
draw_odd_column_1:
*      Sky
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       srl  r2,1                       ; Div 2
       mov  r2,r7                      ; Save height of sky
       jeq  draw_odd_column_3
       li   r1,>0707                   ; Color of sky
       bl   @draw_odd_pixels
*      Wall
draw_odd_column_3:
       mov  r6,r2                      ; Wall height
       jeq  draw_odd_column_5          ; Jump if zero
       mov  @column_color(r4),r1       ; Color / texture number
       mov  @column_hit_x(r4),r0       ; Check for texture
       jlt  draw_odd_column_8          ; No texture if -1
*      Wall textured
       bl   @prepare_texture           ; Calculate texture address and y-step
       ai   r1,1024                    ; Add offset to odd column texture
       ai   r0,odd_col_vector_0
*      Cartridge bank
       mov  *r0+,r2
       seto *r2
*      Draw routine address
       mov  *r0,r2
       bl   *r2
       jmp  draw_odd_column_5
draw_odd_column_8:
*      Wall single color
       movb @r1lb,r1
       bl   @draw_odd_pixels
*      Floor
draw_odd_column_5:
       li   r2,screen_height           ; Screen height
       s    r6,r2                      ; Minus wall height
       s    r7,r2                      ; Minus sky height
       jeq  draw_odd_column_7
       li   r1,>0a0a
       bl   @draw_odd_pixels
draw_odd_column_7:
       .endproc
*// draw_odd_column

*********************************************************************
*
* Draw a column of identical pixels (odd)
*
* r1: Color in lower nybble of MSB and LSB
* r2: Number of pixels to draw (not zero)
* r3: Screen buffer address
*
draw_odd_pixels:
       coc  @one,r3
       jne  draw_odd_pixels_0
       socb r1,*r3+
       dec  r2
       jeq  draw_odd_pixels_4
draw_odd_pixels_0:
       mov  r2,r0
       srl  r2,3
       jeq  draw_odd_pixels_2
draw_odd_pixels_1:
       soc  r1,*r3+
       soc  r1,*r3+
       soc  r1,*r3+
       soc  r1,*r3+
       dec  r2
       jne  draw_odd_pixels_1
draw_odd_pixels_2:
       andi r0,7
       jeq  draw_odd_pixels_4
draw_odd_pixels_3:
       socb r1,*r3+
       dec  r0
       jne  draw_odd_pixels_3
draw_odd_pixels_4:
       rt
*// draw_odd_pixels

*********************************************************************
*
* Calculate texture address and y-step
*
* r0: Texture hit x (FP 8.8)
* r1: Texture number
* r2: Screen height of wall
* r4: Column structure
*
* On return r0 contains the address of the routine to draw the column,
* and r1 contains the texture source address,

prepare_texture:
*      Texture address
       srl  r0,4                       ; Column of texture
       sla  r0,6                       ; * 64
       andi r1,3                       ; 4 textures per bank
       sla  r1,11                      ; texture number * 2048
       ai   r1,textures                ; Base texture source address
       a    r0,r1                      ; Base texture column source address
*      Column drawing vector offset
       mov  @column_height(r4),r0
       ci   r0,screen_height
       jh   prepare_texture_1
;      srl  r0,1                       ; / 2
;      sla  r0,2                       ; * 4
       sla  r0,1                       ; * 2
       jmp  prepare_texture_3
prepare_texture_1:
       ci   r0,512
       jle   prepare_texture_2
       li   r0,512
prepare_texture_2:
       ai   r0,-192
       srl  r0,3                       ; / 8
       sla  r0,2                       ; * 4
       ai   r0,192*2
prepare_texture_3:
       rt
*// prepare_texture

*********************************************************************
*
* Draw objects
*
draw_objects:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  draw_objects_3
draw_objects_1:
       mov  *r4,r0                     ; Active?
       jeq  draw_objects_2
       mov  @object_x(r4),r0
       s    @x,r0                      ; dx
       mov  @object_y(r4),r1
       s    @y,r1                      ; dy
       mov  r0,r2
       abs  r2
       mov  r1,r3
       abs  r3
       a    r2,r3                      ; Taxi distance
       ci   r3,max_object_distance*256
       jhe  draw_objects_2
*      Look up angle
       bl   @atan2
       sb   @angle+1,r6                ; Subtract player angle
       sra  r6,8                       ; Extend to 16-bit
       ci   r6,-n_rays-max_object_width
       jlt  draw_objects_2
       ci   r6,n_rays+max_object_width-1
       jgt  draw_objects_2
*      Look up distance
       bl   @euclidian_distance
       ci   r7,max_object_distance*256
       jgt  draw_objects_2
*      Object is within view and distance
       bl   @draw_object
draw_objects_2:
       ai   r4,object_size
       dec  r5
       jne  draw_objects_1
draw_objects_3:
       bl   @check_int
       .endproc
*// draw_objects

*********************************************************************
*
* Draw object
*
* r4: object to draw
* r6: angle relative to player (2 units per column)
* r7: distance FP 8.8 (last 6 bits are zero)
*
draw_object:
       .proc
;*      Find map to use
;       mov  r7,r8                      ; Distance FP 8.8
;       srl  r8,5                       ; To FP 14.2 + word offset
;       a    @object_depth_table(r4),r8 ; Add depth table base for object
;       mov  *r8,r8                     ; Map address
;       jeq  draw_object_10             ; Zero means don't draw
;       mov  *r8+,r1                    ; Width
;       mov  *r8+,r2                    ; Height
;       inct r8                         ; Skip size word
;*      Screen address
;       mov  @dbl_buffer_flag,r0        ; Which buffer to update?
;       andi r0,>0001
;       sla  r0,10                      ; x 1024
;       ai   r0,nametb+(screen_width*(screen_height/2)) ; Middle screen row
;       clr  r3                         ; For distance
;       movb r7,@r3lb                   ; Distance integer
;       sla  r3,1                       ; To word offset
;       mov  @floor_offset_from_center(r3),r3            ; Floor offset from center
;       s    r2,r3                      ; Minus object height
;       sla  r3,5                       ; * 32
;       a    r3,r0                      ; Add row offset
;*      Find start column to render
;       ai   r6,screen_width            ; Center screen column * 2
;       s    r1,r6                      ; Leftmost screen column * 2
;       mov  r6,r12                     ; Index to depth buffer
;       sra  r6,1                       ; Leftmost screen column
;       mov  r1,r3                      ; Column counter
;       mov  r1,r13                     ; Adjusted width
;draw_object_5:
;       mov  r6,r6                      ; Check if out of screen
;       jlt  draw_object_6              ; Jump if out of screen
;       c    r7,@depth_buffer(r12)      ; Check if behind wall
;       jhe  draw_object_6              ; Jump if at or behind wall
;       jmp  draw_object_7              ; Column OK
;draw_object_6:
;       inc  r6                         ; Next column
;       inct r12                        ; Next depth buffer index
;       dec  r13                        ; Decrease width
;       inc  r8                         ; Increase map address
;       dec  r3                         ; Decrease columns left
;       jne  draw_object_5              ; Loop until no more columns
;       jmp  draw_object_10             ; No columns to render
;draw_object_7:
;       a    r6,r0                      ; Add start column to screen address
;*      Find end column to render
;draw_object_8:
;       ci   r6,screen_width-1          ; Check if out of screen
;       jgt  draw_object_9              ; Jump if out of screen
;       c    r7,@depth_buffer(r12)      ; Check if behind wall
;       jhe  draw_object_9              ; Jump if at or behind wall
;       inc  r6                         ; Next column
;       inct r12                        ; Next depth buffer index
;       dec  r3                         ; Decrease columns left
;       jne  draw_object_8              ; Loop until no more columns
;draw_object_9:
;       s    r3,r13                     ; Substract remaining columns from width
;       jeq  draw_object_10             ; No columns to render
;*      Draw to VDP
;draw_object_1:
;       bl   @vwad                      ; Set VDP address
;       mov  r13,r3                     ; Column counter
;draw_object_2:
;       movb *r8+,r9                    ; Get map byte
;       jeq  draw_object_3              ; Zero is transparent
;       movb r9,*r15                    ; Write to VDP
;       dec  r3                         ; Decrease colum counter
;       jne  draw_object_2              ; Loop until done
;       jmp  draw_object_4              ; To next row
;draw_object_3:
;       movb @vdprd,r9                  ; Increment VDP address
;       dec  r3                         ; Decrease colum counter
;       jne  draw_object_2              ; Loop until done
;draw_object_4:
;       a    r1,r8                      ; Add width to map address
;       s    r13,r8                     ; Substract adjusted width
;       ai   r0,screen_width            ; One VDP row down
;       dec  r2                         ; Decrease row counter
;       jne  draw_object_1              ; Loop until done
;*      Speak first time
;       mov  @object_speech(r4),r1
;       jeq  draw_object_11
;       bl   @say_phrase
;       clr  @object_speech(r4)
;*      Muzzle flash
;draw_object_11:
;       abs  @object_fire(r4)
;       jeq  draw_object_10
;       mov  r6,r0
;       dec  r0
;       sla  r0,3
;       ori  r0,>6000
;       mov  r0,@muzzle_flash
;       clr  @object_fire(r4)
;draw_object_10:
       .endproc
*// draw_object

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       li   r0,colrtb
       bl   @vwad
       li   r5,screen_buffer
       li   r6,3
upload_screen_1:
       li   r7,32
upload_screen_2:
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r5,192-64
       dec  r7
       jne  upload_screen_2
       bl   @check_int
       ai   r5,64-(32*192)
       dec  r6
       jne  upload_screen_1
       .endproc
*// upload_screen


*********************************************************************
*
* Upload screen loop
*

upload_screen_loop:
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       dec  r8
       jne  upload_screen_loop
       rt
upload_screen_loop_end:
       equ  $
*// upload_screen_loop

*********************************************************************
*
* Read user input
*
user_input:
       .proc
*      Map
       li   r0,KEY_M
       bl   @check_key
       jeq  user_input_0
       bl   @display_map
       jmp  user_input_8
*      Joystick
user_input_0:
       li   r0,JOY_FI
       bl   @check_key
*      Fire
       jeq  user_input_1
       abs  @bullet_active
       jne  user_input_1
       bl   @fire_bullet
*      Left
user_input_1:
       tb   1
       jeq  user_input_2
       mov  @angle,r0
       ai   r0,-32                     ; Turn left
       andi r0,angle_mask
       mov  r0,@angle
       seto @update_screen
       jmp  user_input_3
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       mov  @angle,r0
       ai   r0,32                      ; Turn right
       andi r0,angle_mask
       mov  r0,@angle
       seto @update_screen
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       mov  @angle,r2
       mov  @x,r0
       mov  @cos_table(r2),r3
       s    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r4
       s    r4,r1
       bl   @get_map_value
       jne  user_input_8
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_8
       mov  @angle,r2
       mov  @x,r0
       mov  @cos_table(r2),r3
       a    r3,r0
       mov  @y,r1
       mov  @sin_table(r2),r4
       a    r4,r1
       bl   @get_map_value
       jeq  user_input_5
       cb   @goal,r2                   ; Check for goal
       jne  user_input_9
       inc  @status                    ; Finish
       jmp  user_input_8
user_input_9:
       ci   r2,first_texture_index*256 ; Check for texture
       jhe  user_input_8               ; Cannot move through texture
       andi r2,>0100                   ; Test secret door bit
       jeq  user_input_8               ; If not set we cannot move
*      Move
user_input_5:
       seto @update_screen
       mov  r0,@x
       mov  r1,@y
       mov  @sal_no,r0
       mov  @sal_no_inc,r1
       jlt  user_input_6
       ci   r0,7
       jlt  user_input_7
       neg  r1
       mov  r1,@sal_no_inc
       jmp  user_input_7
user_input_6:
       ci   r0,0
       jgt  user_input_7
       neg  r1
       mov  r1,@sal_no_inc
user_input_7:
       a    r1,r0
       mov  r0,@sal_no
user_input_8:
       bl   @check_int
       .endproc
*// user_input

*********************************************************************
*
* Move enemies
*
move_enemies:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  move_enemies_3
move_enemies_1:
       mov  *r4,r0
       jeq  move_enemies_2
       mov  @object_type(r4),r0
       ci   r0,object_type_chest
       jeq  move_enemies_2
*      x
       mov  @object_x(r4),r0
       mov  @x,r2
       s    r0,r2
       mov  r2,r6
*      y
       mov  @object_y(r4),r1
       mov  @y,r3
       s    r1,r3
       mov  r3,r7
*      Check distance
       abs  r6
       abs  r7
       a    r6,r7
       ci   r7,max_object_distance*256
       jhe  move_enemies_2
*      x
       mov  r2,r2
       jeq  move_enemies_5
       jlt  move_enemies_4
       ci   r2,guard_speed
       jlt  move_enemies_5
       li   r2,guard_speed
       jmp  move_enemies_5
move_enemies_4:
       ci   r2,-guard_speed
       jgt  move_enemies_5
       li   r2,-guard_speed
move_enemies_5:
*      y
       mov  r3,r3
       jeq  move_enemies_7
       jlt  move_enemies_6
       ci   r3,guard_speed
       jlt  move_enemies_7
       li   r3,guard_speed
       jmp  move_enemies_7
move_enemies_6:
       ci   r3,-guard_speed
       jgt  move_enemies_7
       li   r3,-guard_speed
move_enemies_7:
*      Check map
       mov  r2,r6
       a    r2,r0
       a    r3,r1
       bl   @get_map_value
       jeq  move_enemies_8
       s    r6,r0
       bl   @get_map_value
       jeq  move_enemies_8
       a    r6,r0
       s    r3,r1
       bl   @get_map_value
       jne  move_enemies_2
move_enemies_8:
*      Move
       mov  r0,@object_x(r4)
       mov  r1,@object_y(r4)
*      Fire
move_enemies_9:
       bl   @rand
       ci   r0,>f800
       jl   move_enemies_2
       seto @object_fire(r4)
       dec  @health
       bl   @play_shot_2
*      Next object
move_enemies_2:
       ai   r4,object_size
       dec  r5
       jne  move_enemies_1
move_enemies_3:
       bl   @check_int
       .endproc
*// move_enemies

*********************************************************************
*
* Move bullets
*
move_bullets:
       abs  @bullet_active
       jeq  move_bullets_0
       a    @bullet_vx,@bullet_x
       a    @bullet_vy,@bullet_y
       li   r0,bullet_accl_z
       a    r0,@bullet_vz
       a    @bullet_vz,@bullet_z
       a    @bullet_speed,@bullet_distance
move_bullets_0:
       rt
*// move_bullets

*********************************************************************
*
* Draw bullets
*
draw_bullets:
       .proc
       mov  @sal_no,r0                 ; Which buffer to update?
       sla  r0,7
       ai   r0,spratb+(n_fixed_sprites*4)
       bl   @vwad                      ; Set VDP address
       abs  @bullet_active
       jeq  draw_bullets_0
*      Check angle
       mov  @bullet_angle,r0
       s    @angle,r0                  ; Subtract player angle
       ci   r0,-n_rays
       jlt  draw_bullets_0
       ci   r0,n_rays
       jgt  draw_bullets_0
       ai   r0,>78                     ; Center
       mov  @bullet_distance,r1
       srl  r1,8
       movb @bullet_distance_pattern_table(r1),r1    ; Pattern
*      Draw sprite
       movb @bullet_z,*r15             ; y
       movb @r0lb,*r15                 ; x
       movb r1,*r15                    ; pattern
       movb @bullet_color_byte,*r15    ; color
*      Muzzle flash
draw_bullets_0:
       mov  @muzzle_flash,r0
       jeq  draw_bullets_1
       movb r0,*r15
       movb @r0lb,*r15
       li   r0,>600b
       movb r0,*r15
       movb @r0lb,*r15
       clr  @muzzle_flash
*      End marker
draw_bullets_1:
       movb @end_marker_byte,*r15
       bl   @check_int
       .endproc
bullet_distance_pattern_table:
       byte >30,>34,>38,>3c,>40,>40,>44,>44
       byte >48,>48,>48,>4c,>4c,>4c,>4c,>4c
       byte >4c,>4c
bullet_color_byte:
       byte bullet_color
end_marker_byte:
       byte >d0
*// draw_bullets

*********************************************************************
*
* Bullet collisions
*
bullet_collisions:
       .proc
       abs  @bullet_active
       jeq  bullet_collisions_0
*      Check distance
       mov  @bullet_distance,r0
       ci   r0,max_bullet_distance*256
       jgt  bullet_collisions_1
*      Check for wall collision
       mov  @bullet_x,r0
       mov  @bullet_y,r1
       bl   @get_map_address
       movb *r2,r3
       jeq  bullet_collisions_2
       cb   r3,@door
       jne  bullet_collisions_1
       bl   @open_door
       jmp  bullet_collisions_1
*      Check for enemy collison
bullet_collisions_2:
       li   r4,objects
       mov  @n_objects,r5
       jeq  bullet_collisions_0
bullet_collisions_3:
       mov  *r4,r2
       jeq  bullet_collisions_4
       mov  @object_type(r4),r2
       ci   r2,object_type_chest
       jeq  bullet_collisions_4
       mov  @object_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0080
       jgt  bullet_collisions_4
       mov  @object_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0080
       jgt  bullet_collisions_4
*      hit
       dec  @object_health(r4)
       jgt  bullet_collisions_4
       bl   @remove_object
       li   r0,25
       a    r0,@score
       jmp  bullet_collisions_1
bullet_collisions_4:
       ai   r4,object_size
       dec  r5
       jne  bullet_collisions_3
       jmp  bullet_collisions_0
*      Remove bullet
bullet_collisions_1:
       clr  @bullet_active
bullet_collisions_0:
       bl   @check_int
       .endproc
*// bullet_collisions

*********************************************************************
*
* Object collisions
*
object_collisions:
       .proc
       li   r4,objects
       mov  @n_objects,r5
       jeq  object_collisions_3
       mov  @x,r0
       mov  @y,r1
object_collisions_1:
       mov  *r4,r2
       jeq  object_collisions_2
       mov  @object_type(r4),r2
       ci   r2,object_type_chest
       jne  object_collisions_2
       mov  @object_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0100
       jgt  object_collisions_2
       mov  @object_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0100
       jgt  object_collisions_2
       bl   @remove_object
       li   r0,100
       a    r0,@score
       bl   @play_chest
       jmp  object_collisions_3
object_collisions_2:
       ai   r4,object_size
       dec  r5
       jne  object_collisions_1
object_collisions_3:
       bl   @check_int
       .endproc
*// object_collisions

*********************************************************************
*
* Update health bar
*
update_health_bar:
       .proc
       c    @health,@old_health
       jeq  update_health_bar_4
       mov  @health,r0
       jgt  update_health_bar_0
       dec  @status
       clr  r0
update_health_bar_0:
       mov  r0,r1
       mov  r0,r2
       srl  r0,4                       ; Which sprite 0-3 to update
       sla  r0,5                       ; Sprite pattern offset
       andi r1,>0008                   ; Isolate column bit
       sla  r1,1                       ; Column offset
       a    r1,r0                      ; Add to address
       ai   r0,sprptb+(20*32)          ; Add base address
       bl   @vwad
*      Pixels within column
       li   r1,>00aa                   ; Pattern
       andi r2,>0007                   ; Number of pixels to show
       li   r0,8
       s    r2,r0                      ; Number of pixels to clear
       srl  r1,0
       sla  r1,0
       swpb r1
       li   r2,12
update_health_bar_1:
       movb r1,*r15
       movb r1,*r15
       dect r2
       jne  update_health_bar_1
*      Full columns to clear
       mov  @old_health,r2
       srl  r2,3                       ; Old column
       mov  @health,r2
       srl  r0,3                       ; New column
       s    r0,r2                      ; Column difference
       jeq  update_health_bar_3
       jlt  update_health_bar_3
       sla  r2,4                       ; columns * 16
update_health_bar_2:
       clr  *r15
       clr  *r15
       dect r2
       jne  update_health_bar_2
update_health_bar_3:
       mov  @health,@old_health
update_health_bar_4:
       .endproc
*// update_health_bar

*********************************************************************
*
* Display score
*
display_score:
       .proc
       mov  @score,r1
       c    r1,@old_score
       jeq  display_score_1
       li   r0,26+32
       li   r2,5
       bl   @display_decimal
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Display map
*
display_map:
       .proc
*      Set patterns and colors
       li   r0,ptrnt2+(12*8*8)
       clr  r1
       li   r2,64*8
       bl   @vsmw
       li   r0,colrt2+(12*8*8)
       li   r1,>f100
       li   r2,64*8
       bl   @vsmw
*      Display map
       li   r0,ptrnt2+(12*8*8)
       bl   @vwad
       li   r6,>0080                   ; A bit to set
       li   r0,map                     ; Source address
       li   r3,map_width/8             ; Column counter
*      Column loop
display_map_7:
       li   r4,map_height            ; Row counter
*      Line loop
display_map_6:
       clr  r2                         ; Result byte to write to VDP
       li   r5,8                       ; Bits in a byte
*      Bit loop
display_map_8:
       movb *r0+,r1                    ; Get map byte
       jeq  display_map_5              ; Don't set map bit if zero
       soc  r6,r2                      ; Set bit
display_map_5:
       sla  r2,1                       ; Shift result left to accept next bit
       dec  r5
       jne  display_map_8              ; Next bit
       movb r2,*r15                    ; Write 8 pixels to VDP
       ai   r0,map_width-8             ; Next row of map
       dec  r4
       jne  display_map_6
       ai   r0,(-map_height*map_width)+8
       dec  r3
       jne  display_map_7              ; Next column
*      Display player position
       mov  @sal_no,r0                 ; Which table to update?
       sla  r0,7
       ai   r0,spratb+(n_fixed_sprites*4)
       bl   @vwad                      ; Set VDP address
       movb @y,r0
       ab   @map_y,r0
       movb r0,*r15
       movb @x,r0
       ab   @map_x,r0
       movb r0,*r15
       li   r0,>4805
       movb r0,*r15
       movb @r0lb,*r15
*      Wait key
display_map_1:
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_1
display_map_2:
       li   r0,KEY_UP
       bl   @check_key
       jeq  display_map_2
*      Restore patterns
       li   r0,colrt2+(12*8*8)
       li   r1,>1100
       li   r2,64*8
       bl   @vsmw
       li   r0,ptrnt2+(12*8*8)
       li   r1,>f000
       li   r2,64*8
       bl   @vsmw
       .endproc
map_x:
       byte 96-8
map_y:
       byte 64-9

*// display_map

*********************************************************************
*
* Fire bullet
*
fire_bullet:
       .proc
       mov  @x,@bullet_x
       mov  @y,@bullet_y
       li   r3,>9000
       mov  r3,@bullet_z               ; Screen y coordinate
       mov  @angle,r2
       mov  @cos_table(r2),@bullet_vx
       mov  @sin_table(r2),@bullet_vy
       li   r3,bullet_speed_z
       mov  r3,@bullet_vz
       mov  r2,@bullet_angle
       li   r3,>0100                   ; 1.0
       mov  r3,@bullet_speed
       clr  @bullet_distance
       seto @bullet_active
       bl   @play_shot_1
       .endproc
*// fire_bullet

*********************************************************************
*
* Open door
*
* r0: x FP 8.8
* r1: y FP 8.8
* r2: Map address
*
open_door:
       .proc
       movb @space,*r2
       li   r8,doors
       mov  @n_doors,r9
open_door_1:
       cb   r0,@door_x(r8)
       jne  open_door_2
       cb   r1,@door_y(r8)
       jne  open_door_2
       mov  @door_object_inits(r8),r4
       mov  @door_n_objects(r8),r5
       jeq  open_door_3
open_door_4:
       bl   @create_object
       ai   r4,object_init_size
       dec  r5
       jne  open_door_4
       jmp  open_door_3
open_door_2:
       ai   r8,door_size
       dec  r9
       jne  open_door_1
open_door_3:
       seto @update_screen
       .endproc
*// open_door

*********************************************************************
*
* Get map value
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the map byte. r0 and r1 are preserved.
*
get_map_value:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       movb @map(r2),r2
       rt
*// get_map_value

*********************************************************************
*
* Get map address
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the address. r0 and r1 are preserved.
*
get_map_address:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       ai   r2,map
       rt
*// get_map_address

*********************************************************************
*
* Reset objects
*
reset_objects:
       li   r5,objects
       li   r6,max_objects
reset_objects_1:
       clr  *r5
       ai   r5,object_size
       dec  r6
       jne  reset_objects_1
       rt
*// reset_objects

*********************************************************************
*
* Create object
*
* r4: Object init data
*
* On return r6 contains the address of the object, or 0 if it failed
* Uses: r2,r3,r6,r7
*
create_object:
       li   r6,objects
       clr  r7
create_object_1:
       mov  *r6,r3                     ; Object active?
       jne  create_object_2
       inc  *r6                        ; set active
       mov  @object_init_type(r4),r2
       mov  r2,@object_type(r6)
       movb @object_init_x(r4),@object_x(r6)
       movb @byte_00,@object_x+1(r6)
       movb @object_init_y(r4),@object_y(r6)
       movb @byte_00,@object_y+1(r6)
       mov  r2,r3
       sla  r3,1
       mov  @object_depth_tables(r3),@object_depth_table(r6)
       mov  @object_speech_table(r3),@object_speech(r6)
       mov  @object_health_table(r3),@object_health(r6)
       clr  @object_fire(r6)
*      Next object
       c    r7,@n_objects
       jlt  create_object_3
       inc  @n_objects
       jmp  create_object_3
create_object_2:
       ai   r6,object_size
       inc  r7
       ci   r7,max_objects
       jlt  create_object_1
       clr  r6
create_object_3:
       rt
*// create_object

*********************************************************************
*
* Remove object
*
* r4: Address of object
*
remove_object:
       .proc
       mov  r4,r0
       ai   r0,object_size
       mov  r4,r1
       li   r2,objects+(object_size*max_objects)
       s    r4,r2
       bl   @copy
       li   r0,objects+(object_size*(max_objects-1))
       clr  *r0
       dec  @n_objects
       .endproc
*// remove_object

*********************************************************************
*
* Initialize level
*
init_level:
       .proc
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@angle
       li   r0,initial_health
       mov  r0,@health
       mov  r0,@old_health
       clr  @score
       seto @old_score
       clr  @status
       seto @update_screen
*      Init doors
       li   r4,doors
       mov  @n_doors,r5
init_level_1:
       clr  r0
       movb @door_x(r4),r0
       clr  r1
       movb @door_y(r4),r1
       bl   @get_map_address
       movb @door,*r2
       ai   r4,door_size
       dec  r5
       jne  init_level_1
*      Init objects
       bl   @reset_objects
       li   r4,object_init_data
       li   r5,initial_objects
init_level_2:
       bl   @create_object
       ai   r4,object_init_size
       dec  r5
       jne  init_level_2
*      Speak
       li   r1,start_of_level
       bl   @say_phrase
*      Sprite patterns
       li   r0,sprptb+(20*32)
       li   r1,SPR20
       li   r2,4*32
       bl   @vmbw
       .endproc
*// init_level

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r0,1
       mov  r0,@one
       bl   @graphics_mode
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Copy textures to RAM
       seto @texture_bank_select
       li   r0,>6000
       li   r1,textures
       li   r2,>2000
       bl   @copy
*      Init speech
       bl   @init_speech
*      Patterns
       li   r0,ptrntb
       li   r1,>f000
       li   r2,>1800
       bl   @vsmw
*      Colors
       li   r0,colrtb
       clr  r1
       li   r2,>1800
       bl   @vsmw
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r3,24
one_time_init_4:
       li   r2,32
one_time_init_5:
       movb r1,*r15
       ai   r1,>0800
       dec  r2
       jne  one_time_init_5
       ai   r1,>0100
       andi r1,>0700
       dec  r3
       jne  one_time_init_4
*      Sprite patterns
       li   r0,sprptb
       li   r1,SPR0
       li   r2,n_sprite_patterns*32
       bl   @vmbw
*      Sprite attribute tables
       li   r0,spratb
       li   r3,8
       li   r4,>ff00
one_time_init_1:
       bl   @vwad
       li   r2,n_fixed_sprites
       li   r1,sal
one_time_init_2:
       movb *r1+,r5
       ci   r2,n_fixed_sprites-4
       jgt  one_time_init_3
       ab   r4,r5
one_time_init_3:
       movb r5,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r2
       jne  one_time_init_2
       ai   r0,>80
       ai   r4,>0100
       dec  r3
       jne  one_time_init_1
       inc  @sal_no_inc
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; 3 color tables
       byte ptrntb/>800+>03            ; 3 pattern tables
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte backdrop_color             ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       .proc
       ai   r0,nametb
       mov  r0,r4
       bl   @vwad
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       ai   r0,char_0
       swpb r0
       movb r0,*r15
       dec  r2
       jne  display_decimal_1
       ai   r1,char_0
       swpb r1
       movb r1,*r15
       .endproc
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// display_decimal

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source
* r1: destination
* r2: number of bytes
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       b    *r11
*// rand

*********************************************************************
*
* Arcus tangent 2 function
*
* Calculates the angle of the vector with coordinates (x,y) = (r0,r1)
* Uses r2-r3
* Result in r6 as FP 8.8
*
atan2:
       clr  r3                         ; For division
       mov  r1,r1                      ; if (y >= 0) {
       jlt  atan2_4
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_2
*      Q1
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_1
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2                      ; Result in r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       rt                              ;             result = 0x00 + a;
atan2_1:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x40 - a;
       ai   r6,>4000
       rt                              ;         }
atan2_2:                               ;     } else {
*      Q2
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_3
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x80 - a;
       ai   r6,>8000
       rt
atan2_3:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>4000                   ;                 result = 0x40 + a;
       rt                              ;         }
                                       ;     }
atan2_4:                               ; } else {
       neg  r1                         ;     y = -y;
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_6
*      Q4
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_5
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x100 - a;
       rt
atan2_5:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>c000                   ;                 result = 0xc0 + a;
       rt                              ;         }
atan2_6:                               ;     } else {
*      Q3
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_7
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>8000                   ;                 result = 0x80 + a;
       rt
atan2_7:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0xc0 - a;
       ai   r6,>c000
       rt                              ;         }
                                       ;     }
                                       ; }
*// atan2

*********************************************************************
*
* Euclidian distance
*
* Calculates the length of the vector with coordinates (x,y) = (r0,r1)
* Result in r7 as FP 8.8
*
euclidian_distance:
       abs  r0
       ai   r0,>0080                   ; x += 0.5
       srl  r0,8                       ; round(x)
       abs  r1
       ai   r1,>0080                   ; y += 0.5
       srl  r1,8                       ; round(y)
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; +x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,2                       ; To FP 8.8
       rt
*// euclidian_distance

*********************************************************************
*
* Program files
*
       copy "vdp.a99"
       copy "speech.a99"
       copy "sound-fx-routines.a99"
;      copy "music-player.a99"
       copy "sound-player.a99"

***************************************************************
*
* Data
*
start_x:
       data >0500
start_y:
       data >2100
start_dir:
       data >140
space:
       byte 0
door:
       byte 13
goal:
       byte 14
checkered:
       byte 15
byte_00:
       byte >00
byte_01:
       byte >01

depth_buffer:
       bss  n_rays*2

column_height:
       equ  0
column_color:
       equ  2
column_side:
       equ  4
column_hit_x:
       equ  6
column_size:
       equ  8

columns:
       bss  n_rays*column_size

**
* Objects
*
object_active:                         ; 0 = inactive, <> 0 = active,
       equ  0
object_type:
       equ  2
object_x:
       equ  4
object_y:
       equ  6
object_depth_table:
       equ  8
object_speech:
       equ  10
object_fire:
       equ  12
object_health:
       equ  14
object_size:
       equ  16

object_type_guard:
       equ  1
object_type_boss:
       equ  2
object_type_chest:
       equ  3

object_init_type:
       equ  0
object_init_x:
       equ  2
object_init_y:
       equ  3
object_init_size:
       equ  4

n_objects:
       data 0
objects:
       bss  object_size*16

object_depth_tables:
       data 0
       data 0                          ; Guard
       data 0                          ; Boss
       data 0                          ; Chest
object_speech_table:
       data 0
       data hand_up                    ; Guard
       data your_time_is_up            ; Boss
       data come_and_get_me            ; Chest
object_health_table:
       data 0
       data 1                          ; Guard
       data 5                          ; Boss
       data 0                          ; Chest

bullet_active:
       data 0
bullet_x:
       data 0
bullet_y:
       data 0
bullet_z:
       data 0
bullet_vx:
       data 0
bullet_vy:
       data 0
bullet_vz:
       data 0
bullet_angle:
       data 0
bullet_speed:
       data 0
bullet_distance:
       data 0

***************************************************************
*
* Data files
*
       copy "sprites.a99"
       copy "sound-fx.a99"

lower_ram_max:
       equ  $
**
*      Upper RAM
*
       aorg >a000

textures:                              ; Must be at 256 byte boundary address
       bss  >2000

       copy "math_tables.a99"
       copy "graphics.a99"

map:
       equ  MD0

doors:
       copy "doors.a99"
col_index:
       copy "../TexGen/col-index.a99"

*      Organised as 32 columns of 192 bytes
*      First 192 bytes for column 0, next 192 bytes for column 1 etc.
*      Each column contains 2 fat (4x1, 16 color) pixels horizontally
*      and 192 pixels vertically.

screen_buffer:
       bss  >1800

upper_ram_max:
       equ  $

       end  main

