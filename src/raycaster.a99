*********************************************************************
*
* Textured raycaster
* For the TI-99/4A home computer
*
* April 2020 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "structs.a99"
       copy "sound-defs.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 1
ptrnt2 equ  >0800                      ; Pattern table base 2
ptrnt3 equ  >1000                      ; Pattern table base 3
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base 1
colrt2 equ  >2800                      ; Color table base 2
colrt3 equ  >3000                      ; Color table base 3
nametb equ  >3800                      ; Name table base
spratb equ  >3c00                      ; Sprite attribute table base 1
sprat2 equ  >3c80                      ; Sprite attribute table base 2
sprat3 equ  >3d00                      ; Sprite attribute table base 3
sprat4 equ  >3d80                      ; Sprite attribute table base 4
sprat5 equ  >3e00                      ; Sprite attribute table base 5
sprat6 equ  >3e80                      ; Sprite attribute table base 6
sprat7 equ  >3f00                      ; Sprite attribute table base 7
sprat8 equ  >3f80                      ; Sprite attribute table base 8

**
* Constants
*
map_width:
       equ  64
map_height:
       equ  64
map_size:
       equ  map_width*map_height
map_sams_page:
       equ  >0000
screen_width:
       equ  64
screen_height:
       equ  128
screen_buffer_sams_page:
       equ  >0100
height_at_distance_1:
       equ  160
n_directions:
       equ  256
turn_speed:
       equ  64
angle_mask:
       equ  2*n_directions-1
n_rays:
       equ  screen_width
max_steps:
       equ  24
allow_missing_ray:
       equ  0
max_wall_height:
       equ  528
max_sprite_width:
       equ  32
max_sprite_height:
       equ  128
max_sprite_distance:
       equ  8
max_sprites:
       equ  16
n_hw_sprite_patterns:
       equ  33
n_high_priority_hw_sprites:
       equ  2
n_fixed_hw_sprites:
       equ  8
n_compass_hw_sprites:
       equ  6
enemy_speed:
       equ  >0010
bullet_speed_z:
       equ  ->0c00
bullet_accl_z:
       equ  >0120
max_bullet_distance:
       equ  16
bullet_color:
       equ  >0f
backdrop_color:
       equ  >0e
char_0:
       equ  >30
max_health:
       equ  64
max_might:
       equ  64
texture_bank_select:
       equ  >6022
texture_sams_page:
       equ  >1000
n_texture_banks:
       equ  9
texture_width:                         ; Width in fat pixels
       equ  32
texture_height:
       equ  64
texture_size:
       equ  (texture_width/2)*texture_height
max_texture_height_2:                  ; Up to this value
       equ  192                        ; all even heights are indexed
max_texture_height_8:                  ; Up to this value
       equ  456                        ; every 8th height is indexed
first_object_texture:
       equ  32
first_monster_texture:
       equ  40
first_action_block:
       equ  32
background_bank_select:
       equ  >6040
background_sams_page:
       equ  >c000
n_background_banks:
       equ  8
background_address:
       equ  >6000
background_height:
       equ  128
inventory_size:
       equ  8
bottom_panel_bank_select:
       equ  >603e
map_bank_select:
       equ  >603c

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
intws  equ  wrksp+>20                  ; Interrupt work space
stack  equ  intws+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
one:
       equ  padcon
**
* PAD variables
*
padvar:
       equ  one+2                      ; Start of pad variables
interrupt_count:
       equ  padvar
rand_no:
       equ  interrupt_count+2
score:
       equ  rand_no+2
old_score:
       equ  score+2
health:
       equ  old_score+2
old_health:
       equ  health+2
might:
       equ  old_health+2
old_might:
       equ  might+2
status:
       equ  old_might+2
x:                                     ; Player x FP 8.8
       equ  status+2
y:                                     ; Player y FP 8.8
       equ  x+2
dx:
       equ  y+2
dy:
       equ  dx+2
angle:                                 ; Player direction 0 - 2 * n_directions (even only)
       equ  dy+2
ray_count:
       equ  angle+2
ray_angle:
       equ  ray_count+2
distance:
       equ  ray_angle+2
column_ptr:
       equ  distance+2
full_redraw_required:
       equ  column_ptr+2
column_redraw_cleared:
       equ  full_redraw_required+2
current_background_page_select:
       equ  column_redraw_cleared+2
has_sprite_moved:
       equ  current_background_page_select+2
current_sprite:
       equ  has_sprite_moved+2
pointer_x:
       equ  current_sprite+2
pointer_y:
       equ  pointer_x+2
pointer_pattern:
       equ  pointer_y+2
pointer_color:
       equ  pointer_pattern+1
pointer_click:
       equ  pointer_color+1
is_target_pointer:
       equ  pointer_click+2
inventory_index:
       equ  is_target_pointer+2
target_inventory_index:
       equ  inventory_index+2
selected_object:
       equ  target_inventory_index+2
snd_channel_1:
       equ  selected_object+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
snd_track_1:
       equ  snd_channel_4+snd_channel_size
snd_track_2:
       equ  snd_track_1+snd_track_size
snd_track_3:
       equ  snd_track_2+snd_track_size
module_speed:
       equ  snd_track_3+snd_track_size
get_speech_status:
       equ  module_speed+2
speech_ptr:
       equ  get_speech_status+6
speech_on:
       equ  speech_ptr+2
cast_ray_loop_pad:
       equ  speech_on+2
upload_screen_loop_pad:
       equ  cast_ray_loop_pad+30
pad_max:
       equ  upload_screen_loop_pad+22

***************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       bl   @one_time_init
restart:
       bl   @init_level
main_loop:
       clr  @interrupt_count
       bl   @cast_if_required
       bl   @draw_screen
       bl   @draw_sprites
       bl   @upload_screen
       bl   @keyboard_input
       bl   @pointer_actions
       bl   @bullet_collisions
       bl   @sprite_collisions
       bl   @move_sprites
       bl   @move_bullets
       bl   @update_health_bar
       bl   @update_might_bar
       bl   @display_score
       bl   @speak
       bl   @delay
       mov  @status,r0
       jeq  main_loop
       jgt  finish
       bl   @play_die
       jmp  pause
finish:
       bl   @play_finish
pause:
       li   r14,120
pause_loop:
       bl   @wait_int
       dec  r14
       jne  pause_loop
pause_loop_1:
       bl   @wait_int
       li   r0,KEY_FI
       bl   @check_key
       jeq  pause_loop_1
       jmp  restart

*********************************************************************
*
* Delay if needed
*
delay:
       .proc
delay_1:
       mov  @interrupt_count,r0
       ci   r0,3
       jhe  delay_2
       bl   @wait_int
       jmp  delay_1
delay_2:
       .endproc
*// delay

*********************************************************************
*
* Wait for interrupt
*
wait_int:
       clr  r12
wait_int_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  wait_int_1
       blwp @interrupt
       rt
*// wait_int

*********************************************************************
*
* Check for interrupt
*
*
check_int:
       clr  r12
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  check_int_1
       blwp @interrupt
check_int_1:
       rt
*// check_int

***************************************************************
*
* Interrupt routine
* Called with blwp @interrupt
*
interrupt:
       data intws
       data interrupt_1
interrupt_1:
       inc  @interrupt_count
       movb @vdpsta,r12
       mov  @wrksp+20,r10              ; Copy stack pointer
       li   r15,vdpwd
       bl   @upload_hw_sprites
       mov  @tipi_crubase,r0
       jne  interrupt_2
       bl   @joystick_input
       jmp  interrupt_3
interrupt_2:
       bl   @sams_disable_reg_access
       bl   @tipi_read_mouse
       bl   @sams_enable_reg_access
interrupt_3:
       bl   @module_player
       clr  r15
       rtwp
*// interrupt

*********************************************************************
*
* Upload hardware sprites
*
upload_hw_sprites:
       .proc
       mov  @sal_no,r0                 ; Which buffer to update?
       sla  r0,7
       ai   r0,spratb
       bl   @vwad                      ; Set VDP address
*      Pointer has highest priority
       movb @pointer_y,*r15
       movb @pointer_x,*r15
       movb @pointer_pattern,*r15
       movb @pointer_color,*r15
*      Skip high priority and fixed sprites
       ai   r0,(n_high_priority_hw_sprites+n_fixed_hw_sprites)*4
       bl   @vwad
*      Bullets
       bl   @draw_bullets
*      Blood stain
       mov  @blood_stain_count,r0
       jeq  upload_hw_sprites_2
       li   r0,blood_stain_sal
       mov  @blood_stain_x,r1
       li   r2,4
upload_hw_sprites_1:
       movb *r0+,*r15
       movb *r0+,r3
       ab   r1,r3
       movb r3,*r15
       movb *r0+,*r15
       movb *r0+,*r15
       dec  r2
       jne  upload_hw_sprites_1
       dec  @blood_stain_count
*      End marker
upload_hw_sprites_2:
       movb @end_marker_byte,*r15
       .endproc
end_marker_byte:
       byte >d0
*// upload_hw_sprites

*********************************************************************
*
* Cast if required
*
cast_if_required:
       .proc
       abs  @full_redraw_required
       jeq  cast_if_required_1
       bl   @cast_rays
       clr  @column_redraw_cleared
       jmp  cast_if_required_2
cast_if_required_1:
       bl   @skip_cast_rays
       bl   @check_int
       seto @column_redraw_cleared
cast_if_required_2:
       .endproc
*// cast_if_required

*********************************************************************
*
* Cast rays
*
cast_rays:
       .proc
       li   r0,map_sams_page
       mov  r0,@sams_reg_3             ; Page map into >3000
       li   r0,columns
       mov  r0,@column_ptr
       li   r2,n_rays                  ; Number of rays to cast
       mov  r2,@ray_count              ; Init count-down
       mov  @angle,r2                  ; Player direction (even only)
       ai  r2,-n_rays                  ; Direction of leftmost ray
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save
cast_rays_1:
*      Cast ray
       mov  @x,r0                      ; x
       mov  @y,r1                      ; y
       mov  @ray_angle,r2              ; Direction
       bl   @cast_ray                  ; Cast ray (r2=distance, r3=side, r4=color)
       mov  @column_ptr,r5
       movb @r0lb,@column_map_x(r5)
       movb @r1lb,@column_map_y(r5)
       mov  r2,@distance               ; Save euclidian distance
       bl   @fish_eye_correction       ; Adjust distance in r2
*      Calculate height and color of column
       mov  r2,r0                      ; Distance as FP 8.8
       .ifeq allow_missing_ray,1
       jne  cast_rays_2
       li   r0,max_wall_height         ; Max height
       jmp  cast_rays_3
       .endif
cast_rays_2:
       clr  r0
       li   r1,height_at_distance_1*256 ; Height at distance 1 as FP 24.8
       div  r2,r0                       ; height = height at distance 1 / distance, as FP 16.0
cast_rays_3:
       andi r0,>fffe                   ; Make height even
       mov  r0,@column_height(r5)
       mov  @distance,@column_distance(r5)
       mov  @distance,@column_distance_copy(r5)
       bl   @wall_color
       ai   r5,column_size
       mov  r5,@column_ptr
*      Next ray
       mov  @ray_angle,r2              ; Get ray direction
       inct r2                         ; Increment it
       andi r2,angle_mask              ; Wrap around
       mov  r2,@ray_angle              ; Save it
       bl   @check_int
       dec  @ray_count                 ; Count down
       jne  cast_rays_1                ; Loop if more rays to cast
       .endproc
*// cast_rays

*********************************************************************
*
* Skip cast rays
*
* Restore all column values to those from the last cast,
* because these may have been changed by sprite drawing.
*
skip_cast_rays:
       li   r4,columns
       li   r5,n_rays                  ; Number of columns
skip_cast_rays_1:
       mov  @column_distance_copy(r4),@column_distance(r4)   ; Restore distance
       abs  @column_redraw_cleared
       jne  skip_cast_rays_2
       clr  @column_redraw(r4)
*      Next column
skip_cast_rays_2:
       ai   r4,column_size
       dec  r5                         ; Count down
       jne  skip_cast_rays_1           ; Loop if more columns
       rt
*// skip_cast_rays

*********************************************************************
*
* Draw screen
*
draw_screen:
       .proc
       li   r0,screen_buffer_sams_page
       mov  r0,@sams_reg_3                     ; Page screen buffer into >3000
       bl   @calc_background_address
       li   r3,screen_buffer
       li   r4,columns
       clr  r5
draw_screen_1:
*      Check even or odd
       mov  r5,r0
       andi r0,1
       jne  draw_screen_3
*      Check if column and next can be skipped
       abs  @full_redraw_required
       jne  draw_screen_2
       abs  @column_redraw(r4)
       jne  draw_screen_2
*      No need to redraw 2 columns
       ai   r3,screen_height
       ai   r8,background_height
       ai   r4,column_size*2
       inct r5
       jmp  draw_screen_5
draw_screen_2:
*      Draw even column
       bl   @draw_even_column
       ai   r3,-screen_height
       ai   r8,-screen_height
       jmp  draw_screen_4
draw_screen_3:
*      Draw odd column
       bl   @draw_odd_column
       .ifgt background_height, screen_height
       ai   r8,background_height-screen_height
       .endif
draw_screen_4:
*      Next column
       ai   r4,column_size
       inc  r5
draw_screen_5:
       bl   @check_int
       ci   r5,n_rays
       jlt  draw_screen_1
*      Done
       .endproc
*// draw_screen

*********************************************************************
*
* Draw sprites
*
draw_sprites:
       .proc
       abs  @full_redraw_required
       jne  draw_sprites_0
       abs  @has_sprite_moved
       jeq  draw_sprites_3
draw_sprites_0:
       bl   @clear_column_sprite_pointers
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  draw_sprites_3
draw_sprites_1:
       mov  *r4,r0                     ; Active?
       jeq  draw_sprites_2
       bl   @check_int
       mov  @sprite_x(r4),r0
       s    @x,r0                      ; dx
       mov  @sprite_y(r4),r1
       s    @y,r1                      ; dy
       mov  r0,r2
       abs  r2
       mov  r1,r3
       abs  r3
       a    r2,r3                      ; Taxi distance
       jeq  draw_sprites_2
       ci   r3,max_sprite_distance*3/2*256
       jhe  draw_sprites_2
*      Look up angle
       bl   @atan2
       mov  r6,@sprite_angle(r4)
       mov  @angle,r2
       sla  r2,7
       s    r2,r6
       sra  r6,7
       ci   r6,-n_rays-max_sprite_width
       jlt  draw_sprites_2
       ci   r6,n_rays+max_sprite_width-1
       jgt  draw_sprites_2
*      Look up distance
       bl   @euclidian_distance
       ci   r7,max_sprite_distance*256
       jgt  draw_sprites_2
*      Sprite is within view and distance
       bl   @draw_sprite
draw_sprites_2:
       ai   r4,sprite_size
       dec  r5
       jne  draw_sprites_1
draw_sprites_3:
       .endproc
*// draw_sprites

*********************************************************************
*
* Clear column sprite pointers
*
clear_column_sprite_pointers:
       li   r4,columns+column_sprite
       li   r5,n_rays
clear_column_sprite_pointers_1:
       clr  *r4
       ai   r4,column_size
       dec  r5
       jne  clear_column_sprite_pointers_1
       rt
*// clear_column_sprite_pointers

*********************************************************************
*
* Draw sprite
*
* r4: sprite to draw
* r6: angle relative to player (2 units per column)
* r7: distance FP 8.8 (last 6 bits are zero)
*
draw_sprite:
       .proc
       .push r5
       mov  r4,@current_sprite
       mov  @sprite_type(r4),r5
       mov  @sprite_type_props(r5),r5
*      Width, Height
       ci   r7,>0100
       jgt  draw_sprite_1
       li   r2,max_sprite_height
       jmp  draw_sprite_2
draw_sprite_1:
       clr  r2
       li   r3,max_sprite_height*256   ; max_sprite_height as FP 24.8
       div  r7,r2                      ; Size (FP 16.0) = max_sprite_height / distance
draw_sprite_2:
       coc  @sprite_half_size,r5
       jne  draw_sprite_3
       srl  r2,1                       ; Half size
draw_sprite_3:
       mov  r2,r3                      ; Height = size
       srl  r2,2                       ; Width = size / 4
*      Column
       li   r0,screen_width
       a    r6,r0
       s    r2,r0
       sra  r0,1
*      Row
       li   r1,screen_height           ; Screen height
       coc  @sprite_half_size,r5
       jeq  draw_sprite_4
       s    r3,r1                      ; Minus sprite height
draw_sprite_4
       srl  r1,1                       ; Divided by 2
*      Texture
       mov  @sprite_texture(r4),r4     ; Texture number
*      Distance
       mov  r7,r5                      ; Depth/distance
*      Draw sprite
       bl   @draw_texture
*      Speak first time
       mov  @current_sprite,r4
       mov  @sprite_speech(r4),r1
       jeq  draw_sprite_5
       bl   @say_phrase
       clr  @sprite_speech(r4)
draw_sprite_5:
       .pop r5
       .endproc
*// draw_sprite

*********************************************************************
*
* Upload screen
*
upload_screen:
       .proc
       li   r14,vdpwa
       abs  @full_redraw_required
       jeq  upload_screen_3
*      Full update
       li   r0,colrtb+>4000
       li   r5,screen_buffer
*      Full sections of 64 lines
       li   r6,(screen_height/64)
upload_screen_1:
       movb @r0lb,*r14
       movb r0,*r14
       li   r7,screen_width/2
upload_screen_2:
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r5,screen_height-64
       dec  r7
       jne  upload_screen_2
       bl   @check_int
       ai   r5,64-(screen_height*screen_width/2)
       ai   r0,>800
       dec  r6
       jne  upload_screen_1
       .ifne screen_height%64, 0
*      Remaining lines
       li   r7,screen_width/2
upload_screen_2a:
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,(screen_height%64)/8
       bl   @upload_screen_loop_pad
       ai   r5,screen_height-(screen_height%64)
       ai   r0,64
       dec  r7
       jne  upload_screen_2a
       bl   @check_int
       .endif
       clr  @full_redraw_required
       jmp  upload_screen_8
*      Column update
upload_screen_3:
       li   r0,colrtb+>4000
       li   r1,columns
       li   r2,screen_width/2
       li   r5,screen_buffer
upload_screen_4:
*      Check if the column can be skipped
       abs  @column_redraw(r1)
       jne  upload_screen_5
*      Skip column
       ai   r0,64
       ai   r5,screen_height
       jmp  upload_screen_7
*      Update column
upload_screen_5:
*      Full sections of 64 lines
       li   r6,(screen_height/64)
upload_screen_6:
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,64/8
       bl   @upload_screen_loop_pad
       ai   r0,>800
       dec  r6
       jne  upload_screen_6
       .ifne screen_height%64, 0
*      Remaining lines
       movb @r0lb,*r14
       movb r0,*r14
       li   r8,(screen_height%64)/8
       bl   @upload_screen_loop_pad
       .endif
       ai   r0,64-(screen_height/64*>800)
       bl   @check_int
upload_screen_7:
       ai   r1,column_size*2
       dec  r2
       jne  upload_screen_4
upload_screen_8:
       bl   @check_int
       .endproc
*// upload_screen

*********************************************************************
*
* Keyboard input
*
keyboard_input:
       .proc
       li   r0,map_sams_page
       mov  r0,@sams_reg_3             ; Page map into >3000
*      Space - Fire
       li   r0,KEY_SP
       bl   @check_key
       jeq  keyboard_input_1
       bl   @fire_bullet
*      Q - Turn left
keyboard_input_1:
       li   r0,KEY_Q
       bl   @check_key
       jeq  keyboard_input_2
       bl   @turn_left
       jmp  keyboard_input_8
*      E - Turn right
keyboard_input_2:
       li   r0,KEY_E
       bl   @check_key
       jeq  keyboard_input_3
       bl   @turn_right
       jmp  keyboard_input_8
*      S - Move back
keyboard_input_3:
       li   r0,KEY_S
       bl   @check_key
       jeq  keyboard_input_4
       bl   @move_back
       jmp  keyboard_input_8
*      W - Move forward
keyboard_input_4:
       li   r0,KEY_W
       bl   @check_key
       jeq  keyboard_input_5
       bl   @move_forward
       jmp  keyboard_input_8
*      A - Strafe left
keyboard_input_5:
       li   r0,KEY_A
       bl   @check_key
       jeq  keyboard_input_6
       bl   @move_left
       jmp  keyboard_input_8
*      D - Strafe right
keyboard_input_6:
       li   r0,KEY_D
       bl   @check_key
       jeq  keyboard_input_7
       bl   @move_right
       jmp  keyboard_input_8
*      M - Map
keyboard_input_7:
       li   r0,KEY_M
       bl   @check_key
       jeq  keyboard_input_8
       bl   @display_map
*      Done
keyboard_input_8:
       bl   @check_int
       .endproc
dirs:
       data >0100,>0000
       data >0100,>0100
       data >0000,>0100
       data ->0100,>0100
       data ->0100,>0000
       data ->0100,->0100
       data >0000,->0100
       data >0100,->0100
*// keyboard_input

*********************************************************************
*
* Turn left
*
turn_left:
       .proc
       mov  @angle,r0
       ai   r0,-turn_speed             ; Turn left
       andi r0,angle_mask
       mov  r0,@angle
       srl  r0,4
       mov  r0,r1
       ai   r0,dirs
       mov  *r0+,@dx
       mov  *r0,@dy
       srl  r1,2
       mov  r1,@sal_no
       seto @full_redraw_required
       bl   @set_sal
       .endproc
*// turn_left

*********************************************************************
*
* Turn right
*
turn_right:
       .proc
       mov  @angle,r0
       ai   r0,turn_speed              ; Turn right
       andi r0,angle_mask
       mov  r0,@angle
       srl  r0,4
       mov  r0,r1
       ai   r0,dirs
       mov  *r0+,@dx
       mov  *r0,@dy
       srl  r1,2
       mov  r1,@sal_no
       seto @full_redraw_required
       bl   @set_sal
       .endproc
*// turn_right

***************************************************************
*
* Set sprite attribute table
*
set_sal:
       .proc
       li   r0,>0500+(spratb/>80)
       a    @sal_no,r0
       bl   @vwtr
       .endproc
*// set_sal

*********************************************************************
*
* Move forward
*
move_forward:
       .proc
       mov  @x,r0
       a    @dx,r0
       mov  @y,r1
       a    @dy,r1
       bl   @get_map_value
       jeq  move_forward_2
       cb   @block_goal,r2             ; Check for goal
       jne  move_forward_1
       inc  @status                    ; Finish
       jmp  move_forward_3
move_forward_1:
       andi r2,>0100                   ; Test secret door bit
       jeq  move_forward_3             ; If not set we cannot move
       bl   @get_map_address           ; Address needed for open_door
       bl   @open_door                 ; Open secret door
*      Move:
move_forward_2:
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_forward_3:
       .endproc
*// move_forward

*********************************************************************
*
* Move back
*
move_back:
       .proc
       mov  @x,r0
       s    @dx,r0
       mov  @y,r1
       s    @dy,r1
       bl   @get_map_value
       jne  move_back_1
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_back_1:
       .endproc
*// move_back

*********************************************************************
*
* Move left
*
move_left:
       .proc
       mov  @x,r0
       a    @dy,r0
       mov  @y,r1
       s    @dx,r1
       bl   @get_map_value
       jne  move_left_1
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_left_1:
       .endproc
*// move_left

*********************************************************************
*
* Move right
*
move_right:
       .proc
       mov  @x,r0
       s    @dy,r0
       mov  @y,r1
       a    @dx,r1
       bl   @get_map_value
       jne  move_right_1
       mov  r0,@x
       mov  r1,@y
       seto @full_redraw_required
move_right_1:
       .endproc
*// move_right

*********************************************************************
*
* Upload screen loop
*
upload_screen_loop:
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       movb *r5+,*r15
       dec  r8
       jne  upload_screen_loop
       rt
upload_screen_loop_end:
       equ  $
*// upload_screen_loop

*********************************************************************
*
* Move sprites
*
move_sprites:
       .proc
       clr  @has_sprite_moved          ; We will record if any sprite has moved
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  move_sprites_3
move_sprites_1:
       mov  *r4,r0                     ; Active?
       jeq  move_sprites_2
       bl   @check_int                 ; Only if active
       mov  @sprite_type(r4),r1
       mov  @sprite_type_props(r1),r0
       coc  @sprite_can_move,r0        ; Can it move at all?
       jne  move_sprites_2
*      x
       mov  @sprite_x(r4),r0           ; Distance from player x
       mov  @x,r2
       s    r0,r2
       mov  r2,r6
*      y
       mov  @sprite_y(r4),r1           ; Distance from player y
       mov  @y,r3
       s    r1,r3
       mov  r3,r7
*      Check taxi distance and bail out if too big
       abs  r6
       abs  r7
       a    r6,r7
       ci   r7,max_sprite_distance*256
       jhe  move_sprites_2
       ci   r7,1*256
       jle  move_sprites_9
*      Move x, but not faster than the distance to the player
       mov  r2,r2
       jeq  move_sprites_5
       jlt  move_sprites_4
       ci   r2,enemy_speed
       jlt  move_sprites_5
       li   r2,enemy_speed
       jmp  move_sprites_5
move_sprites_4:
       ci   r2,-enemy_speed
       jgt  move_sprites_5
       li   r2,-enemy_speed
move_sprites_5:
*      Move y, but not faster than the distance to the player
       mov  r3,r3
       jeq  move_sprites_7
       jlt  move_sprites_6
       ci   r3,enemy_speed
       jlt  move_sprites_7
       li   r3,enemy_speed
       jmp  move_sprites_7
move_sprites_6:
       ci   r3,-enemy_speed
       jgt  move_sprites_7
       li   r3,-enemy_speed
move_sprites_7:
*      Check map
       mov  r2,r6                      ; Save dx
       a    r2,r0                      ; Add dx to x
       a    r3,r1                      ; Add dy to y
       bl   @get_map_value
       jeq  move_sprites_8
       s    r6,r0                      ; What if we only moved in y?
       bl   @get_map_value
       jeq  move_sprites_8
       a    r6,r0                      ; What if we only moved in x?
       s    r3,r1
       bl   @get_map_value
       jne  move_sprites_2             ; Nope
move_sprites_8:
*      Move
       mov  r0,@sprite_x(r4)
       mov  r1,@sprite_y(r4)
       seto @has_sprite_moved
*      Attack
move_sprites_9:
       ci   r7,>0500
       jgt  move_sprites_2
       bl   @rand
       ci   r0,>e000
       jl   move_sprites_2
       bl   @path_clear
       jne  move_sprites_2
       seto @sprite_attacking(r4)
       li   r0,1
       bl   @sub_health
       bl   @play_shot_2
       jmp  move_sprites_3
*      Next sprite
move_sprites_2:
       ai   r4,sprite_size
       dec  r5
       jne  move_sprites_1
move_sprites_3:
       .endproc
*// move_sprites

*********************************************************************
*
* Move bullets
*
move_bullets:
       abs  @bullet_active
       jeq  move_bullets_0
       a    @bullet_vx,@bullet_x
       a    @bullet_vy,@bullet_y
       li   r0,bullet_accl_z
       a    r0,@bullet_vz
       a    @bullet_vz,@bullet_z
       a    @bullet_speed,@bullet_distance
move_bullets_0:
       rt
*// move_bullets

*********************************************************************
*
* Draw bullets
*
draw_bullets:
       abs  @bullet_active
       jeq  draw_bullets_1
*      Check angle
       mov  @bullet_angle,r0
       s    @angle,r0                  ; Subtract player angle
       ci   r0,-n_rays
       jlt  draw_bullets_1
       ci   r0,n_rays
       jgt  draw_bullets_1
       ai   r0,>78                     ; Center
       mov  @bullet_distance,r1
       srl  r1,8
       movb @bullet_distance_pattern_table(r1),r1    ; Pattern
*      Draw sprite
       movb @bullet_z,*r15             ; y
       swpb r0
       movb r0,*r15                    ; x
       movb r1,*r15                    ; pattern
       movb @bullet_color_byte,*r15    ; color
*      Return
draw_bullets_1:
       rt
bullet_distance_pattern_table:
       byte >30,>34,>38,>3c,>40,>40,>44,>44
       byte >48,>48,>48,>4c,>4c,>4c,>4c,>4c
       byte >4c,>4c
bullet_color_byte:
       byte bullet_color
*// draw_bullets

*********************************************************************
*
* Bullet collides with walls or sprites
*
bullet_collisions:
       .proc
       abs  @bullet_active
       jeq  bullet_collisions_5
*      Check distance
       mov  @bullet_distance,r0
       ci   r0,max_bullet_distance*256
       jgt  bullet_collisions_4
*      Check for wall collision
       mov  @bullet_x,r0
       mov  @bullet_y,r1
       bl   @get_map_address
       movb *r2,r3
       szcb @byte_80,r3
       jeq  bullet_collisions_1
       cb   r3,@block_door
       jne  bullet_collisions_4
       mov  @bullet_distance,r3
       ci   r3,2*256
       jgt  bullet_collisions_4
       bl   @open_door
       jmp  bullet_collisions_4
*      Check for sprite collison
bullet_collisions_1:
       li   r4,sprites                 ; Sprite pointer
       mov  @n_sprites,r5              ; Sprite counter
       jeq  bullet_collisions_5        ; Skip if no sprites
bullet_collisions_2:
       mov  *r4,r2                     ; Active?
       jeq  bullet_collisions_3        ; Skip if not active
       mov  @sprite_type(r4),r2        ; Check if sprite can be attacked
       mov  @sprite_type_props(r2),r2
       coc  @sprite_can_be_attacked,r2
       jne  bullet_collisions_3
       mov  @sprite_x(r4),r2           ; Sprite x
       s    r0,r2                      ; Minus bullet x
       abs  r2                         ; Distance
       ci   r2,>0080                   ; Less than 0.5?
       jgt  bullet_collisions_3        ; Skip if too far
       mov  @sprite_y(r4),r3           ; Sprite y
       s    r1,r3                      ; Minus bullet y
       abs  r3                         ; Distance
       ci   r3,>0080                   ; Less than 0.5?
       jgt  bullet_collisions_3        ; Skip if too far
*      hit
       bl   @hit_sprite
       jmp  bullet_collisions_4        ; Stop when a sprite is hit
bullet_collisions_3:
       ai   r4,sprite_size             ; Next sprite
       dec  r5
       jne  bullet_collisions_2
       jmp  bullet_collisions_5
*      Remove bullet
bullet_collisions_4:
       clr  @bullet_active
bullet_collisions_5:
       bl   @check_int
       .endproc
*// bullet_collisions

*********************************************************************
*
* Player collides with sprite
*
sprite_collisions:
       .proc
       li   r4,sprites
       mov  @n_sprites,r5
       jeq  sprite_collisions_3
       mov  @x,r0
       mov  @y,r1
sprite_collisions_1:
       mov  *r4,r2
       jeq  sprite_collisions_2
       bl   @check_int
       mov  @sprite_type(r4),r2
       mov  @sprite_type_props(r2),r2
       coc  @sprite_can_be_collected,r2
       jne  sprite_collisions_2
       mov  @sprite_x(r4),r2
       s    r0,r2
       abs  r2
       ci   r2,>0080
       jgt  sprite_collisions_2
       mov  @sprite_y(r4),r3
       s    r1,r3
       abs  r3
       ci   r3,>0080
       jgt  sprite_collisions_2
       bl   @collect_sprite
       jmp  sprite_collisions_3
sprite_collisions_2:
       ai   r4,sprite_size
       dec  r5
       jne  sprite_collisions_1
sprite_collisions_3:
       .endproc
*// sprite_collisions

*********************************************************************
*
* Update health bar
*
update_health_bar:
       .proc
       li   r6,health
       li   r7,old_health
       li   r8,max_health
       li   r9,ptrnt3+(23*64)+6
       bl   @update_status_bar
       .endproc
*// update_health_bar

*********************************************************************
*
* Update might bar
*
update_might_bar:
       .proc
       li   r6,might
       li   r7,old_might
       li   r8,max_might
       li   r9,ptrnt3+(23*64)+18
       bl   @update_status_bar
       .endproc
*// update_might_bar

*********************************************************************
*
* Update status bar
*
* r6: Pointer to new value
* r7: Pointer to old value
* r8: Max value
* r9: VDP address
*
update_status_bar:
       .proc
       c    *r6,*r7                    ; Compare old and new
       jeq  update_status_bar_9
*      Column difference
       mov  *r7,r3                     ; Get old value
       srl  r3,3                       ; Old column
       mov  *r6,r2                     ; Get new value
       srl  r2,3                       ; New column
       s    r2,r3                      ; Columns removed
       jeq  update_status_bar_3
       jgt  update_status_bar_3
*      Full columns to add
       mov  *r7,r0                     ; Get old value
       srl  r0,3                       ; Old column
       sla  r0,6                       ; Column offset
       a    r9,r0                      ; Add base address
       li   r1,>ff00                   ; Pattern byte
       mov  r3,r2                      ; Columns removed (negative)
       neg  r2                         ; Columns added
update_status_bar_1:
       bl   @vwad                      ; Set VDP address
       li   r4,8                       ; Number of lines to update
update_status_bar_2:
       movb r1,*r15                    ; Set pattern byte
       movb r1,*r15                    ; Set pattern byte
       dect r4
       jne  update_status_bar_2
       ai   r0,64                      ; Next column
       dec  r2
       jne  update_status_bar_1
*      VDP address for pixels within column
update_status_bar_3:
       mov  *r6,r0                     ; Value
       c    r0,r8                      ; Compare to max value
       jeq  update_status_bar_8
       srl  r0,3                       ; Column
       sla  r0,6                       ; Column offset
       a    r9,r0                      ; Add base address
       mov  r0,r5                      ; Save VDP address
       bl   @vwad
*      Pixels within column
update_status_bar_4:
       li   r1,>00ff                   ; Pattern
       mov  *r6,r2                     ; New value
       andi r2,>0007                   ; Number of pixels to show
       li   r0,8                       ; Number of bits in a byte
       s    r2,r0                      ; Number of pixels to clear
       srl  r1,0                       ; Shift pixels out
       sla  r1,0                       ; Shift remaining pixels back
       swpb r1                         ; Pattern to MSB
       li   r2,8                       ; Number of lines to update
update_status_bar_5:
       movb r1,*r15                    ; Set pattern byte
       movb r1,*r15                    ; Set pattern byte
       dect r2
       jne  update_status_bar_5
*      Full columns to clear
       mov  *r7,r0                     ; Old value
       c    r0,r8                      ; Compare to max value
       jeq  update_status_bar_8
       mov  r3,r2                      ; Columns removed
       jmp  update_status_bar_8
       jlt  update_status_bar_8
       mov  r5,r0                      ; VDP address
update_status_bar_6:
       ai   r0,64                      ; Next column
       bl   @vwad                      ; Set VDP address
       li   r4,8                       ; Number of lines to update
update_status_bar_7:
       clr  *r15                       ; Clear pattern byte
       clr  *r15                       ; Clear pattern byte
       dect r4
       jne  update_status_bar_7
       dec  r2
       jne  update_status_bar_6
update_status_bar_8:
       mov  *r6,*r7                    ; Copy new to old
update_status_bar_9:
       .endproc
*// update_status_bar

*********************************************************************
*
* Add health
*
* r0: health to add
*
add_health:
       a    @health,r0
       ci   r0,max_health
       jle  add_health_1
       li   r0,max_health
add_health_1:
       mov  r0,@health
       rt
*// add_health

*********************************************************************
*
* Subtract health
*
* r0: health to subtract
*
sub_health:
       neg  r0
       a    @health,r0
       jgt  sub_health_1
       dec  @status
       clr  r0
sub_health_1:
       mov  r0,@health
       rt
*// sub_health

*********************************************************************
*
* Add might
*
* r0: might to add
*
add_might:
       a    @might,r0
       ci   r0,max_might
       jle  add_might_1
       li   r0,max_might
add_might_1:
       mov  r0,@might
       rt
*// add_might

*********************************************************************
*
* Subtract might
*
* r0: might to subtract
*
sub_might:
       neg  r0
       a    @might,r0
       jgt  sub_might_1
       clr  r0
sub_might_1:
       mov  r0,@might
       rt
*// sub_might

*********************************************************************
*
* Player hits sprite
*
* r4: Points to sprite structure
*
hit_sprite:
       .proc
*      Find sprite column and display blood stain
       bl   @find_sprite_column
       mov  r0,r0
       jlt  hit_sprite_0
       sla  r0,10                       ; Column * 4 in MSB
       mov  r0,@blood_stain_x
       li   r0,16
       mov  r0,@blood_stain_count
*      Decrease health
hit_sprite_0:
       dec  @sprite_health(r4)
       jgt  hit_sprite_1
*      Sprite is dead
       bl   @remove_sprite
       li   r0,25
       a    r0,@score
       seto @full_redraw_required
       jmp  hit_sprite_3
*      Sprite is not dead
hit_sprite_1:
       mov  @sprite_type(r4),r2
       mov  @sprite_type_next(r2),r3
       jeq  hit_sprite_2
       mov  @sprite_type_texture(r3),@sprite_texture(r4)
       mov  @sprite_type_health(r3),@sprite_health(r4)
       seto @full_redraw_required
hit_sprite_2:
       bl   @play_shot_2
hit_sprite_3:
       .endproc
*// hit_sprite

*********************************************************************
*
* Find the screen column where a sprite is displayed
*
* r4: points to sprite structure
*
* On return r0 contains the screen column number (0-63),
* or -1 if not displayed.
*
find_sprite_column:
       clr  r1                         ; Start column
       li   r2,columns
find_sprite_column_1:
       c    @column_sprite(r2),r4
       jeq  find_sprite_column_2
       ai   r2,column_size
       inc  r1                         ; Next column
       ci   r1,n_rays
       jlt  find_sprite_column_1       ; Loop if more columns
       seto r0                         ; Not found
       jmp  find_sprite_column_5
find_sprite_column_2:
       mov  r1,r0                      ; End column
find_sprite_column_3:
       c    @column_sprite(r2),r4
       jne  find_sprite_column_4
       ai   r2,column_size
       inc  r0
       ci   r0,n_rays
       jlt  find_sprite_column_3       ; Loop if more columns
find_sprite_column_4:
       a    r1,r0                      ; Start + end column
       srl  r0,1                       ; Center column
find_sprite_column_5:
       rt
*// find_sprite_column

*********************************************************************
*
* Collect sprite
*
* r4: Points to sprite structure
*
collect_sprite:
       .proc
       mov  @sprite_type(r4),r5
       bl   @remove_sprite
       mov  @sprite_type_index(r5),r5
       sla  r5,1
       mov  @collect_sprite_table(r5),r0
       jeq  collect_sprite_1
       bl   *r0
       seto @full_redraw_required
collect_sprite_1:
       .endproc
collect_sprite_table:
       data collect_box_sprite
       data collect_barrel_sprite
       data 0                          ; Pillar
       data 0                          ; Pillar broken
       data 0                          ; Grate
       data 0                          ; Stump
       data collect_red_potion_sprite
       data collect_green_potion_sprite
*// collect_sprite

*********************************************************************
*
* Collect box sprite
*
* r4: Points to sprite structure
*
collect_box_sprite:
       .proc
       li   r0,250
       a    r0,@score
       bl   @play_chest
       .endproc
*// collect_box_sprite

*********************************************************************
*
* Collect barrel sprite
*
* r4: Points to sprite structure
*
collect_barrel_sprite:
       .proc
       li   r0,100
       a    r0,@score
       li   r0,16
       bl   @add_might
       bl   @play_chest
       .endproc
*// collect_barrel_sprite

*********************************************************************
*
* Collect red potion sprite
*
* r4: Points to sprite structure
*
collect_red_potion_sprite:
       .proc
       mov  @x,r0
       mov  @y,r1
       bl   @collect_red_potion
       .endproc
*// collect_red_potion_sprite

*********************************************************************
*
* Collect green potion sprite
*
* r4: Points to sprite structure
*
collect_green_potion_sprite:
       .proc
       mov  @x,r0
       mov  @y,r1
       bl   @collect_green_potion
       .endproc
*// collect_green_potion_sprite

*********************************************************************
*
* Collect red potion
*
collect_red_potion:
       .proc
       bl   @find_object
       mov  r8,r0
       jeq  collect_red_potion_1
       movb @block_recess,*r2
       seto @full_redraw_required
       bl   @add_inventory
       bl   @play_chest
collect_red_potion_1:
       .endproc
*// collect_red_potion

*********************************************************************
*
* Collect green potion
*
collect_green_potion:
       .proc
       bl   @find_object
       mov  r8,r0
       jeq  collect_green_potion_1
       movb @block_recess,*r2
       seto @full_redraw_required
       bl   @add_inventory
       bl   @play_chest
collect_green_potion_1:
       .endproc
*// collect_green_potion

*********************************************************************
*
* Collect key
*
collect_key:
       .proc
       bl   @find_object
       mov  r8,r0
       jeq  collect_key_1
       movb @block_recess,*r2
       seto @full_redraw_required
       bl   @add_inventory
       bl   @play_chest
collect_key_1:
       .endproc
*// collect_key

****************************************************
*
* Display score
*
display_score:
       .proc
       mov  @score,r1
       c    r1,@old_score
       jeq  display_score_1
       li   r0,26+32
       li   r2,5
       bl   @calculate_decimal
       bl   @display_score_on_screen
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Display map
*
display_map:
       .proc
*      Set colors
       li   r0,ptrntb
       li   r1,>0000
       bl   @display_map_background
       li   r0,colrtb
       li   r1,>f100
       bl   @display_map_background
*      Display map
       li   r0,ptrntb+(8*8*8)          ; VDP write address
       li   r6,>00c0                   ; One fat pixel = two bits to set
       li   r7,map                     ; Source address
       li   r3,map_width/4             ; Column counter
       li   r8,>003e                   ; For testing end of screen 3rd
*      Column loop
display_map_7:
       bl   @vwad                      ; Set VDP write address
       li   r4,map_height              ; Row counter
*      Line loop
display_map_6:
       clr  r2                         ; Result byte to write to VDP
       li   r5,4                       ; Fat pixels in a byte
*      Bit loop
display_map_8:
       movb *r7+,r1                    ; Get map byte
       andi r1,>8000                   ; Has it been visited?
       jeq  display_map_5              ; Don't set map bit if zero
       soc  r6,r2                      ; Set bits
display_map_5:
       sla  r2,2                       ; Shift result left to accept next bits
       dec  r5
       jne  display_map_8              ; Next bit
       movb r2,*r15                    ; Write 4 fat pixels to VDP
       movb r2,*r15                    ; Write 4 fat pixels to VDP
*      Next line
       coc  r8,r0                      ; End of screen 3rd?
       jne  display_map_9
       ai   r0,>800-62
       bl   @vwad
       jmp  display_map_10
display_map_9:
       inct r0
display_map_10:
       ai   r7,map_width-4             ; Next row of map
       dec  r4
       jne  display_map_6
*      Next column
       ai   r0,->1000+64
       ai   r7,4-map_size
       bl   @check_int
       dec  r3
       jne  display_map_7              ; Next column
*      Display player position
       mov  @sal_no,r0                 ; Which table to update?
       sla  r0,7
       ai   r0,spratb+4
       bl   @vwad                      ; Set VDP address
       clr  r0
       movb @y,r0
       sla  r0,1
       ab   @map_y,r0
       movb r0,*r15
       movb @x,r0
       sla  r0,1
       ab   @map_x,r0
       movb r0,*r15
       li   r0,>4805
       movb r0,*r15
       movb @r0lb,*r15
*      Wait key
display_map_1:
       bl   @wait_int
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_1
       li   r0,KEY_FI
       bl   @check_key
       jne  display_map_1
display_map_2:
       bl   @wait_int
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_3
       li   r0,KEY_FI
       bl   @check_key
       jeq  display_map_2
display_map_3:
       bl   @wait_int
       li   r0,KEY_M
       bl   @check_key
       jne  display_map_3
       li   r0,KEY_FI
       bl   @check_key
       jne  display_map_3
*      Hide player position
       mov  @sal_no,r0                 ; Which table to update?
       sla  r0,7
       ai   r0,spratb+4
       li   r1,>c000
       bl   @vsbw
*      Restore patterns
       li   r0,colrtb
       li   r1,>1100
       bl   @display_map_background
       li   r0,ptrntb
       li   r1,>f000
       bl   @display_map_background
*      Redraw screen
       seto @full_redraw_required
       .endproc
map_x:
       byte 64-8
map_y:
       byte 0-9
*// display_map

*********************************************************************
*
* Display map background
*
* r0: Base address
* r1: Byte to write
*
display_map_background:
       .proc
       ai   r0,(8*8*8)
       mov  r0,r4
*      Top
       li   r2,64*16
       bl   @vsmw
       bl   @check_int
*      Middle
       mov  r4,r0
       ai   r0,>800
       li   r2,64*16
       bl   @vsmw
       bl   @check_int
       .endproc
*// display_map_background

*********************************************************************
*
* Fire bullet
*
fire_bullet:
       .proc
       abs  @bullet_active
       jne  fire_bullet_1
       mov  @might,r0
       jeq  fire_bullet_1
       mov  @x,@bullet_x
       mov  @y,@bullet_y
       li   r3,>8000
       mov  r3,@bullet_z               ; Screen y coordinate
       mov  @angle,r2
       mov  @cos_table(r2),@bullet_vx
       mov  @sin_table(r2),@bullet_vy
       li   r3,bullet_speed_z
       mov  r3,@bullet_vz
       mov  r2,@bullet_angle
       li   r3,>0100                   ; 1.0
       mov  r3,@bullet_speed
       clr  @bullet_distance
       seto @bullet_active
       bl   @play_shot_1
       li   r0,1
       bl   @sub_might
fire_bullet_1:
       .endproc
*// fire_bullet

*********************************************************************
*
* Open door
*
* r0: x FP 8.8
* r1: y FP 8.8
* r2: Map address
*
open_door:
       .proc
       bl   @find_door
       mov  r8,r8
       jeq  open_door_3
       mov  @door_key(r8),r4
       jne  open_door_3
       movb *r2,r3
       andi r3,>7e00
       jeq  open_door_0
       cb   r3,@block_door
       jne  open_door_1
open_door_0:
       movb @block_space,*r2
open_door_1:
       seto @full_redraw_required
       mov  @door_sprite_inits(r8),r4
       jeq  open_door_3
       mov  *r4,r5                     ; Already created?
       jne  open_door_3
       seto *r4+                       ; Mark as created
       mov  *r4+,r5                    ; Number of sprites to create
       jeq  open_door_3
open_door_2:
       bl   @create_sprite
       mov  r6,r6
       jeq  open_door_3
       ai   r4,sprite_init_size
       dec  r5
       jne  open_door_2
open_door_3:
       .endproc
*// open_door

*********************************************************************
*
* Find door
*
* r0: x FP 8.8
* r1: y FP 8.8
*
find_door:
       li   r8,doors
       mov  @n_doors,r9
       jeq  find_door_3
find_door_1:
       cb   r0,@door_x(r8)
       jne  find_door_2
       cb   r1,@door_y(r8)
       jeq  find_door_4
find_door_2:
       ai   r8,door_size
       dec  r9
       jne  find_door_1
find_door_3:
       clr  r8
find_door_4:
       rt
*// find_door

*********************************************************************
*
* Find object
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r8 contains the object or zero if not found.
*
find_object:
       li   r8,objects
       mov  @n_objects,r9
find_object_1:
       cb   r0,@object_map_x(r8)
       jne  find_object_2
       cb   r1,@object_map_y(r8)
       jeq  find_object_4
find_object_2:
       ai   r8,object_size
       dec  r9
       jne  find_object_1
find_object_3:
       clr  r8
find_object_4:
       rt
*// find_object

*********************************************************************
*
* Path clear
* Is path from sprite to player clear?
*
* r4: Sprite pointer
*
* On return eq is set if path is clear.
*
path_clear:
       .proc
       mov  @sprite_x(r4),r0
       mov  @sprite_y(r4),r1
       mov  @sprite_angle(r4),r6
       ai   r6,>8000
       srl  r6,8
       sla  r6,1
       mov  @cos_table(r6),r7
       mov  @sin_table(r6),r8
       li   r6,max_steps
path_clear_1:
       bl   @get_map_value
       jne  path_clear_3
       cb   r0,@x
       jne  path_clear_2
       cb   r1,@y
       jne  path_clear_2
       .pop r11
       c    r1,r1
       rt
path_clear_2:
       a    r7,r0
       a    r8,r1
       dec  r6
       jne  path_clear_1
path_clear_3:
       .endproc
*// path_clear

*********************************************************************
*
* Get map value
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the map byte. r0 and r1 are preserved.
*
get_map_value:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       movb @map(r2),r2
       szcb @byte_80,r2
       rt
*// get_map_value

*********************************************************************
*
* Get map address
*
* r0: x FP 8.8
* r1: y FP 8.8
*
* On return r2 MSB contains the address. r0 and r1 are preserved.
*
get_map_address:
       clr  r2
       movb r1,r2
       srl  r2,2                       ; 2-log2(map_width)
       socb r0,@r2lb
       ai   r2,map
       rt
*// get_map_address

*********************************************************************
*
* Reset sprites
*
reset_sprites:
       li   r5,sprites
       li   r6,max_sprites
reset_sprites_1:
       clr  *r5
       ai   r5,sprite_size
       dec  r6
       jne  reset_sprites_1
       rt
*// reset_sprites

*********************************************************************
*
* Create sprite
*
* r4: Sprite init data
*
* On return r6 contains the address of the sprite, or 0 if it failed
* Uses: r2,r3,r6,r7
*
create_sprite:
       li   r6,sprites
       clr  r7
create_sprite_1:
       mov  *r6,r3                     ; Sprite active?
       jne  create_sprite_2
       inc  *r6                        ; set active
       mov  @sprite_init_type(r4),r2
       mov  r2,@sprite_type(r6)
       movb @sprite_init_x(r4),@sprite_x(r6)
       movb @byte_80,@sprite_x+1(r6)
       movb @sprite_init_y(r4),@sprite_y(r6)
       movb @byte_80,@sprite_y+1(r6)
       mov  @sprite_type_texture(r2),@sprite_texture(r6)
       mov  @sprite_type_speech(r2),@sprite_speech(r6)
       mov  @sprite_type_health(r2),@sprite_health(r6)
       clr  @sprite_attacking(r6)
*      Next sprite
       c    r7,@n_sprites
       jlt  create_sprite_3
       inc  @n_sprites
       jmp  create_sprite_3
create_sprite_2:
       ai   r6,sprite_size
       inc  r7
       ci   r7,max_sprites
       jlt  create_sprite_1
       clr  r6
create_sprite_3:
       rt
*// create_sprite

*********************************************************************
*
* Remove sprite
*
* r4: Address of sprite
*
remove_sprite:
       .proc
       mov  r4,r0
       ai   r0,sprite_size
       mov  r4,r1
       li   r2,sprites+(sprite_size*max_sprites)
       s    r4,r2
       bl   @copy
       li   r0,sprites+(sprite_size*(max_sprites-1))
       clr  *r0
       dec  @n_sprites
       .endproc
*// remove_sprite

*********************************************************************
*
* Add object to inventory
*
* r0: Address of object to add
*
* Does nothing if inventory is full
*
add_inventory:
       .proc
       mov  @inventory_index,r1
       li   r2,inventory_size
add_inventory_0:
       mov  r1,r3
       sla  r3,1                       ; * object_size
       mov  @inventory(r3),r4          ; Get object
       jne  add_inventory_1
       mov  r0,@inventory(r3)          ; Store object
       mov  r1,@inventory_index
       bl   @display_inventory
       jmp  add_inventory_3
add_inventory_1:
       inc  r1
       andi r1,inventory_size-1
       dec  r2
       jne  add_inventory_0
add_inventory_3:
       .endproc
*// add_inventory

*********************************************************************
*
* Remove object from inventory
*
* r1: Inventory index to remove
*
remove_inventory:
       .proc
       sla  r1,1                       ; * object_size
       ai   r1,inventory
       mov  *r1,r0                     ; Get object
       clr  *r1
       bl   @display_inventory
       .endproc
*// remove_inventory

*********************************************************************
*
* Display inventory
*
display_inventory:
       .proc
       mov  @inventory_index,r7
       dec  r7
       andi r7,inventory_size-1
       li   r8,20
       li   r9,3
display_inventory_1:
       mov  r8,r0
       mov  r7,r13
       sla  r13,1                       ; * object_size
       mov  @inventory(r13),r3
       jeq  display_inventory_2
       mov  @object_type(r3),r3
       mov  @object_type_panel_graphics(r3),r3
       jmp  display_inventory_3
display_inventory_2:
       li   r3,empty_patterns
display_inventory_3:
       li   r1,4
       li   r2,4
       bl   @display_panel_graphics
       inc  r7
       andi r7,inventory_size-1
       ai   r8,4
       dec  r9
       jne  display_inventory_1
       .endproc
*// display_inventory

*********************************************************************
*
* Initialize level
*
init_level:
       .proc
       mov  @start_x,@x
       mov  @start_y,@y
       mov  @start_dir,@angle
       mov  @start_dx,@dx
       mov  @start_dy,@dy
       li   r0,max_health
       mov  r0,@health
       clr  @old_health
       li   r0,max_might
       mov  r0,@might
       clr  @old_might
       clr  @score
       seto @old_score
       clr  @status
       seto @full_redraw_required
       seto @has_sprite_moved
       li   r0,>7800
       mov  r0,@pointer_x
       li   r0,>6000
       mov  r0,@pointer_y
       li   r0,>2c0f
       mov  r0,@pointer_pattern
*      Init columns
       li   r1,columns
       li   r2,n_rays
init_level_1:
       seto @column_redraw(r1)
       ai   r1,column_size
       dec  r2
       jne  init_level_1
*      Init map
       seto @map_bank_select
       li   r0,map_sams_page
       mov  r0,@sams_reg_3
       li   r0,>6000
       li   r1,map
       li   r2,map_size
       bl   @copy
*      Init doors
       li   r4,doors
       mov  @n_doors,r5
       jeq  init_level_4
init_level_2:
       mov  @door_sprite_inits(r4),r6
       clr  *r6                        ; Mark as not completed
       ai   r4,door_size
       dec  r5
       jne  init_level_2
init_level_4:
*      Init sprites
       bl   @reset_sprites
       li   r4,sprite_init_data
       mov  *r4+,r5
       jeq  init_level_6
init_level_5:
       bl   @create_sprite
       mov  r6,r6
       jeq  init_level_6
       ai   r4,sprite_init_size
       dec  r5
       jne  init_level_5
init_level_6:
*      Init inventory
       li   r4,inventory
       li   r5,inventory_size
init_level_7:
       clr  *r4+
       dec  r5
       jne  init_level_7
       clr  @inventory_index
       li   r0,objects
       bl   @add_inventory
       bl   @display_inventory
*      Sprite patterns
       li   r0,>0200
       mov  r0,@sams_reg_2
       li   r0,sprptb+(20*32)
       li   r1,SPR20
       li   r2,4*32
       bl   @vmbw
       bl   @set_sal
*      Music
       li   r0,raycaster_module
       bl   @play_module
       .endproc
*// init_level

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       li   r15,vdpwd
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r0,1
       mov  r0,@one
*      Display message
       li   r0,11*32+9
       li   r1,txt_please_wait
       li   r2,14
       bl   @vmbw
*      Init SAMS
       bl   @init_sams
*      Detect TIPI
       bl   @sams_disable_reg_access
       bl   @tipi_detect
       bl   @sams_enable_reg_access
*      Clear scratch pad
       li   r0,padvar
       li   r2,>8400-padvar
       bl   @clear
*      Copy code to pad
       li   r0,cast_ray_loop
       li   r1,cast_ray_loop_pad
       li   r2,cast_ray_loop_end-cast_ray_loop
       bl   @copy
       li   r0,upload_screen_loop
       li   r1,upload_screen_loop_pad
       li   r2,upload_screen_loop_end-upload_screen_loop
       bl   @copy
*      Copy textures to SAMS
       li   r0,texture_bank_select
       li   r1,texture_sams_page
       li   r13,n_texture_banks
one_time_init_0:
       bl   @copy_textures_to_sams
       dec  r13
       jne  one_time_init_0
*      Copy backgrounds to SAMS
       li   r0,background_bank_select
       li   r1,background_sams_page
       bl   @copy_background_to_sams
       bl   @copy_background_to_sams
*      Init speech
       bl   @init_speech
*      Graphics mode
       bl   @graphics_mode
*      Patterns
       li   r0,ptrntb
       li   r1,>f000
       li   r2,>1000
       bl   @vsmw
       li   r0,ptrnt3
       clr  r1
       li   r2,>800
       bl   @vsmw
*      Colors
       li   r0,colrtb
       clr  r1
       li   r2,>1000
       bl   @vsmw
       li   r0,colrt3
       li   r1,>f100
       li   r2,>800
       bl   @vsmw
*      Name table
       li   r0,nametb
       bl   @vwad
       clr  r1
       li   r3,24
one_time_init_4:
       li   r2,32
one_time_init_5:
       movb r1,*r15
       ai   r1,>0800
       dec  r2
       jne  one_time_init_5
       ai   r1,>0100
       andi r1,>0700
       dec  r3
       jne  one_time_init_4
*      Sprite patterns
       li   r0,>0200
       mov  r0,@sams_reg_2
       li   r0,sprptb
       li   r1,SPR0
       li   r2,n_hw_sprite_patterns*32
       bl   @vmbw
*      Sprite attribute tables
       li   r0,spratb
       li   r3,8
       li   r4,sal_compass
one_time_init_1:
       bl   @vwad
       li   r2,(n_high_priority_hw_sprites+n_fixed_hw_sprites-n_compass_hw_sprites)*4
       li   r1,sal
one_time_init_2:
       movb *r1+,*r15
        dec  r2
       jne  one_time_init_2
       li   r2,n_compass_hw_sprites*4
one_time_init_3:
       movb *r4+,*r15
       dec  r2
       jne  one_time_init_3
       ai   r0,>80
       dec  r3
       jne  one_time_init_1
*      Bottom panel
       bl   @display_panel
       .endproc
txt_please_wait:
       text "PLEASE WAIT..."
*// one_time_init

*********************************************************************
*
* Display bottom panel
*
display_panel:
       .proc
       li   r7,display_panel_data
       li   r8,6
display_panel_1:
       mov  *r7+,r0
       mov  *r7+,r1
       mov  *r7+,r2
       mov  *r7+,r3
       bl   @display_panel_graphics
       dec  r8
       jne  display_panel_1
       .endproc
display_panel_data:
       data 0,0,12,sword_mirrored_patterns
       data 20,0,12,status_bars_patterns
       data 0,4,4,score_patterns
       data 4,4,4,map_patterns
       data 8,4,4,attack_patterns
       data 12,4,8,arrows_patterns
*// display_panel

*********************************************************************
*
* Display panel graphics
*
* r0: Column (0-31)
* r1: Row (0-4)
* r2: Width in columns
* r3: Address of graphics data (patterns followed by colors)
*
* Modifies r0-r6
*
display_panel_graphics:
       .proc
       seto @bottom_panel_bank_select
       sla  r0,6                       ; * 64
       ai   r0,ptrnt3
       sla  r1,3
       a    r1,r0
       mov  r0,r4
       li   r6,2
display_panel_graphics_0:
       mov  r2,r5
display_panel_graphics_1:
       bl   @vwad
       li   r1,32
display_panel_graphics_2:
       movb *r3+,*r15
       movb *r3+,*r15
       dect r1
       jne  display_panel_graphics_2
       ai   r0,64
       dec  r5
       jne  display_panel_graphics_1
       mov  r4,r0
       ai   r0,>2000
       dec  r6
       jne  display_panel_graphics_0
       .endproc
*// display_panel_graphics

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       clr  r0
       li   r1,vdp_registers
       li   r2,8
graphics_mode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  graphics_mode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
       .endproc
*      VDP registers
vdp_registers:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte >ff                        ; 3 color tables
       byte ptrntb/>800+>03            ; 3 pattern tables
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte backdrop_color             ; Backdrop color
*// graphics_mode

*********************************************************************
*
* Calculate decimal number
*
* r1: Number to display
* r2: Number of digits
*
calculate_decimal:
       li   r4,decimal_buffer
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
calculate_decimal_1:
       clr  r0
       div  *r3+,r0
       mov  r0,*r4+
       dec  r2
       jne  calculate_decimal_1
       mov  r1,*r4
       rt
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
decimal_buffer:
       bss  10
*// calculate_decimal

*********************************************************************
*
* Display score on screen
*
* Score to display is in @decimal_buffer
*
display_score_on_screen:
       .proc
*      Copy empty patterns to buffer
       seto @bottom_panel_bank_select
       li   r0,empty_patterns+2
       li   r1,display_score_buffer
       li   r2,4
display_score_on_screen_1:
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       mov  *r0+,*r1+
       ai   r0,24
       dec  r2
       jne  display_score_on_screen_1
*      Copy number patterns to buffer
       li   r0,4                       ; X shift
       li   r1,display_score_buffer
       li   r2,5                       ; Number of dígits
       li   r3,decimal_buffer
display_score_on_screen_4:
       mov  *r3+,r4                    ; Get digit
       sla  r4,3                       ; * 8
       ai   r4,PAT0                    ; Add pattern base address
       li   r5,8                       ; Number of pattern rows
       mov  r0,r0
       jne  display_score_on_screen_9
*      Zero shift
display_score_on_screen_10:
       socb *r4+,*r1+                  ; Write byte
       dec  r5
       jne  display_score_on_screen_10
       jmp  display_score_on_screen_13
display_score_on_screen_9:
       ci   r0,4
       jgt  display_score_on_screen_12
*      Shift and one byte
display_score_on_screen_11
       movb *r4+,r6                    ; Get pattern byte
       srl  r6,0                       ; Shift it
       socb r6,*r1+                    ; Write byte
       dec  r5
       jne  display_score_on_screen_11
       jmp  display_score_on_screen_13
*      Shift and two bytes
display_score_on_screen_12:
       clr  r6
       movb *r4+,r6                    ; Get pattern byte
       srl  r6,0                       ; Shift it
       socb r6,*r1                     ; Write byte 1
       ai   r1,8
       socb @r6lb,*r1                  ; Write byte 2
       ai   r1,-7
       dec  r5
       jne  display_score_on_screen_12
*      Next digit
display_score_on_screen_13:
       ai   r0,5                       ; Increase shift
       ci   r0,8
       jlt  display_score_on_screen_8
       ai   r0,-8
       jmp  display_score_on_screen_14
display_score_on_screen_8:
       ai   r1,-8
display_score_on_screen_14:
       dec  r2
       jne  display_score_on_screen_4
*      Copy buffer to screen
       li   r0,ptrnt3+34
       li   r1,display_score_buffer
       li   r2,4
display_score_on_screen_2:
       bl   @vwad
       li   r3,8
display_score_on_screen_3:
       movb *r1+,*r15
       movb *r1+,*r15
       dect r3
       jne  display_score_on_screen_3
       ai   r0,64
       dec  r2
       jne  display_score_on_screen_2
       .endproc
display_score_buffer:
       bss 32
*// display_score_on_screen

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* CPU space to CPU space copy
*
* r0: source (even)
* r1: destination (even)
* r2: number of bytes (even)
*
copy:
       mov  *r0+,*r1+
       dect r2
       jne  copy
       rt
*// copy

*********************************************************************
*
* CPU space clear
*
* r0: start
* r2: number of bytes
*
clear:
       clr  *r0+
       dect r2
       jne  clear
       rt
*// clear

*********************************************************************
*
* CPU space fill
*
* r0: start
* r1: word to fill with
* r2: number of bytes
*
fill:
       mov  r1,*r0+
       dect r2
       jne  fill
       rt
*// fill

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Arcus tangent 2 function
*
* Calculates the angle of the vector with coordinates (x,y) = (r0,r1)
* Uses r2-r3
* Result in r6 as FP 8.8
*
atan2:
       clr  r3                         ; For division
       mov  r1,r1                      ; if (y >= 0) {
       jlt  atan2_4
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_2
*      Q1
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_1
       jlt  !
       li   r6,>2000
       rt
!      mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2                      ; Result in r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       rt                              ;             result = 0x00 + a;
atan2_1:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x40 - a;
       ai   r6,>4000
       rt                              ;         }
atan2_2:                               ;     } else {
*      Q2
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_3
       jlt  !
       li   r6,>6000
       rt
!      mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x80 - a;
       ai   r6,>8000
       rt
atan2_3:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>4000                   ;                 result = 0x40 + a;
       rt                              ;         }
                                       ;     }
atan2_4:                               ; } else {
       neg  r1                         ;     y = -y;
       mov  r0,r0                      ;     if (x >= 0) {
       jlt  atan2_6
*      Q4
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_5
       jlt  !
       li   r6,>e000
       rt
!       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0x100 - a;
       rt
atan2_5:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>c000                   ;                 result = 0xc0 + a;
       rt                              ;         }
atan2_6:                               ;     } else {
*      Q3
       neg  r0                         ;         x = -x;
       c    r1,r0                      ;         if (y <= x) {
       jgt  atan2_7
       jlt  !
       li   r6,>a000
       rt
!
       mov  r1,r2                      ;             int a = lookup(y / x);
       div  r0,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       ai   r6,>8000                   ;                 result = 0x80 + a;
       rt
atan2_7:                               ;         } else {
       mov  r0,r2                      ;             int a = lookup(x / y);
       div  r1,r2
       srl  r2,8
       sla  r2,1
       mov  @atan_table(r2),r6
       neg  r6                         ;             result = 0xc0 - a;
       ai   r6,>c000
       rt                              ;         }
                                       ;     }
                                       ; }
*// atan2

*********************************************************************
*
* Euclidian distance
*
* Calculates the length of the vector with coordinates
* (x,y) = (r0,r1) in FP 8.8 format.
* Result in r7 as FP 8.8
*
euclidian_distance:
       abs  r0
       abs  r1
       ci   r0,>00ff
       jgt  euclidian_distance_1
       ci   r1,>00ff
       jgt  euclidian_distance_1
       srl  r0,4                       ; To FP 12.4
       srl  r1,4                       ; To FP 12.4
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,6                       ; To FP 8.8
       rt
euclidian_distance_1:
       ci   r0,>03ff
       jgt  euclidian_distance_2
       ci   r1,>03ff
       jgt  euclidian_distance_2
       srl  r0,6                       ; To FP 14.2
       srl  r1,6                       ; To FP 14.2
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,4                       ; To FP 8.8
       rt
euclidian_distance_2:
       srl  r0,8                       ; To FP 16.0
       srl  r1,8                       ; To FP 16.0
       sla  r1,4                       ; y * 16
       a    r0,r1                      ; + x
       clr  r7
       movb @distance_table(r1),r7     ; Get distance as FP 6.2
       srl  r7,2                       ; To FP 8.8
       rt
*// euclidian_distance

*********************************************************************
*
* Program files
*
       copy "ray-casting.a99"
       copy "screen-drawing.a99"
       copy "pointer-interface.a99"
       copy "vdp.a99"
       copy "sams.a99"
       copy "tipi.a99"
       copy "speech.a99"
       copy "sound-fx-routines.a99"
       copy "music-player.a99"
       copy "sound-player.a99"

***************************************************************
*
* Data
*
sal_no:
       data 0
bullet_active:
       data 0
bullet_x:
       data 0
bullet_y:
       data 0
bullet_z:
       data 0
bullet_vx:
       data 0
bullet_vy:
       data 0
bullet_vz:
       data 0
bullet_angle:
       data 0
bullet_speed:
       data 0
bullet_distance:
       data 0
blood_stain_x:
       data 0
blood_stain_count:
       data 0
blood_stain_sal:
       byte >30,>f0,>50,>06
       byte >30,>00,>54,>06
       byte >40,>f0,>58,>06
       byte >40,>00,>5C,>06
arrow_click_x:
       data 0
arrow_click_y:
       data 0
arrow_click_pattern:
       data 0
arrow_click_count:
       data 0

**
* Constants
*
byte_00:
       byte >00
byte_01:
       byte >01
byte_80:
       byte >80
block_space:
       byte 0
block_space_secret:
       byte 1
block_door:
       byte 32
block_goal:
       byte 34
block_button:
       byte 36
block_recess:
       byte 38
block_red_potion:
       byte 40
block_green_potion:
       byte 42
block_key:
       byte 44
block_trees:
       byte 46
pointer_pattern_arrow:
       byte >2c
pointer_pattern_target:
       byte >68

       even

**
* Column list
*
columns:
       bss  n_rays*column_size

**
* Sprite list
*
n_sprites:
       data 0
sprites:
       bss  max_sprites*sprite_size

**
* Object types
*
object_type_red_potion:
       data 0
       data potion_red_patterns
object_type_green_potion:
       data 1
       data potion_green_patterns
object_type_key:
       data 2
       data key_patterns

**
* Inventory
*
inventory:
       bss  object_size*inventory_size

***************************************************************
*
* Data files
*

       copy "math_tables.a99"          ; 2K
       copy "sound-fx.a99"
       copy "../audio/raycaster-music.a99"
       copy "sprite-types.a99"
       copy "level.a99"
col_index:
       copy "../TexGen/col-index.a99"
sprite_index:
       copy "../TexGen/sprite-index.a99"
       copy "number-patterns.a99"

upper_ram_max:
       equ  $

***************************************************************
*
* Lower RAM
*
***************************************************************

       aorg >2000

**
*      One time init data
*
       copy "hw-sprite-init.a99"
       copy "hw-sprite-patterns.a99"

lower_ram_max:
       equ  $

**
*      Textures
*
textures:
       equ  >2000

map:
       equ  >3000

**
*      Screen buffer (currently 4k, 6K for full screen)
*
*      Organised as n columns of m bytes
*      First m bytes for column 0, next m bytes for column 1 etc.
*      Each column contains 2 fat (4x1, 16 color) pixels horizontally
*      and m pixels vertically.

screen_buffer:
       equ  >3000

***************************************************************
*
* Cartridge
* Included to calculate label values only.
*
***************************************************************

       aorg >6000
       copy "../panel/bottom-panel.a99"

***************************************************************
*
* End
       end  main
*
***************************************************************


